[{"categories":null,"content":"Lâ€™application est bien, mais Ã§a serait plus sympa si on pouvait changer de morceau. Ã‡a tombe bien, on va intÃ©grer aujourdâ€™hui une playlist musicale !","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"Ã‰couter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":" â€ Afin dâ€™assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  repartir depuis ce chapitre oÃ¹ lâ€™on a configurÃ© le MediaElement. La derniÃ¨re fois, nous avions vu comment tÃ©lÃ©charger de la musique directement depuis lâ€™app. Seulement, câ€™est la mÃªme chanson depuis le dÃ©but ! Lâ€™application serait bien plus sympa si on pouvait changer de morceau, non ? Ã‡a tombe bien, on va y intÃ©grer aujourdâ€™hui une playlist musicale. ","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:0:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"Ã‰couter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"CrÃ©ation de la playlist Pour cela, dÃ©finissons dÃ©jÃ  la liste des morceaux disponibles dans lâ€™application comme ceci : Nom du fichier :MusicPlayerViewModel.cs static readonly MusicTrack[] playlist = new MusicTrack[] { new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1890762\u0026format=mp31\u0026from=b5bSbOTAT1kXawaT8EV9IA%3D%3D%7CGcDX%2BeejT3P%2F0CfPwtSyYA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1890762/mp32/\", Author = \"Alfonso Lugo\", Title = \"Baila\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=619144\u0026format=mp31\u0026from=%2BJv5PkdWd%2BvsByBkyrboJA%3D%3D%7Co%2FKvdc5gcd6iQLjnqacjYA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/619144/mp32/\", Author = \"Pablo GÃ³mez\", Title = \"Devastation (remastered)\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1399476\u0026format=mp31\u0026from=LQFaB9%2FDVAE6QaK%2BsXtl%2FA%3D%3D%7CouuozaATpW3zoEvVwprgRw%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1399476/mp32/\", Author = \"Singularity\", Title = \"How many times\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=946449\u0026format=mp31\u0026from=blTB635bS8UiDVL%2FzZC2Xw%3D%3D%7CQO1Fj6AWgTrjIu7LELLCLA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/946449/mp32/\", Author = \"Julien Gathy\", Title = \"Octave (HQ)\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1026396\u0026format=mp31\u0026from=nWYOo%2FxFcd1oJBINLSQAXg%3D%3D%7CI8xQbXqZfz2bfgmtqxmqyA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1026396/mp32/\", Author = \"dj alike\", Title = \"dj alike (new trance edition)\", } }; Rien dâ€™extraordinaire ici, si ce nâ€™est la dÃ©monstration de lâ€™utilitÃ© de notre Model ! â€ ğŸ’â€ â€ Oh oui, 5 chansons, Ã§a va groover !! ğŸ™Š Mais câ€™est Ã§a oui, moque-toi ! ğŸ˜‚ Le nombre de chansons est limitÃ© Ã  5 pour les besoins de ce cours, mais imagine si on permettait Ã  lâ€™utilisateur dâ€™explorer des titres du monde entier ! â€ Il nâ€™est pas improbable que je rÃ©flÃ©chisse Ã  une suite de ce cours, peut-Ãªtre en vidÃ©o ! Mais revenons Ã  nos moutons. La logique que lâ€™on va implÃ©menter consiste Ã  passer dâ€™un morceau Ã  un autre parmi notre playlist. Câ€™est un peu comme un pointeur qui glisse sur les cases dâ€™un tableau dâ€™Ã©lÃ©ments de type MusicTrack pour dÃ©finir la prochaine musique Ã  jouer. Pour cela, nous allons amÃ©liorer la logique autour de la propriÃ©tÃ© CurrentTrack introduite dans le chapitre prÃ©cÃ©dent avec le code suivant : Nom du fichier :MusicPlayerViewModel.cs #region Properties ... // Une nouvelle propriÃ©tÃ© pour dÃ©finir la position du \"pointeur\" [ObservableProperty] [NotifyPropertyChangedFor(nameof(CurrentTrack))] int currentTrackPosition = 0; // Attention Ã  bien renommer la propriÃ©tÃ© avec un \"C\" majuscule public MusicTrack CurrentTrack =\u003e playlist[CurrentTrackPosition]; #endregion public MusicPlayerViewModel() { // Nous n'avons plus besoin du code ci-aprÃ¨s, Ã  supprimer ! // CurrentTrack = new MusicTrack() // { // ... // }; } On a ajoutÃ© une nouvelle propriÃ©tÃ© nommÃ©e currentTrackPosition qui correspond en quelque sorte Ã  notre pointeur Ã©voquÃ© plus haut. Câ€™est elle qui va dÃ©finir la position de la chanson quâ€™il faut jouer parmi la playlist, grÃ¢ce Ã  ce nouvel attribut : NotifyPropertyChangedFor(). ConcrÃ¨tement, Ã  chaque changement de valeur de la propriÃ©tÃ© currentTrackPosition, cet attribut va dÃ©clencher une notification vers la View pour lâ€™informer que la propriÃ©tÃ© CurrentTrack vient dâ€™Ãªtre mise Ã  jour. En effet, la propriÃ©tÃ© CurrentTrack a Ã©tÃ© adaptÃ©e pour retourner un titre musical depuis la playlist Ã  la position demandÃ©e (playlist[CurrentTrackPosition]). â€ Dâ€™ailleurs, nous nâ€™avons plus besoin dâ€™initialiser CurrentTrack depuis le constructeur du MusicPlayerViewModel ! Tu peux donc supprimer ce bout de code. Câ€™est dÃ©jÃ  lâ€™heure de relancer lâ€™application ! â€ ğŸ’â€ â€ Mais je nâ€™ai vu aucun changement, câ€™est normal ? Exact, câ€™e","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:1:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"Ã‰couter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Binding des composants Attention, rÃ©vÃ©lation : on va dÃ©sormais sâ€™attaquer aux derniers composants factices de lâ€™application ! Si tu te rappelles bien du chapitre sur lâ€™affichage des contrÃ´les de lecture, il nous reste 3 composants de type ImageButton Ã  implÃ©menter : SkipNextButton pour passer Ã  la chanson suivante, SkipPreviousButton pour revenir Ã  la chanson prÃ©cÃ©dente, et RepeatOnceButton pour rejouer la piste musicale (une seule fois). Pour passer Ã  la prochaine chanson, câ€™est trÃ¨s simple. Commence par ajouter la commande suivante dans le ViewModel : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] void GoToNextTrack() { if (CurrentTrackPosition + 1 \u003c playlist.Length) CurrentTrackPosition++; else CurrentTrackPosition = 0; } ... #endregion Puis associe la nouvelle commande au bouton SkipNextButton depuis la View : Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... ImageButton SkipNextButton = new ImageButton // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ { HeightRequest = 75, WidthRequest = 75, Source = \"skip_next.png\" } .BindCommand(\"GoToNextTrackCommand\"); // et voilÃ  la commande associÃ©e ... #endregion Le comportement dÃ©fini dans la mÃ©thode GoToNextTrack() consiste Ã  simplement dÃ©placer dâ€™un cran en avant la position du pointeur sur le tableau. Bien sÃ»r, quand la derniÃ¨re case du tableau est atteinte, alors on retourne au dÃ©but de la playlist. Et si on testait ? Super, on peut enfin Ã©couter dâ€™autres chansons ! â€ ğŸ’â€ â€ Câ€™Ã©tait rapide ! Et pour revenir en arriÃ¨re dans la playlist, on fait juste lâ€™inverse ? Presque ! Pour revenir Ã  la chanson prÃ©cÃ©dente, on va en effet implÃ©menter une logique similaire Ã  une condition prÃ¨s. En effet, jâ€™aimerais dâ€™abord que la chanson redÃ©marre avant de basculer vers la chanson prÃ©cÃ©dente. Je vais tâ€™expliquer comment. Ajoute dÃ©jÃ  la commande suivante dans le ViewModel : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] void GoToPreviousTrack(double elapsedTimeForCurrentTrack) { if (elapsedTimeForCurrentTrack \u003c 2) { // Soit on revient un cran en arriÃ¨re dans la playlist if (CurrentTrackPosition - 1 \u003e= 0) CurrentTrackPosition--; else CurrentTrackPosition = playlist.Length - 1; } else { // Ou bien on rÃ©initialise le morceau en cours // en forÃ§ant la notification vers la View OnPropertyChanged(\"CurrentTrack\"); } } ... #endregion Le comportement dÃ©fini dans la mÃ©thode GoToPreviousTrack() consiste Ã  simplement dÃ©placer dâ€™un cran en arriÃ¨re la position du pointeur sur le tableau. Bien sÃ»r, quand la premiÃ¨re case du tableau est atteinte, alors on bascule Ã  la derniÃ¨re chanson de la playlist. Mais as-tu remarquÃ© la condition imposÃ©e dans le if? On ne doit revenir Ã  la chanson prÃ©cÃ©dente que si la chanson en cours a Ã©tÃ© jouÃ©e depuis moins de 2 secondes. â€ ğŸ’â€ â€ Mais comment va-tâ€™on faire pour obtenir cette information ? Jusquâ€™Ã  prÃ©sent, nous nâ€™avions vu que des commandes sans paramÃ¨tre. Mais cette fois-ci, on va partager lâ€™information TimeTracker.Value en paramÃ¨tre de la commande Ã  associer au SkipPreviousButton. Pour cela, applique les changements suivants dans la View : Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... ImageButton SkipPreviousButton = new ImageButton // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ { HeightRequest = 75, WidthRequest = 75, Source = \"skip_previous.png\" } .BindCommand(\"GoToPreviousTrackCommand\", // et voilÃ  la commande associÃ©e, avec un paramÃ¨tre ! parameterPath: nameof(TimeTracker.Value), parameterSource: TimeTracker); ... #endregion On emploie toujours BindCommand(), mais on utilise deux paramÃ¨tres supplÃ©mentaires pour les besoins de notre mÃ©thode GoToPreviousTrack() : Lâ€™information Ã  passer en paramÃ¨tre (parameterPath), câ€™est le TimeTracker.Value correspondant au temps de lecture Ã©coulÃ©, Et la source de cette propriÃ©tÃ© (parameterSource), câ€™est bien sÃ»r le TimeTracker. Enfin, dans le cas oÃ¹ lâ€™on doit redÃ©marrer la chanson, on fait preuve dâ€™un peu dâ€™astuce en utilisant la mÃ©thode OnPropertyChanged(). En effet,","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:2:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"Ã‰couter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Rejouer le morceau une fois Câ€™est la derniÃ¨re ligne droite de ce cours, accroche-toi ! Pour permettre la rÃ©pÃ©tition dâ€™un morceau, nous devons dâ€™abord ajouter la propriÃ©tÃ© suivante dans le ViewModel : Nom du fichier :MusicPlayerViewModel.cs #region Properties ... [ObservableProperty] bool mustRepeatCurrentTrackOnce; #endregion Il sâ€™agit dâ€™un boolÃ©en classique dont lâ€™Ã©tat sera modifiÃ© via sa commande dÃ©diÃ©e : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] void ToggleRepeatOnce() { MustRepeatCurrentTrackOnce = !MustRepeatCurrentTrackOnce; } ... #endregion Lâ€™idÃ©e est quâ€™Ã  chaque clic de lâ€™utilisateur, on inverse lâ€™Ã©tat du boolÃ©en afin dâ€™activer ou dÃ©sactiver la rÃ©pÃ©tition. Il ne nous reste alors plus quâ€™Ã  associer cette commande au bouton RepeatOnceButton depuis la View : Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... ImageButton RepeatOnceButton = new ImageButton // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"repeat_once.png\", BackgroundColor = Colors.Black, BorderColor = Colors.GreenYellow // On rajoute une bordure colorÃ©e au bouton } .BindCommand(\"ToggleRepeatOnceCommand\"); // Et voilÃ  la commande associÃ©e ... #endregion Comme tu lâ€™auras peut-Ãªtre remarquÃ©, jâ€™ai dÃ©fini une couleur pour le contour du RepeatOnceButton avec la propriÃ©tÃ© BorderColor. Câ€™est pour amÃ©liorer le rendu visuel quand la rÃ©pÃ©tition est enclenchÃ©e ! Pour cela, on va se baser Ã©videmment sur la propriÃ©tÃ© MustRepeatCurrentTrackOnce. Modifie donc la mÃ©thode InitMediaControlPanel() pour appliquer les changements suivants : Nom du fichier :MusicPlayerView.cs void InitMediaControlPanel() { ... RepeatOnceButton.Bind( targetProperty: ImageButton.BorderWidthProperty, path: nameof(MusicPlayerViewModel.MustRepeatCurrentTrackOnce), convert: (bool isEnabled) =\u003e isEnabled ? 2 : 0); } Avec ce code, on joue avec lâ€™Ã©paisseur des bordures (BorderWidth) du bouton RepeatOnceButton selon si lâ€™option de rÃ©pÃ©tition est activÃ©e ou non. En effet, il faut savoir que lâ€™Ã©paisseur du contour est par dÃ©faut nÃ©gative ! On ne risque pas de voir de contour avec une Ã©paisseur nÃ©gative ! Autrement dit, on ne verra aucune bordure Ã  moins de modifier nous-mÃªmes la valeur du BorderWidth. Câ€™est pourquoi, dans le convert, on dÃ©finit une valeur positive pour faire apparaÃ®tre un contour colorÃ© quand MustRepeatCurrentTrackOnce est Ã©gal Ã  True. On voit bien quand la rÃ©pÃ©tition est active. Bon aprÃ¨s, les goÃ»ts et les couleurs, câ€™est autre chose ! â€ ğŸ’â€ â€ Câ€™est trÃ¨s bien, mais Ã§a ne va pas nous aider Ã  boucler le morceau, non ? Câ€™est vrai ! En fait, on va se baser sur le paramÃ¨tre MustRepeatCurrentTrackOnce pour savoir sâ€™il faut redÃ©marrer la chanson Ã  la fin du morceau, ou passer Ã  la chanson suivante. Et cette logique sera dÃ©finie dans le ViewModel avec cette nouvelle mÃ©thode publique : Nom du fichier :MusicPlayerViewModel.cs public void AssessRepeatOrSkip() // La mÃ©thode doit Ãªtre publique { if (MustRepeatCurrentTrackOnce) { // Soit on rÃ©initialise le morceau en cours // en forÃ§ant la notification vers la View OnPropertyChanged(\"CurrentTrack\"); MustRepeatCurrentTrackOnce = false; } else { // Ou bien on se dÃ©place d'une position vers l'avant dans la playlist GoToNextTrack(); } } Selon que MustRepeatCurrentTrackOnce est Ã  True ou False, on fait soit Ã  nouveau appel Ã  la technique du OnPropertyChanged() que lâ€™on a vue plus haut, ou bien on passe Ã  la chanson suivante avec la mÃ©thode GoToNextTrack(). Au fait, on ne veut rÃ©pÃ©ter la chanson quâ€™une seule fois ! Alors nâ€™oublie pas de dÃ©sactiver la rÃ©pÃ©tition en passant la propriÃ©tÃ© MustRepeatCurrentTrackOnce Ã  False. Enfin, pour dÃ©tecter le moment oÃ¹ la chanson se termine, on va se baser sur lâ€™Ã©vÃ¨nement MediaEnded exposÃ© par le MediaElement, comme ceci : Nom du fichier :MusicPlayerView.cs void InitMusicPlayer() { ... MusicPlayer.MediaEnded += MusicPlayer_MediaEnded; } Et câ€™est au moment oÃ¹ lâ€™Ã©vÃ¨nement se dÃ©clenche que lâ€™on va demander Ã  rÃ©pÃ©ter la chanson","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:3:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"Ã‰couter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Conclusion Bon eh bien voilÃ , est-ce que le rÃ©sultat te plaÃ®t ? On peut dÃ©sormais profiter de lâ€™application et Ã©couter quelques titres Ã  la suite, au volume souhaitÃ©, rÃ©Ã©couter quelques passages, et mÃªme tÃ©lÃ©charger les morceaux ! ğŸ˜ â€ Pour rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours, rÃ©fÃ¨re-toi auÂ guide dâ€™installation du projetÂ et repars de lâ€™exemple situÃ© dans le dossierÂ â€œ5 - Music Playerâ€. Mais Ã§a manque un peu dâ€™animation pour une ambiance â€œboÃ®te de nuitâ€â€¦ Or câ€™Ã©tait la promesse du dÃ©but ! On va remÃ©dier Ã  Ã§a dans le prochain article, et ce sera le dernier de cette sÃ©rie !! Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:4:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"Ã‰couter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Aujourdâ€™hui, nous allons voir comment permettre Ã  lâ€™utilisateur de tÃ©lÃ©charger la musique qui est en cours de lecture. Depuis le temps quâ€™on Ã©coute la mÃªme chanson en boucle, je suis sÃ»r que tu rÃªvais de pouvoir la tÃ©lÃ©charger depuis lâ€™application ! ğŸ˜„","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"TÃ©lÃ©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":" â€ Afin dâ€™assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  repartir depuis ce chapitre oÃ¹ lâ€™on a configurÃ© le MediaElement. Et nous voilÃ  reparti pour un nouveau chapitre ! Câ€™est dÃ©jÃ  lâ€™Ã©pisode nÂ°13 de cette sÃ©rie, alors jâ€™espÃ¨re que câ€™est toujours relativement simple Ã  suivre ! Mais il se peut que tu aies des questions ou des remarques. Si câ€™est le cas, pose-les moi en commentaires en bas de lâ€™article ou Ã©cris-moi directement par e-mail (jeanemmanuel.baillat@gmail.com) ! Aujourdâ€™hui, nous allons voir comment permettre Ã  lâ€™utilisateur de tÃ©lÃ©charger la musique qui est en cours de lecture. Depuis le temps quâ€™on Ã©coute la mÃªme chanson en boucle, je suis sÃ»r que tu rÃªvais de pouvoir la tÃ©lÃ©charger depuis lâ€™application ! ğŸ˜„ ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:0:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"TÃ©lÃ©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"CrÃ©ation dâ€™un nouveau ViewModel Avant tout, nous devons mettre en place un nouveau ViewModel pour la vue MusicPlayerView. Pour cela, ajoute une nouvelle classe nommÃ©e MusicPlayerViewModel dans le dossier ViewModels, et dÃ©finis-la avec le code suivant : Nom du fichier :MusicPlayerViewModel.cs using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace NightClub.ViewModels; public partial class MusicPlayerViewModel : ObservableObject { #region Properties #endregion public MusicPlayerViewModel() { } #region Commands #endregion } â€ Si dÃ©chiffrer ce bout de code est difficile pour toi, alors ne te dÃ©courage pas et prends le temps de relire le chapitre sur le MVVM. Ã‰videmment, ce ViewModel ne fait rien pour le moment, mais il est prÃªt Ã  Ãªtre associÃ© Ã  sa View. Ouvre donc le fichier MusicPlayerView.cs et modifie-le comme suit : Nom du fichier :MusicPlayerView.cs ... // Ce using est obligatoire pour retrouver la dÃ©finition du MusicPlayerViewModel using NightClub.ViewModels; namespace NightClub.Views; public class MusicPlayerView : ContentPage { public MusicPlayerView() { Console.WriteLine(\"[NightClub] MusicPlayerView - Constructor\"); // C'est ici que l'association s'opÃ¨re ! BindingContext = new MusicPlayerViewModel(); NavigationPage.SetHasNavigationBar(this, false); BackgroundColor = Colors.DimGray; ... } ... } Comme pour le HomeViewModel que lâ€™on avait associÃ© avec la HomeView, on a modifiÃ© ici le BindingContext de la MusicPlayerView pour lui associer le nouveau MusicPlayerViewModel. Bon, câ€™Ã©tait rapide ! Voyons maintenant comment structurer les donnÃ©es de lâ€™application en dÃ©finissant le Model des pistes musicales. ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:1:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"TÃ©lÃ©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"Une classe pour les pistes musicales Chaque piste musicale lue dans lâ€™application se dÃ©finit par un panel dâ€™informations que lâ€™on va regrouper dans une classe nommÃ©e MusicTrack. Et comme tu lâ€™auras compris, ce nouvel objet fait parti du Model de notre application. Commence donc par crÃ©er un nouveau dossier intitulÃ© Models, puis ajoutes-y une nouvelle classe dÃ©finie par le code suivant : Nom du fichier :MusicTrack.cs namespace NightClub.Models; public class MusicTrack { public string AudioURL { get; set; } public string AudioDownloadURL { get; set; } public string Title { get; set; } public string Author { get; set; } } Pour les besoins de ce cours, 4 propriÃ©tÃ©s de type string sont nÃ©cessaires pour contenir les informations suivantes : Le lien dâ€™Ã©coute du morceau (AudioURL), Le lien de tÃ©lÃ©chargement du morceau (AudioDownloadURL), Le nom du morceau (Title), Et le nom de lâ€™auteur du morceau (Author). Comme il est dÃ©sormais possible de manipuler des pistes musicales, on va ajouter une propriÃ©tÃ© de type MusicTrack au MusicPlayerViewModel pour dÃ©finir la chanson en cours de lecture : Nom du fichier :MusicPlayerViewModel.cs ... using NightClub.Models; // Obligatoire pour utiliser la classe MusicTrack ! namespace NightClub.ViewModels; public partial class MusicPlayerViewModel : ObservableObject { #region Properties [ObservableProperty] MusicTrack currentTrack; #endregion ... } Une propriÃ©tÃ© qui sâ€™adapte parfaitement au dÃ©coupage Model-View-ViewModel (MVVM) puisquâ€™on lâ€™a dÃ©clarÃ©e comme Ã©tant une [ObservableProperty], une annotation fournie par la librairie MVVM Toolkit. Cette annotation va alors gÃ©nÃ©rer tout le code nÃ©cessaire pour dÃ©clencher des Ã©vÃ¨nements (gÃ©nÃ©ralement vers la View) en cas de changement de valeur. En effet, on souhaite calquer les informations affichÃ©es dans la View sur le ViewModel qui lui est associÃ©. â€ ğŸ’â€ â€ Compris ! Mais comment va-tâ€™on faire pour dÃ©finir cette chanson ? Pour lâ€™instant câ€™est facile car notre application ne supporte la lecture que dâ€™une seule chanson. On va donc tout simplement lâ€™initialiser depuis le constructeur du MusicPlayerViewModel, comme ceci : Nom du fichier :MusicPlayerViewModel.cs public MusicPlayerViewModel() { CurrentTrack = new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1890762\u0026format=mp31\u0026from=b5bSbOTAT1kXawaT8EV9IA%3D%3D%7CGcDX%2BeejT3P%2F0CfPwtSyYA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1890762/mp32/\", Author = \"Alfonso Lugo\", Title = \"Baila\", }; } â€ Toutes ces informations sont fournies par Jamendo, un site de musique gratuite et indÃ©pendante. Mais puisquâ€™on a dÃ©fini la piste musicale dans le MusicPlayerViewModel, il nous faut maintenant retravailler la MusicPlayerView pour reconfigurer le MusicPlayer. Pour cela, il va falloir modifier la mÃ©thode InitMusicPlayer() dans le MusicPlayerView, et appliquer le Data Binding Ã  la propriÃ©tÃ© Source du MediaElement : Nom du fichier :MusicPlayerView.cs ... using NightClub.Models; // Obligatoire pour utiliser la classe MusicTrack ! namespace NightClub.Views; public class MusicPlayerView : ContentPage { ... #region MusicPlayer MediaElement MusicPlayer = new MediaElement(); // Et voici la nouvelle dÃ©finition de la mÃ©thode... void InitMusicPlayer() { MusicPlayer.ShouldAutoPlay = true; // ... avec ici le binding sur le MusicPlayer. MusicPlayer.Bind( MediaElement.SourceProperty, nameof(MusicPlayerViewModel.CurrentTrack), convert: (MusicTrack musicTrack) =\u003e MediaSource.FromUri(musicTrack.AudioURL) ); } #endregion ... } Souviens-toi, la propriÃ©tÃ© Source du MediaElement permet de dÃ©finir la source du mÃ©dia quâ€™il doit jouer. Et dÃ©sormais, la propriÃ©tÃ© MusicPlayer.Source est rattachÃ©e dynamiquement Ã  la propriÃ©tÃ© CurrentTrack dÃ©finie dans le MusicPlayerViewModel. Bien-sÃ»r, on nâ€™oublie pas dans le convert de transformer le lien streaming audio (musicTrack.AudioURL) avec la mÃ©thode MediaSource.FromUri(), pour se conformer au type de la propriÃ©tÃ© Source du MediaElement. Et voilÃ  ! Relance ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:2:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"TÃ©lÃ©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"TÃ©lÃ©charger un morceau Continuons maintenant notre petit bout de chemin en implÃ©mentant le bouton de tÃ©lÃ©chargement. Pour cela, on va dÃ©jÃ  associer une action dÃ©clenchÃ©e au clic sur le DownloadButtonâ€¦ Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... // N'oublie pas de transformer le signe \"=\u003e\" en \"=\" ! ImageButton DownloadButton = new ImageButton { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"download.png\", BackgroundColor = Colors.Black } .BindCommand(\"DownloadCurrentTrackCommand\"); // Et voici la commande associÃ©e #endregion â€¦ et dont le comportement sera dÃ©fini dans MusicPlayerViewModel : Nom du fichier :MusicPlayerViewModel.cs ... using CommunityToolkit.Maui.Alerts; // Ce using est nouveau... using CommunityToolkit.Maui.Storage; // ... ainsi que celui-ci ! namespace NightClub.ViewModels; public partial class MusicPlayerViewModel : ObservableObject { ... #region Commands [RelayCommand] async Task DownloadCurrentTrack(CancellationToken cancellationToken) { await Toast .Make($\"[TEST] You have successfully downloaded \\\"{CurrentTrack.Title} - {CurrentTrack.Author}\\\"!\") .Show(cancellationToken); } #endregion } Tu te rappelles de lâ€™annotation [RelayCommand] ? On y avait dÃ©jÃ  eu recours dans le chapitre sur le MVVM.Â Câ€™est elle qui permet Ã  notre mÃ©thode DownloadCurrentTrack() dâ€™Ãªtre appelÃ©e depuis la View ! Et je tâ€™arrÃªte tout de suite, la mÃ©thode Toast() nâ€™a rien Ã  voir avec ton petit-dÃ©jeuner ce matin ğŸ˜„ Cette mÃ©thode fournie par la librairie .NET MAUI Community Toolkit permet dâ€™afficher temporairement un message Ã  lâ€™Ã©cran, Ã  la maniÃ¨re dâ€™une notification directement intÃ©grÃ©e dans lâ€™application. Ã€ ce stade, on peut dÃ©jÃ  tester que notre bouton fonctionne bien : Finalement, ce message est bien utile ! â€ ğŸ’â€ â€ Oui mais tu essaies de mâ€™arnaquer lÃ , Ã§a ne tÃ©lÃ©charge rien du tout ! ğŸ˜„ Je vais te partager le code final juste aprÃ¨sâ€¦ patience ! ğŸ¤“ Juste avant, jâ€™aurais aimÃ© attirer ton attention sur le paramÃ¨tre requis par notre nouvelle commande, le cancellationToken. Il sâ€™agit dâ€™un objet de type CancellationToken qui permet de garder un lien avec le code initiateur de lâ€™appel Ã  la mÃ©thode DownloadCurrentTrack() en cas de demande dâ€™annulation de son exÃ©cution. Câ€™est trÃ¨s utile pour les opÃ©rations un peu longues, par exemple si notre utilisateur dÃ©cidait dâ€™annuler le tÃ©lÃ©chargement par manque de rÃ©seau. On ne va pas implÃ©menter cette fonctionnalitÃ© aujourdâ€™hui, mais Ã§a serait une trÃ¨s bonne amÃ©lioration ! â€ Aller plus loin avec la gestion des demandes dâ€™annulation des opÃ©rations. Passons maintenant au tÃ©lÃ©chargement en lui-mÃªme avec lâ€™implÃ©mentation complÃ¨te de la mÃ©thode : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] async Task DownloadCurrentTrack(CancellationToken cancellationToken) { // On lÃ¨ve une exception quand l'annulation de l'opÃ©ration est demandÃ©e cancellationToken.ThrowIfCancellationRequested(); try { // On a besoin d'un client HTTP pour gÃ©rer nos requÃªtes sur le rÃ©seau HttpClient client = new HttpClient(); client.MaxResponseContentBufferSize = 100000000; // On peut tÃ©lÃ©charger jusqu'Ã  ~100Mo de donnÃ©es par fichier ! // On envoie une requÃªte HTTP vers le lien de tÃ©lÃ©chargement du morceau using var httpResponse = await client.GetAsync( new Uri(CurrentTrack.AudioDownloadURL), cancellationToken); httpResponse.EnsureSuccessStatusCode(); var downloadedImage = await httpResponse.Content.ReadAsStreamAsync(cancellationToken); try { string fileName = $\"{CurrentTrack.Title} - {CurrentTrack.Author}.mp3\"; // Puis on transfÃ¨re les donnÃ©es rÃ©cupÃ©rÃ©es dans un fichier // Note : on a besoin de mettre Ã  jour CommunityToolkit.Maui au moins vers version 5.1.0 var fileSaveResult = await FileSaver.SaveAsync(fileName, downloadedImage, cancellationToken); fileSaveResult.EnsureSuccess(); await Toast.Make($\"File saved at: {fileSaveResult.FilePath}\").Show(cancellationToken); } catch (Exception ex) { await Toast.Make($\"Cannot save file because: {ex.Message}\").Show(cancellationToken); } } ca","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:3:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"TÃ©lÃ©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"On va dÃ©sormais implementer le contrÃ´le du volume ! Comme dans tout bon lecteur musical, on veut que notre utilisateur puisse monter ou baisser le niveau sonore Ã  sa guise.","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":" â€ Afin dâ€™assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  repartir depuis ce chapitre oÃ¹ lâ€™on a configurÃ© le MediaElement. Dans lâ€™article prÃ©cÃ©dent, on avait vu comment dÃ©placer la tÃªte de lecture avec notre propre contrÃ´le de type Slider. Et je sais que câ€™Ã©tait un peu long ! Accroche-toi, on nâ€™est plus trÃ¨s loin de la fin de ce cours ğŸ™‚ Nous allons donc voir aujourdâ€™hui comment implÃ©menter le contrÃ´le du volume, lui aussi avec lâ€™aide dâ€™un Slider. Eh oui, comme dans tout bon lecteur musical, on veut que notre utilisateur puisse monter ou baisser le niveau sonore Ã  sa guise ! ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:0:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"DÃ©finir un niveau de volume Si tu te rappelles bien, dans le chapitre sur lâ€™affichage du volume, nous avions introduit 2 composants : le MuteButton, qui est un contrÃ´le de type ImageButton pour couper le son, et le Slider VolumeTracker, pour contrÃ´ler le volume sonore de maniÃ¨re prÃ©cise. Comme on a lâ€™habitude de le faire, rendons-les maintenant utilisables avec lâ€™aide du Data Binding, et tout Ã§a dans une mÃ©thode dâ€™initialisation nommÃ©e InitVolumeTracker() : Nom du fichier :MusicPlayerView.cs // Comme toujours, chaque morceau de code a sa rÃ©gion ! #region Volume Tracker ... Slider VolumeTracker = new Slider { Minimum = 0, MinimumTrackColor = Colors.Black, Maximum = 100, MaximumTrackColor = Colors.Gray, // On n'a plus besoin de valeur factice, tu peux supprimer cette ligne // Value = 60 }; void InitVolumeTracker() // Et voici la nouvelle mÃ©thode d'initialisation { VolumeTracker.Bind( Slider.ValueProperty, nameof(MusicPlayer.Volume), source: MusicPlayer, convert: (double mediaElementVolume) =\u003e mediaElementVolume * 100, convertBack: (double sliderValue) =\u003e sliderValue / 100); } #endregion Ã‡a va, pas de problÃ¨me jusquâ€™ici ? Finalement, câ€™est trÃ¨s proche de ce quâ€™on a mis en place pour le contrÃ´le de la tÃªte de lecture ! â€ ğŸ’â€ â€ Ah oui ! Mais euhâ€¦ câ€™est nouveau le convertBack ? HÃ©-hÃ©, rien ne tâ€™Ã©chappe ! ConcrÃ¨tement, nous avons associÃ© la position du curseur sur le Slider (VolumeTracker.Value) Ã  la valeur du volume qui est exposÃ© par le MediaElement (MusicPlayer.Volume). Et si tu as bien lu la documentation du Slider, il est dit que lâ€™association de la propriÃ©tÃ© Value du Slider est bidirectionnelle (BindingMode.TwoWay), câ€™est-Ã -dire que : Tout changement de valeur depuis le composant source (ici, le MusicPlayer) aura un impact sur le composant cible (câ€™est le VolumeTracker), Et inversement, toute nouvelle valeur depuis le composant cible (VolumeTracker) aura un impact sur le composant source (MusicPlayer) ! En dâ€™autres mots, si le volume du MediaElement descendait Ã  0, alors le curseur du Slider glisserait tout Ã  gauche, et si lâ€™utilisateur dÃ©plaÃ§ait le curseur tout Ã  droite, alors le volume du MediaElement serait dÃ©fini Ã  1. â€ La propriÃ©tÃ© convert agit dans le sens â€œsource â†’ cibleâ€, alors que la propriÃ©tÃ© convertBack agit dans le sens contraire, â€œcible â†’ sourceâ€. Seulement, il est prÃ©cisÃ© dans la documentation du MediaElement que la propriÃ©tÃ© Volume nâ€™accepte que des valeurs de type double qui sont comprises entre 0 et 1. Câ€™est pourquoi, lors du convert, nous devons multiplier par 100 la valeur du MusicPlayer.Volume pour dÃ©finir la position du curseur sur le Slider (VolumeTracker.Value). Et Ã  lâ€™inverse dans le convertBack, on doit diviser par 100 la valeur choisie par lâ€™utilisateur via le Slider pour modifier correctement la valeur du MediaElement. Enfin, tu nâ€™as plus quâ€™Ã  appeler la mÃ©thode dâ€™initialisation InitVolumeTracker() depuis le constructeur de la page : Nom du fichier :MusicPlayerView.cs ... namespace NightClub.Views; public class MusicPlayerView : ContentPage { public MusicPlayerView() { ... InitVolumeTracker(); // Et voilÃ , avec Ã§a on est bons ! ... } ... } Allez, relance le projet et vÃ©rifie que tu peux modifier le volume ! â€ ğŸ’â€ â€ DÃ©jÃ  !? HÃ©Ã©Ã© mais, et le MuteButton, quâ€™est-ce quâ€™on en fait ? Parfois, il suffit de peu de code pour dÃ©bloquer de nouvelles fonctionnalitÃ©s ! Profites-en pour vÃ©rifier que Ã§a fonctionne bien, on se revoit juste aprÃ¨s pour la suite ! ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:1:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"Couper le son Pour le MuteButton, câ€™est encore plus simple ! En effet, câ€™est dÃ©jÃ  pris en compte par le MediaElement avec la propriÃ©tÃ© ShouldMute de type boolean. Et donc, tout ce que nous avons Ã  faire, câ€™est dÃ©tecter le clic de lâ€™utilisateur sur le bouton et modifier sa valeur. Pour cela, commenÃ§ons par dÃ©finir un nouvel Ã©vÃ¨nement nommÃ© MuteButton_Clicked()â€¦ Nom du fichier :MusicPlayerView.cs #region Events ... void MuteButton_Clicked(object sender, EventArgs e) { MusicPlayer.ShouldMute = !MusicPlayer.ShouldMute; } #endregion â€¦ qui sera initialisÃ© depuis notre mÃ©thode existante, dans le InitMuteButton() : Nom du fichier :MusicPlayerView.cs #region Mute Button Visual States ... void InitMuteButton() { ... MuteButton.Clicked += MuteButton_Clicked; } #endregion Cet Ã©vÃ¨nement est plutÃ´t simple, non ? Il suffit dâ€™inverser la valeur de la propriÃ©tÃ© MusicPlayer.ShouldMute pour alternativement couper ou remettre le son. Bon, mais câ€™est pas tout ! Car si jamais tu voulais essayer, voici ce que cela donne : Le bouton fonctionne bien ! Mais il y a quelque chose qui cloche visuellement. Le son est bien coupÃ© quand on clique une premiÃ¨re fois sur le MuteButton, et il se rÃ©active au clic suivant. Câ€™est pas mal du tout ! Cependant, quelque chose dÃ©range visuellement. Ã‡a donne comme un effet bizarre quand le son est coupÃ© : Lâ€™icÃ´ne du MuteButton aurait du changer pour reprÃ©senter le son coupÃ©, Et le curseur du VolumeTracker aurait du glisser tout Ã  gauche, pour la mÃªme raison. En fait, il aurait fallu que ces deux contrÃ´les sâ€™adaptent au niveau de volume sonoreâ€¦ Aurais-tu une idÃ©e ? ğŸ˜Š â€ ğŸ’â€ â€ Eh bien, on doit modifier la valeur du volume nous-mÃªmes, tout simplement ! HÃ© oui, câ€™est Ã§a ! Mais as-tu pensÃ© Ã  ce qui se passerait quand lâ€™utilisateur rÃ©activera le son ? Lâ€™idÃ©al serait que le volume sonore remonte au niveau oÃ¹ il Ã©tait avant dâ€™Ãªtre coupÃ©. On va donc enregistrer le niveau du volume lorsque lâ€™utilisateur clique sur le MuteButton ! Pour cela, on aura besoin Ã  nouveau dâ€™une variable : Nom du fichier :MusicPlayerView.cs #region Properties bool mustResumePlayback; double savedVolumeBeforeGoingMute; // Une nouvelle variable de type double #endregion La variable savedVolumeBeforeGoingMute doit Ãªtre de type double pour correspondre Ã  la valeur contenue dans la propriÃ©tÃ© Volume du MediaElement. Et maintenant, tu nâ€™as plus quâ€™Ã  modifier lâ€™Ã©vÃ¨nement MuteButton_Clicked() comme ceci : Nom du fichier :MusicPlayerView.cs #region Events ... void MuteButton_Clicked(object sender, EventArgs e) { if (!MusicPlayer.ShouldMute) { // On enregistre bien le volume actuel avant de couper le son... savedVolumeBeforeGoingMute = MusicPlayer.Volume; MusicPlayer.Volume = 0; } else { // ... et quand le son est rÃ©activÃ©, on le rÃ©tablit comme avant ! MusicPlayer.Volume = savedVolumeBeforeGoingMute; } // Et bien sÃ»r ici, Ã§a ne change pas ! MusicPlayer.ShouldMute = !MusicPlayer.ShouldMute; } ... #endregion DÃ©sormais quand on dÃ©tecte que le son va Ãªtre dÃ©sactivÃ©, on garde en mÃ©moire la valeur du volume sonore dans la variable savedVolumeBeforeGoingMute, puis on modifie nous-mÃªmes la valeur de la propriÃ©tÃ© MusicPlayer.Volume Ã  0. Dâ€™ailleurs, je me suis demandÃ© pourquoi ce nâ€™Ã©tait dÃ©jÃ  pas intÃ©grÃ© dans la librairie .NET MAUI Community Toolkit. Et jâ€™ai donc posÃ© la question sur Github directement Ã  lâ€™auteur de la fonctionnalitÃ© ! Câ€™est Ã§a la magie de lâ€™Open Source. â€ En lisant la rÃ©ponse Ã  ma question, tu auras peut-Ãªtre compris quâ€™il existe une autre faÃ§on dâ€™implÃ©menter la dÃ©sactivation du son. Partage-moi ton essai en commentaires ! Allez, voyons ce que Ã§a donne avec ces derniers changements : Ah, eh bien lÃ  câ€™est plus clair quand on coupe le son ! Super ! Mais on doit parer tous les cas dâ€™utilisation possibles et imaginablesâ€¦ Câ€™est ce que nous allons voir juste aprÃ¨s. ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:2:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"Quelques optimisations On va en effet appliquer quelques amÃ©liorations, car il reste deux situations oÃ¹ le comportement de notre fonctionnalitÃ© est bancal. Par exemple, on a un premier cas oÃ¹ le curseur du volume reste bloquÃ© tout Ã  gauche : On a beau cliquer sur le bouton pour rÃ©activer le son, rien ne se passe ! Câ€™est complÃ¨tement normal ! Bien que le volume ait diminuÃ© jusquâ€™Ã  0, la variable MusicPlayer.ShouldMute nâ€™est finalement pas passÃ©e Ã  true. Techniquement, lâ€™utilisateur nâ€™est donc pas en train de rÃ©activer le son ! â€ Essaye de mettre des points de dÃ©boggage dans la mÃ©thode MuteButton_Clicked() ! Dans la deuxiÃ¨me situation inattendue, le son ne se rÃ©active tout simplement pas : AprÃ¨s avoir coupÃ© le son, monter le volume ne change rien du tout ! Mais finalement, lÃ  aussi, rien dâ€™Ã©trange. Dâ€™ailleurs, la cause dâ€™origine est la mÃªme que dans le cas prÃ©cÃ©dent ! En effet, mÃªme si le volume a augmentÃ©, la variable MusicPlayer.ShouldMute nâ€™est jamais passÃ©e Ã  false. Rebelotte donc, lâ€™utilisateur nâ€™est pas en train de rÃ©activer le son ! â€ ğŸ’â€ â€ Mais du coup, tout ce quâ€™on a fait est faux ? Non, pas du tout ! Il y a Ã©videmment des dizaines dâ€™autres faÃ§ons dâ€™implÃ©menter tout Ã§a (et libre Ã  toi dâ€™essayer !), mais dans notre cas, il nous reste juste une petite partie Ã  coder. Mais alors, que manque-tâ€™il dâ€™aprÃ¨s toi ? Un indice : tout commence par le changement de valeur du volume. Et Ã§a, ce nâ€™est possible quâ€™avec le dÃ©placement du curseur sur le Sliderâ€¦ Alors, on va optimiser le comportement actuel avec un nouvel Ã©vÃ¨nement nommÃ© VolumeTracker_DragCompleted() : Nom du fichier :MusicPlayerView.cs #region Events ... void VolumeTracker_DragCompleted(object sender, EventArgs e) { // Il est recommandÃ© de toujours se rÃ©fÃ©rer Ã  l'objet qui est // la source de l'Ã©vÃ¨nement Ã  travers le paramÃ¨tre \"sender\" if (sender is Slider volumeTrackerControl) { if (volumeTrackerControl.Value == 0) { // Le volume sonore doit toujours Ãªtre suffisamment // Ã©levÃ© quand le son est rÃ©activÃ© savedVolumeBeforeGoingMute = 0.2; MusicPlayer.ShouldMute = true; } else if(MusicPlayer.ShouldMute) { // On doit rÃ©activer le son quand le curseur // dÃ©finit une valeur strictement positive MusicPlayer.ShouldMute = false; } } } #endregion Et bien sÃ»r, on nâ€™oublie pas dâ€™initialiser cet Ã©vÃ¨nement depuis la bonne mÃ©thodeâ€¦ Nom du fichier :MusicPlayerView.cs #region Volume Tracker ... void InitVolumeTracker() { VolumeTracker.DragCompleted += VolumeTracker_DragCompleted; ... } #endregion Relance le projet, vÃ©rifie que tout fonctionne, et surtout, profite du rÃ©sultat de tes efforts ! Jâ€™espÃ¨re que tu auras appris plein de nouvelles choses aujourdâ€™hui. De maniÃ¨re gÃ©nÃ©rale, inspire-toi de ce que tu observes pour expÃ©rimenter de nouvelles choses. Et en allant un peu plus loin Ã  chaque fois, tu deviendras de plus en plus Ã  lâ€™aise ! Allez, on se revoit trÃ¨s vite pour un nouveau chapitre ! ğŸ™‚ Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:3:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"Continuons sur notre lancÃ©e avec lâ€™implÃ©mentation du contrÃ´le de la tÃªte de lecture ! Lâ€™idÃ©e est de pouvoir se dÃ©placer Ã  un endroit prÃ©cis du morceau.","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler la tÃªte de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":" â€ Afin dâ€™assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  repartir depuis ce chapitre oÃ¹ lâ€™on a configurÃ© le MediaElement. Dans lâ€™article prÃ©cÃ©dent, on avait dÃ©couvert le MediaElement pour lire des fichiers audio, mais avec lâ€™aide de nos propres contrÃ´les. Tu te rappelles des Sliders quâ€™on avait mis en place ? Ils sont cools mais ils ne servent Ã  rien ! ğŸ˜„ Alors aujourdâ€™hui, nous allons commencer par implÃ©menter le contrÃ´le de la tÃªte de lecture, pour permettre Ã  lâ€™utilisateur de se dÃ©placer Ã  un endroit prÃ©cis du morceau. ","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/:0:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler la tÃªte de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":"Binding des composants Si tu te rappelles bien, dans le chapitre sur lâ€™affichage du temps dâ€™Ã©coute, nous avions introduit 3 composants : ElapsedTime qui est un Label pour afficher le temps Ã©coulÃ© de lecture, TotalTime qui est aussi un Label, mais pour afficher la durÃ©e totale de la piste audio, et enfin le Slider TimeTracker, pour contrÃ´ler la tÃªte de lecture de la piste. Adieu les donnÃ©es factices ! Nous allons dÃ©sormais donner vie Ã  ces composants avec lâ€™aide du Data Binding. Et on isolera tout Ã§a dans une mÃ©thode dâ€™initialisation InitTimeTracker() : Nom du fichier :MusicPlayerView.cs #region Time Tracker // RepÃ¨re bien la rÃ©gion pour ajouter le nouveau code ... void InitTimeTracker() // Voici la nouvelle mÃ©thode d'initialisation { TimeTracker.Bind( Slider.ValueProperty, nameof(MusicPlayer.Position), source: MusicPlayer, convert: (TimeSpan currentPosition) =\u003e currentPosition.TotalSeconds); TimeTracker.Bind( Slider.MaximumProperty, nameof(MusicPlayer.Duration), source: MusicPlayer, convert: (TimeSpan duration) =\u003e duration.TotalSeconds); ElapsedTime.Bind( Label.TextProperty, nameof(MusicPlayer.Position), source: MusicPlayer, stringFormat: \"{0:mm\\\\:ss}\"); TotalTime.Bind( Label.TextProperty, nameof(MusicPlayer.Duration), source: MusicPlayer, stringFormat: \"{0:mm\\\\:ss}\"); } #endregion Oui je sais câ€™est un peu dense, courage ! Tout est dÃ©taillÃ© juste aprÃ¨s. Pour commencer, nous avons modifiÃ© le comportement du TimeTracker pour lui associer deux propriÃ©tÃ©s : la position actuelle du curseur sur le Slider, et la valeur maximale du curseur (quand il est positionnÃ© tout Ã  droite). IntÃ©ressons-nous maintenant dâ€™un peu plus prÃ¨s au MediaElement incarnÃ© par notre composant MusicPlayer. Celui-ci expose justement ce quâ€™il nous faut : la position de la tÃªte de lecture en temps rÃ©el (MusicPlayer.Position), Ã  associer Ã  la position du curseur sur le Slider (TimeTracker.Value), et la durÃ©e totale du morceau (MusicPlayer.Duration), Ã  associer Ã  la valeur maximale du Slider (TimeTracker.Maximum). Enfin, si tu te rappelles bien, le Slider ne peut considÃ©rer que des valeurs de type double. Câ€™est pourquoi nous avons besoin de convertir les valeurs obtenues avec MusicPlayer.Position et MusicPlayer.Duration, depuis le type TimeSpan vers le type double, avec la propriÃ©tÃ© TotalSeconds. â€ ğŸ’â€ â€ Et du coup, lâ€™utilisateur pourra avancer ou reculer la lecture du morceau Ã  la seconde prÃ¨s ! Tout juste ! ğŸ™‚ Voyons maintenant pour les Labels. Pour le composant ElapsedTime, on veut quâ€™il affiche depuis combien de temps le morceau est jouÃ© en se basant lui aussi sur la propriÃ©tÃ© MusicPlayer.Position. Seulement, on ne veut pas afficher nâ€™importe quoi ! On veut en effet afficher une durÃ©e en minutes et en secondes. Pour cela, on a besoin de lui appliquer le format de texte souhaitÃ© avec lâ€™aide du code : {0:mm\\\\:ss}. Pour le composant TotalTime, on veut afficher le temps total dâ€™Ã©coute du morceau en se basant sur la propriÃ©tÃ© MusicPlayer.Duration. Et de la mÃªme faÃ§on, on applique le mÃªme format de texte pour afficher une durÃ©e en minutes et en secondes. â€ Pour plus dâ€™information, voir le StringFormat. Au fait, nâ€™oublie pas de remplacer le signe â€œ=\u003eâ€ par â€œ=â€ Ã  la dÃ©claration de chacun de ces composants ! Sinon Ã§a ne marchera pas puisque le mÃªme objet sera retournÃ© Ã  chaque appel Ã  ces variables. On peut dâ€™ailleurs en profiter aussi pour retirer les valeurs factices quâ€™on avait dÃ©finies par dÃ©faut pour certaines propriÃ©tÃ©s : Text pour les Labels, Maximum et Value pour le Slider. Et voici donc la dÃ©claration actualisÃ©e pour ces 3 composants : Nom du fichier :MusicPlayerView.cs #region Time Tracker Label ElapsedTime = new Label // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ { FontSize = 14, TextColor = Colors.White }.TextCenter(); Slider TimeTracker = new Slider // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ { Minimum = 0, MinimumTrackColor = Colors.LightSalmon, MaximumTrackColor = Colors.Black }; Label TotalTime = new Label // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ { FontSize = 14, Tex","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/:1:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler la tÃªte de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":"ContrÃ´ler la tÃªte de lecture Pour contrÃ´ler la tÃªte de lecture, lâ€™utilisateur doit simplement glisser le curseur du Slider dâ€™un point A Ã  un point B. En dÃ©composant un peu plus son geste, on pourrait dire que : Lâ€™utilisateur doit dâ€™abord poser le doigt sur le curseur Ã  un point A du Slider, Puis il dÃ©placera ce curseur en maintenant son doigt appuyÃ© dessus, Et enfin, il le relÃ¢chera Ã  un point B du Slider en levant son doigt de lâ€™Ã©cran. En lisant cette description, est-ce que Ã§a tâ€™a mis la puce Ã  lâ€™oreille ? â€ ğŸ’â€ â€ Je me rappelle quâ€™on avait mis en place des events pour dÃ©tecter les gestes de lâ€™utilisateurâ€¦ câ€™est Ã§a ? Oui, bravo ! On aura ici besoin de deux Ã©vÃ¨nements du Slider pour : DÃ©tecter le moment oÃ¹ lâ€™utilisateur commence Ã  dÃ©placer le curseur, Et dÃ©tecter quand il le relÃ¢che. Rattachons ces deux Ã©vÃ¨nements Ã  notre TimeTracker depuis la mÃ©thode InitTimeTracker() : Nom du fichier :MusicPlayerView.cs void InitTimeTracker() { ... TimeTracker.DragStarted += TimeTracker_DragStarted; TimeTracker.DragCompleted += TimeTracker_DragCompleted; } â€ On aurait pu tout aussi bien utiliser les commandes fournies par le Slider et travailler depuis le ViewModel, mais on avait dÃ©jÃ  expliquÃ© ici quâ€™il Ã©tait prÃ©fÃ©rable de garder la logique dans la View du fait que le MediaElement est un composant purement UI. Maintenant, dÃ©finis ces nouveaux Ã©vÃ¨nements dans la rÃ©gion des Events avec le code suivant : Nom du fichier :MusicPlayerView.cs #region Events ... void TimeTracker_DragStarted(object sender, EventArgs e) { if (MusicPlayer.CurrentState == MediaElementState.Playing) { mustResumePlayback = true; MusicPlayer.Pause(); } } void TimeTracker_DragCompleted(object sender, EventArgs e) { // Il est recommandÃ© de toujours se rÃ©fÃ©rer Ã  l'objet qui est // la source de l'Ã©vÃ¨nement Ã  travers le paramÃ¨tre \"sender\" if (sender is Slider timeTrackerControl) { // On met Ã  jour la position selon l'endroit oÃ¹ l'utilisateur // a arrÃªtÃ© son doigt MusicPlayer.SeekTo(TimeSpan.FromSeconds(timeTrackerControl.Value)); if (mustResumePlayback) { // La musique reprend si elle Ã©tait jouÃ©e avant que // l'utilisateur dÃ©place le curseur MusicPlayer.Play(); mustResumePlayback = false; } } } #endregion Le premier Ã©vÃ¨nement TimeTracker_DragStarted() correspond au moment oÃ¹ lâ€™utilisateur commence Ã  dÃ©placer le curseur sur le Slider. Quand cela se produit, la lecture du morceau est mise en pause pour ne pas que la musique continue de jouer. Et dâ€™ailleurs, le curseur continuerait de se dÃ©placer tout seul ! Bien sÃ»r, pour que lâ€™expÃ©rience utilisateur soit bonne, il faut que la lecture du morceau reprenne aussitÃ´t que lâ€™utilisateur a terminÃ© son mouvement. Pour cela, nous devons garder en mÃ©moire le fait de devoir reprendre la lecture avec lâ€™aide de la variable mustResumePlayback. â€ ğŸ’â€ â€ Mais dâ€™oÃ¹ elle sort cette variable ? Jamais vue ! ğŸ˜„ Câ€™est normal, on va lâ€™ajouter tout de suite ! Nous avons une nouvelle rÃ©gion dÃ©diÃ©e en haut de la classe : Nom du fichier :MusicPlayerView.cs #region Properties bool mustResumePlayback; #endregion Pour le second Ã©vÃ¨nement TimeTracker_DragCompleted(), câ€™est le moment oÃ¹ lâ€™utilisateur a fini de dÃ©placer le curseur sur le Slider. Quand cela arrive, on repÃ¨re la position du curseur pour alors rÃ©ajuster la tÃªte de lecture du MusicPlayer conformÃ©ment. Pour cela, on a recours Ã  la mÃ©thode SeekTo() exposÃ©e par la classe du MediaElement, avec un temps de rÃ©fÃ©rence pour paramÃ¨tre (au format TimeSpan). â€ Cela aura un effet immÃ©diat sur la valeur sur la propriÃ©tÃ© MusicPlayer.Position. Enfin, la lecture du morceau reprendra aussitÃ´t aprÃ¨s, Ã  partir de la nouvelle position choisie. Relance le projet et vÃ©rifie que tu peux avancer ou reculer dans le morceau ! Et hop, je reviens au tout dÃ©but du morceau ! Tu viens de terminer lâ€™implÃ©mentation dâ€™une belle fonctionnalitÃ© pour lâ€™utilisateur, bravo ! La prochaine fois, nous verrons comment implÃ©menter la gestion du volume. Ã€ trÃ¨s vite ! Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installat","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/:2:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"ContrÃ´ler la tÃªte de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":"Notre application prend forme ! Mais ce nâ€™est que visuel pour le momentâ€¦ Dans ce chapitre, on va dÃ©couvrir comment jouer de la musique depuis lâ€™application !","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"Ã‰couter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":" â€ Pour assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours. Pour cela, rÃ©fÃ¨re-toi au guide dâ€™installation du projet et repars de lâ€™exemple situÃ© dans le dossier â€œ4 - All Media Controlsâ€. Avant dâ€™entamer ce nouveau chapitre, je voulais te fÃ©liciter pour tout ce chemin parcouru ! Maintenant quâ€™on a bien avancÃ© sur la partie visuelle, on va pouvoir dÃ©velopper le cÅ“ur de lâ€™application et ainsi la rendre un peu plus fonctionnelle. Et sâ€™il y a bien une fonctionnalitÃ© Ã  implÃ©menter en prioritÃ©, câ€™est la lecture de titres musicaux ! ","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:0:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"Ã‰couter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Le MediaElement Dans lâ€™univers du mobile, la manipulation des mÃ©dias est complÃ¨tement diffÃ©rente dâ€™un systÃ¨me Ã  un autre. Heureusement, Microsoft nous simplifie la vie avec son Community Toolkit qui propose justement de quoi lire des fichiers audio depuis nâ€™importe quelle plateforme: le MediaElement ! Dâ€™aprÃ¨s la documentation, ce composant est fourni dans un paquet NuGet qui lui est dÃ©diÃ©. Pour installer cette dÃ©pendance, ouvre le gestionnaire de paquets NuGet et recherche la librairie nommÃ©e CommunityToolkit.Maui.MediaElement. Une fois trouvÃ©e, ajoute la version la plus rÃ©cente au projet et accepte toutes les licences associÃ©es : â€ Un fichier ReadMe.txt sâ€™ouvre automatiquement dans Visual Studio. Il donne des indications supplÃ©mentaires que nous allons appliquer pour utiliser le MediaElement. Maintenant que la librairie est ajoutÃ©e au projet, il reste une derniÃ¨re Ã©tape pour utiliser le composant MediaElement. En effet, il est nÃ©cessaire de lâ€™initialiser au dÃ©marrage de lâ€™application dans le fichier MauiProgram.cs. Ouvre donc ce fichier et modifie la mÃ©thode CreateMauiApp() de la faÃ§on suivante : Nom du fichier :MauiProgram.cs public static MauiApp CreateMauiApp() { Console.WriteLine(\"[NightClub] MauiProgram - CreateMauiApp\"); var builder = MauiApp.CreateBuilder() .UseMauiCommunityToolkit() .UseMauiCommunityToolkitMarkup() // Tu dois ajouter la ligne ci-dessous: .UseMauiCommunityToolkitMediaElement() .UseMauiApp\u003cApp\u003e(); return builder.Build(); } â€ ğŸ’â€ â€ Ok, mais quâ€™est-ce quâ€™elle fait exactement cette mÃ©thode UseMauiCommunityToolkitMediaElement() ? Bon rÃ©flexe ! Quand on manipule des nouveaux bouts de code, câ€™est toujours mieux de comprendre ce quâ€™ils dÃ©clenchent derriÃ¨re. Et dans le cas prÃ©sent, le code est open-source et peut Ãªtre consultÃ© ici. Sans grande surprise, la mÃ©thode UseMauiCommunityToolkitMediaElement() nâ€™a pour but que de mettre Ã  disposition le fameux MediaElement pour notre application. Dans les grandes lignes, cela consiste Ã  prÃ©ciser quelles classes implÃ©mentent son comportement, pour chacune des plateformes ciblÃ©es. â€ Pour plus dâ€™information, consulte la documentation sur les contrÃ´les personnalisÃ©s. Ã‡a yâ€™est, on va pouvoir Ã©couter de la musique ! ","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:1:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"Ã‰couter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Faites du bruit ! Voyons dÃ©sormais comment dÃ©finir une instance du MediaElement dans la vue MusicPlayerView. â€ ğŸ’â€ â€ Mais finalement, est-ce quâ€™on ne devrait pas considÃ©rer le MediaElement comme un service et lâ€™ajouter au ViewModel ? Câ€™est une trÃ¨s bonne remarque ! En effet, dans le chapitre sur le MVVM, on a prÃ©sentÃ© la View comme la couche correspondant Ã  lâ€™interface utilisateur. En toute logique, on pourrait donc penser que la lecture de mÃ©dias intervient uniquement dans le ViewModel ! Seulement, aprÃ¨s avoir lu la documentation, tu constateras que le MediaElement fournit les contrÃ´les visuels de base pour manipuler des mÃ©dias selon la plateforme cible. Et mÃªme si nous ne les utiliserons pas (puisque nous crÃ©ons nos propres contrÃ´les), le MediaElement est bien un Ã©lÃ©ment de lâ€™interface utilisateur ! Et câ€™est pour respecter le dÃ©coupage du MVVM que je prÃ©fÃ¨re dÃ©finir une instance du MediaElement dans la vue MusicPlayerView. â€ Il est tout Ã  fait possible dâ€™accomplir la mÃªme chose en plaÃ§ant le MediaElement dans le ViewModel au lieu de la View, mais il y a des chances que cela complexifie la maintenance du projet. Ouvre donc le fichier MusicPlayerView.cs, puis dÃ©finis une nouvelle propriÃ©tÃ© de type MediaElement dans la region dÃ©diÃ©e aux contrÃ´les, ainsi quâ€™une mÃ©thode InitMusicPlayer() pour lâ€™initialiser : Nom du fichier :MusicPlayerView.cs #region Controls ... #region MusicPlayer // Et pourquoi pas une nouvelle rÃ©gion ! MediaElement MusicPlayer = new MediaElement(); void InitMusicPlayer() { MusicPlayer.ShouldAutoPlay = true; string trackURL = \"https://prod-1.storage.jamendo.com/?trackid=1890762\u0026format=mp31\u0026from=b5bSbOTAT1kXawaT8EV9IA%3D%3D%7CGcDX%2BeejT3P%2F0CfPwtSyYA%3D%3D\"; MusicPlayer.Source = MediaSource.FromUri(trackURL); } #endregion ... #endregion Avec le paramÃ¨tre ShouldAutoPlay, on configure notre nouveau contrÃ´le pour automatiquement jouer le prochain titre, aussitÃ´t quâ€™il est dÃ©fini. En effet, nos boutons sont toujours factices, or on a besoin dâ€™entendre de la musique pour vÃ©rifier que le MediaElement fonctionne ! â€ ğŸ’â€ â€ Et la musique en question, câ€™est du streaming audio ? Oui câ€™est Ã§a ! Pour notre application, jâ€™ai rÃ©cupÃ©rÃ© quelques chansons depuis Jamendo, un site Web gratuit de musique produite par des artistes indÃ©pendants. Comme tu as du le remarquer, nous avons donc dÃ©fini un morceau Ã  jouer par dÃ©faut Ã  travers la variable trackURL. En effet, cette URL est alors dÃ©clarÃ©e comme une Source de mÃ©dia pour le MediaElement, avec lâ€™aide de la mÃ©thode MediaSource.FromUri(). Retournons maintenant au constructeur de notre page. Dans un premier temps, nous devons initialiser le MediaPlayer avec la mÃ©thode InitMusicPlayer() que lâ€™on vient de prÃ©senter. Enfin, nous devons Ã©galement rajouter ce composant en tant quâ€™Ã©lÃ©ment de la vue pour le rendre disponible. Autrement, il ne serait pas dÃ©tectÃ© par la page et ne pourrait pas fonctionner ! Voici donc Ã  quoi ressemble dÃ©sormais le constructeur de la vue MusicPlayerView : Nom du fichier :MusicPlayerView.cs using CommunityToolkit.Maui.Views; // Attention Ã  bien ajouter ce using ! ... namespace NightClub.Views; public class MusicPlayerView : ContentPage { public MusicPlayerView() { Console.WriteLine(\"[NightClub] MusicPlayerView - Constructor\"); NavigationPage.SetHasNavigationBar(this, false); BackgroundColor = Colors.DimGray; InitMusicPlayer(); // On initialise le contrÃ´le avec sa mÃ©thode dÃ©diÃ©e InitMuteButton(); Content = new Grid { RowDefinitions = Rows.Define( Stars(60), Stars(40)), RowSpacing = 0, Children = { MusicPlayer, // Et on ajoute le contrÃ´le au contenu de la page ! TopLayout.Row(0), BottomLayout.Row(1) } }; } ... } â€ Il nâ€™est pas nÃ©cessaire de prÃ©ciser oÃ¹ lâ€™Ã©lÃ©ment sera dÃ©fini dans la grille. En effet, le MusicPlayer restera de toute maniÃ¨re invisible pour lâ€™utilisateur ! Et si on faisait un essai ? Prends dâ€™abord le temps de rÃ©gler le volume de ton appareil de sorte Ã  ce que cela ne soit ni trop fort, ni trop faible. Puis, relance le projet pour dÃ©marrer lâ€™applica","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:2:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"Ã‰couter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"ContrÃ´ler la lecture du mÃ©dia Maintenant quâ€™on a vÃ©rifiÃ© que la lecture de mÃ©dia fonctionnait, ce serait mieux de pouvoir la contrÃ´ler directement avec le bouton â€œPlayâ€ ! Suivant le mÃªme principe que tout Ã  lâ€™heure, initialisons le contrÃ´le PlayButton via une nouvelle mÃ©thode InitMediaControlPanel(), appelÃ©e depuis le constructeur de la page. Voici les modifications apportÃ©es Ã  la vue MusicPlayerView : Nom du fichier :MusicPlayerView.cs public class MusicPlayerView : ContentPage { public MusicPlayerView() { ... InitMusicPlayer(); InitMediaControlPanel(); // Une nouvelle mÃ©thode d'initialisation ... InitMuteButton(); ... } ... #region Media Control Panel ... // Le signe â€œ=\u003eâ€ a Ã©tÃ© remplacÃ© par â€œ=â€ ImageButton PlayButton = new ImageButton { CornerRadius = 50, HeightRequest = 100, WidthRequest = 100, BackgroundColor = Colors.Black, Source = \"play.png\" }; void InitMediaControlPanel() // ... dont voici la dÃ©finition ! { PlayButton.Bind( targetProperty: ImageButton.SourceProperty, source: MusicPlayer, path: nameof(MusicPlayer.CurrentState), convert: (MediaElementState currentState) =\u003e currentState != MediaElementState.Playing ? \"play.png\" : \"pause.png\"); PlayButton.Clicked += PlayButton_Clicked; } ... #endregion } Dans un premier temps, on souhaite que lâ€™icÃ´ne associÃ©e Ã  notre bouton central change dâ€™apparence selon si la chanson est en train dâ€™Ãªtre jouÃ©e (image: pause.png) ou pas (image: play.png). Pour cela, on applique la technique du Binding (cf: MVVM) sur la propriÃ©tÃ© Source du PlayButton qui nâ€™est autre que la propriÃ©tÃ© pour dÃ©finir lâ€™icÃ´ne du bouton. Voici donc la logique mise en place pour en modifier la valeur automatiquement : On surveille les changements de valeur de la propriÃ©tÃ© CurrentState rattachÃ©e Ã  lâ€™objet MusicPlayer, Et on modifie lâ€™image du PlayButton selon si la valeur du CurrentState Ã©quivaut Ã  lâ€™Ã©tat de lecture ou lâ€™Ã©tat de pause. â€ Attention Ã  bien remplacer le signe â€œ=\u003eâ€ par â€œ=â€ Ã  la dÃ©claration du PlayButton. En effet, on ne veut crÃ©er quâ€™une seule instance dâ€™ImageButton et la modifier dans la mÃ©thode InitMediaControlPanel(). Ensuite, on dÃ©finit un comportement spÃ©cifique au clic de lâ€™utilisateur sur le PlayButton avec la mÃ©thode PlayButton_Clicked(). Voici Ã  quoi correspond cette mÃ©thode : Nom du fichier :MusicPlayerView.cs public class MusicPlayerView : ContentPage { ... #region Events // Quand on aime l'organisation, on utilise les rÃ©gions ! protected override void OnAppearing()... protected override void OnDisappearing()... void PlayButton_Clicked(object sender, EventArgs e) { if (MusicPlayer.CurrentState != MediaElementState.Playing) { MusicPlayer.Play(); } else { MusicPlayer.Pause(); } } #endregion } Comme tu peux le voir, cet Ã©vÃ©nement est plutÃ´t simple. Ã€ chaque clic, on dÃ©tecte quel est lâ€™Ã©tat actuel du lecteur de musique, et selon, on demande la mise en lecture ou la mise en pause du morceau. VoilÃ , câ€™est tout pour ce chapitre. Recompile le projet et mets en pause la musique ! Le morceau est jouÃ© dÃ¨s que la page du lecteur de musique apparaÃ®t, puis on peut stopper la lecture avec le bouton pause. Quel plaisir de pouvoir interagir avec notre app, nâ€™est-ce pas ? Personnellement, câ€™est la partie que je prÃ©fÃ¨re dans le dÃ©veloppement dâ€™une application ! Ã‡a se concrÃ©tise et ce nâ€™est que le dÃ©but. La prochaine fois, on verra comment implÃ©menter la gestion du volume et de la tÃªte de lecture. Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:3:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"Ã‰couter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Pour valider les nouvelles fonctionnalitÃ©s dâ€™une application, il vaut mieux les tester dans un environnement isolÃ©. En effet, tu ne voudrais pas risquer les donnÃ©es de tes utilisateurs ! DÃ©couvre alors comment configurer diffÃ©rents environnements pour ton application mobile.","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Que ce soit pour le dÃ©veloppement dâ€™applications mobiles, de logiciels ou de sites Web, il est courant de mettre en place plusieurs environnements pour son projet. En effet, cela facilite le test de nouvelles fonctionnalitÃ©s sans risquer dâ€™impacter les donnÃ©es de nos utilisateurs. Dans le cadre de cet article, nous verrons comment une application .NET MAUI peut cibler diffÃ©rents environnements, grÃ¢ce Ã  plusieurs configurations de projet. â€ Pour simplifier la lecture de cet article, nous nous concentrerons uniquement sur les plateformes iOS \u0026 Android. Cependant, le procÃ©dÃ© est similaire pour les autres plateformes. ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:0:0","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Identifier toutes les configurations nÃ©cessaires au projet Dans un premier temps, tu dois dÃ©terminer combien de configurations diffÃ©rentes tu as besoin selon le nombre dâ€™environnements crÃ©Ã©s pour ton projet. Cependant, si tu nâ€™es quâ€™au dÃ©but de ton projet, tu ne disposes peut-Ãªtre que dâ€™un environnement de dÃ©veloppement. Voici donc quelques pistes de rÃ©flexion pour tâ€™aider : Es-tu seulÂ·e Ã  dÃ©velopper cette application ? Y-a-tâ€™il des testeurs dans ton Ã©quipe ? Ton projet est-il soumis Ã  des critÃ¨res de sÃ©curitÃ© ou de performance ? Est-ce que tu dois lâ€™exposer au client avant sa publication ? â€ Par dÃ©faut, il est important dâ€™isoler lâ€™environnement de production de ton environnement de dÃ©veloppement. Pour notre dÃ©monstration, nous nous rÃ©fÃ©rerons aux 3 environnements suivants : une configuration â€œDEVâ€ pour travailler de maniÃ¨re totalement isolÃ©e sur sa machine (i.e. â€œen localâ€) et ne pas impacter lâ€™activitÃ© des autres dÃ©veloppeurs de son Ã©quipe, une configuration â€œTESTâ€ pour faire valider tous les dÃ©veloppements avant leur publication, et une configuration â€œPRODâ€ qui reprÃ©sente lâ€™Ã©tat final de lâ€™application, une fois disponible sur les stores. Allez, il est temps de passer Ã  la pratique ! Dans la prochaine section, nous allons crÃ©er ces 3 configurations pour exÃ©cuter notre application mobile dans 3 environnements distincts. â€ Je tâ€™invite Ã  sauter la partie suivante dans le cas oÃ¹ tu aurais dÃ©jÃ  dÃ©fini toutes les configurations nÃ©cessaires Ã  ton projet dans Visual Studio. ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:1:0","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"CrÃ©er les diffÃ©rentes configurations du projet dans Visual Studio Maintenant que nous avons identifiÃ© tous les environnements ciblÃ©s, voyons comment crÃ©er les diffÃ©rentes configurations pour notre application. Commence par ouvrir le fichier de configuration du projet dans Visual Studio. Comment accÃ©der au fichier de configuration du projet ? Il est possible dâ€™accÃ©der au fichier de configuration Ã  lâ€™aide dâ€™un clic droit sur le projet dans Visual Studio. Le fichier de configuration dâ€™un projet se termine par lâ€™extension .csproj et peut Ãªtre Ã©ditÃ© par nâ€™importe quel Ã©diteur de texte (e.g. Visual Studio Code). On le retrouve gÃ©nÃ©ralement via lâ€™explorateur de fichiers Ã  la racine du projet. Une fois le fichier .csproj ouvert, ajoute Ã  la fin du fichier le code suivant : Nom du fichier :MultiEnvMauiApp.csproj \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e ... \u003cPropertyGroup\u003e \u003cConfigurations\u003eDEV;TEST;PROD\u003c/Configurations\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e Nous venons dâ€™ajouter un paramÃ¨tre qui, comme son nom lâ€™indique, dÃ©finit les 3 nouvelles configurations possibles du projet : â€œDEVâ€, â€œTESTâ€ et â€œPRODâ€. Nous pouvons alors personnaliser la configuration du projet pour chacun des environnements ciblÃ©s. Pour cela, rajoute le code suivant Ã  la fin du fichier .csproj : Nom du fichier :MultiEnvMauiApp.csproj \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e ... \u003cPropertyGroup Condition=\" '$(Configuration)' == 'DEV' \"\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'TEST' \"\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'PROD' \"\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e Comme tu lâ€™auras remarquÃ©, nous avons ajoutÃ© une condition dâ€™exÃ©cution Ã  chacun de ces nouveaux groupes de propriÃ©tÃ©s. De cette faÃ§on, Visual Studio pourra appliquer la bonne configuration selon lâ€™environnement ciblÃ©. Voyons maintenant pour ce qui est du contenu en lui-mÃªme (Ã  adapter selon tes besoins) : Nom du fichier :MultiEnvMauiApp.csproj \u003cPropertyGroup Condition=\" '$(Configuration)' == 'DEV' \"\u003e \u003cDebugSymbols\u003etrue\u003c/DebugSymbols\u003e \u003cOptimize\u003efalse\u003c/Optimize\u003e \u003cMtouchDebug\u003etrue\u003c/MtouchDebug\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'TEST' \"\u003e \u003cDebugSymbols\u003efalse\u003c/DebugSymbols\u003e \u003cOptimize\u003etrue\u003c/Optimize\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'PROD' \"\u003e \u003cDebugSymbols\u003efalse\u003c/DebugSymbols\u003e \u003cOptimize\u003etrue\u003c/Optimize\u003e \u003c/PropertyGroup\u003e Dans notre cas, on veut pouvoir dÃ©bogguer lâ€™application quand elle tourne en â€œDEVâ€, mais pas quand elle tourne en â€œTESTâ€ ou en â€œPRODâ€. On a donc recours au paramÃ¨tre DebugSymbols pour activer le dÃ©boggage de lâ€™application, tandis que le paramÃ¨tre Optimize permet dâ€™optimiser les performances de lâ€™app et son poids. â€ En raison dâ€™un problÃ¨me connu des Ã©quipes de Visual Studio, au moment de lâ€™Ã©criture de cet article, il est nÃ©cessaire dâ€™appliquer \u003cMtouchDebug\u003etrue\u003c/MtouchDebug\u003e pour chaque configuration de dÃ©boggage. VoilÃ , on en a fini avec le fichier .csproj ! Mais aprÃ¨s avoir sauvegardÃ© ce fichier, il est fort possible que Visual Studio affiche une petite icÃ´ne rouge. Heureusement, câ€™est tout Ã  fait normal ! Visual Studio est rarement content quâ€™on bidouille les rÃ©glages du projet sans passer par son interface graphique. Le message indique quâ€™il y a un problÃ¨me dâ€™association des configurations. En effet, Visual Studio ne sait pas encore quoi faire de nos configurations â€œDEVâ€, â€œTESTâ€ et â€œPRODâ€. Il nous faut donc aller un peu plus loin en dÃ©finissant leur comportement au niveau de la solution. Pour Visual Studio, une solution est comme un espace de travail : elle peut contenir plusieurs projets en mÃªme temps. Or il est possible de gÃ©rer des configurations pour la solution, comme pour les projets ! Et pour que cela fonctionne, chaque configuration de la solution doit Ãªtre associÃ©e Ã  une configuration de chaque projet prÃ©sent dans lâ€™espace de travail. Tu vas vite comprendre. Commence par ouvrir les paramÃ¨tres de la solution dans Visual Studio. Comment accÃ©der aux paramÃ¨tres de la solution ? On peut Ã©galement accÃ©der","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:2:0","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"DÃ©finir un nom dâ€™application pour chaque environnement ciblÃ© Maintenant que les configurations de ton projet sont prÃªtes, nous allons donner un nom dâ€™application spÃ©cifique pour chacun des environnements ciblÃ©s, afin dâ€™Ã©viter toute confusion entre lâ€™application de dÃ©veloppement et celle de production. Le nom de lâ€™application peut Ãªtre modifiÃ© via le fichier de configuration du projet. Par dÃ©faut, tu y verras normalement un titre et un identifiant dâ€™application dÃ©jÃ  dÃ©finis pour chaque nouveau projet .NET MAUI : Nom du fichier :MultiEnvMauiApp.csproj \u003cPropertyGroup\u003e ... \u003c!-- Display name --\u003e \u003cApplicationTitle\u003eMy App\u003c/ApplicationTitle\u003e \u003c!-- App Identifier --\u003e \u003cApplicationId\u003ecom.companyname.multienvmauiapp\u003c/ApplicationId\u003e ... \u003c/PropertyGroup\u003e Dans lâ€™exemple ci-dessus, â€My Appâ€ correspond au nom de base de lâ€™application, et notre but est de le personnaliser pour chacune des configurations du projet. Dans notre cas, nous allons inclure la dÃ©nomination de lâ€™environnement ciblÃ© dans le titre et dans lâ€™identifiant dâ€™application : Nom du fichier :MultiEnvMauiApp.csproj \u003cPropertyGroup Condition=\" '$(Configuration)' == 'DEV' \"\u003e ... \u003c!-- Display name (Overridden) --\u003e \u003cApplicationTitle\u003e(DEV) My App\u003c/ApplicationTitle\u003e \u003c!-- App Identifier (Overridden) --\u003e \u003cApplicationId\u003ecom.companyname.multienvmauiapp.dev\u003c/ApplicationId\u003e ... \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'TEST' \"\u003e ... \u003c!-- Display name (Overridden) --\u003e \u003cApplicationTitle\u003e(TEST) My App\u003c/ApplicationTitle\u003e \u003c!-- App Identifier (Overridden) --\u003e \u003cApplicationId\u003ecom.companyname.multienvmauiapp.test\u003c/ApplicationId\u003e ... \u003c/PropertyGroup\u003e DÃ©sormais, pour les configurations â€œDEVâ€ et â€œTESTâ€, lâ€™appellation de lâ€™environnement ciblÃ© apparaÃ®tra au dÃ©but du nom dâ€™application et Ã  la fin de lâ€™identifiant dâ€™application. Cette mesure nâ€™est pas nÃ©cessaire pour la configuration â€œPRODâ€, car le titre et lâ€™identifiant de base seront utilisÃ©s par dÃ©faut pour toutes les configurations. â€ Câ€™est parce que le paramÃ¨tre ApplicationId a une valeur diffÃ©rente pour chaque configuration quâ€™il est possible dâ€™installer plusieurs versions de lâ€™application. Tu peux maintenant diffÃ©rencier lâ€™application de dÃ©veloppement de celle de production sur ton tÃ©lÃ©phone. Cool ! Et si on allait un peu plus loin ? Dans la section suivante, tu apprendras Ã  personnaliser lâ€™icÃ´ne de lâ€™app. ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:3:0","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"DÃ©finir une icÃ´ne dâ€™application pour chaque environnement ciblÃ© En plus de nommer lâ€™application selon lâ€™environnement ciblÃ©, nous allons voir comment dÃ©finir une icÃ´ne pour chacune des configurations du projet. Pour cela, il te faut dâ€™abord concevoir une icÃ´ne pour chaque environnement. Une fois que câ€™est fait, ajoute-les au projet dans un dossier adaptÃ©. Par dÃ©faut, tout projet .NET MAUI comporte un dossier AppIcon. Tout comme pour le nom de lâ€™application, tu auras peut-Ãªtre remarquÃ© que lâ€™icÃ´ne se dÃ©finit aussi dans le fichier de configuration du projet, avec la propriÃ©tÃ© MauiIcon. Commence par supprimer ce paramÃ¨tre du fichier .csproj, puis ajoute le code suivant : Nom du fichier :MultiEnvMauiApp.csproj \u003cItemGroup\u003e \u003c!-- App Icon --\u003e \u003cMauiIcon Include=\"Resources\\AppIcon\\icon_dev.png\" Condition=\" '$(Configuration)' == 'DEV' \" /\u003e \u003cMauiIcon Include=\"Resources\\AppIcon\\icon_test.png\" Condition=\" '$(Configuration)' == 'TEST' \" /\u003e \u003cMauiIcon Include=\"Resources\\AppIcon\\icon.png\" Condition=\" '$(Configuration)' == 'PROD' \" /\u003e \u003c/ItemGroup\u003e Et hop ! Ã‡a yâ€™est, on a dÃ©fini une icÃ´ne diffÃ©rente en fonction de la configuration choisie ! Enfinâ€¦ presque ! Comme tu le sais, chaque application .NET MAUI sâ€™appuie sur des fichiers de configuration liÃ©s Ã  la plateforme cible. Il est Ã©galement nÃ©cessaire de dÃ©finir lâ€™icÃ´ne de lâ€™application dans ces fichiers : dans le fichier AndroidManifest.xml sur Android, et dans le fichier Info.plist sur iOS. â€ Ã€ lâ€™heure oÃ¹ jâ€™Ã©cris cet article, il nâ€™est pas possible de gÃ©nÃ©rer automatiquement lâ€™icÃ´ne sur iOS et Android sans modifier ces fichiers. Peut-Ãªtre une fonctionnalitÃ© pour .NET 8 ? Tout dâ€™abord, nous devons associer chacun de ces fichiers Ã  une configuration diffÃ©rente. Dans notre cas, nous aurons besoin de 3 fichiers .plist sur iOS et de 3 fichiers .xml sur Android : Android iOS DEV AndroidManifest.dev.xml Info.dev.plist TEST AndroidManifest.test.xml Info.test.plist PROD AndroidManifest.xml Info.plist CommenÃ§ons par iOS, rends-toi dans le dossier Platforms/iOS et crÃ©e deux copies du fichier Info.plist dâ€™origine. Puis, renomme-les en Info.dev.plist et Info.test.plist. Pour chaque fichier .plist, nous allons modifier la valeur du paramÃ¨tre XSAppIconAssets de sorte Ã  dÃ©finir une icÃ´ne par configuration. La documentation indique que la valeur suit le format Assets.xcassets/{name}.appiconset et quâ€™il nous faut remplacer {name} par le nom de lâ€™icÃ´ne souhaitÃ©e (sans mentionner son chemin dâ€™accÃ¨s, ni son extension). Dans notre cas, voici ce que cela donne pour le fichier Info.dev.plist : Nom du fichier :Info.dev.plist \u003ckey\u003eXSAppIconAssets\u003c/key\u003e \u003cstring\u003eAssets.xcassets/icon_dev.appiconset\u003c/string\u003e Enfin, lorsque tu as modifiÃ© lâ€™icÃ´ne dans tous les fichiers .plist, retourne dans le fichier de configuration du projet. En effet, nous devons lui indiquer quel fichier .plist considÃ©rer selon la configuration choisie : Nom du fichier :MultiEnvMauiApp.csproj \u003cItemGroup Condition=\" '$(TargetFramework)' == 'net7.0-ios' \"\u003e \u003cPartialAppManifest Include=\"Platforms\\iOS\\Info.dev.plist\" Condition=\" '$(Configuration)' == 'DEV' \" /\u003e \u003cPartialAppManifest Include=\"Platforms\\iOS\\Info.test.plist\" Condition=\" '$(Configuration)' == 'TEST' \" /\u003e \u003c/ItemGroup\u003e Par dÃ©faut, Visual Studio choisira le fichier Info.plist. On doit donc uniquement prÃ©ciser quel fichier considÃ©rer pour les configurations â€œDEVâ€ et â€œTESTâ€. â€ Aller plus loin avec la propriÃ©tÃ© PartialAppManifest. Enfin, mÃªme chose pour Android. Rends-toi dans le dossier Platforms/Android et crÃ©e deux copies du fichier AndroidManifest.xml. Puis, renomme-les en AndroidManifest.dev.xml et AndroidManifest.test.xml. Cependant, ici nous devons renommer le AndroidManifest.xml dâ€™origine en AndroidManifest.prod.xml. Sans quoi, tu aurais des soucis Ã  la compilation de lâ€™app. Pour chaque fichier .xml, nous allons modifier la valeur des paramÃ¨tres android:icon et android:roundIcon de sorte Ã  dÃ©finir une icÃ´ne par configuration. La documentation indique que les valeurs suivent respectivement le forma","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:4:0","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"DÃ©monstration Il est grand temps de vÃ©rifier que toute cette mise en place fonctionne. Tu peux maintenant dÃ©ployer lâ€™app pour chaque configuration, et pour chaque plateforme ! Pour les configurations nâ€™autorisant pas le dÃ©boggage, tu dois dÃ©marrer lâ€™application sans dÃ©boggage pour quâ€™elle se dÃ©ploie sur le simulateur. On doit passer par cette option pour les configurations â€œTESTâ€ et â€œPRODâ€. Il y a bien 3 applications installÃ©es sur mon simulateur iOS avec chacune un nom et une icÃ´ne diffÃ©rents. Il y a bien 3 applications installÃ©es sur mon Ã©mulateur Android avec chacune un nom et une icÃ´ne diffÃ©rents. Bravo ! ğŸ‘ Tu vas pouvoir maintenant dÃ©velopper de nouvelles fonctionnalitÃ©s sans risquer les donnÃ©es de tes utilisateurs ! Et puis, câ€™est quand mÃªme pratique de pouvoir comparer le comportement de lâ€™application entre lâ€™environnement de dÃ©veloppement et de production. â€ Si tu rencontres des problÃ¨mes, il se peut que cela soit liÃ© aux donnÃ©es en mÃ©moire sur le tÃ©lÃ©phone ou dans Visual Studio. Aussi, pense Ã  nettoyer la solution et Ã  supprimer lâ€™application de ton tÃ©lÃ©phone avant tout dÃ©ploiement ! Mais dâ€™ailleurs, et sâ€™il Ã©tait possible dâ€™installer une application pour chaque nouveau dÃ©veloppement ? Tu pourrais alors tester sÃ©parÃ©ment chaque nouvelle fonctionnalitÃ© (ou correctif) sans avoir besoin de dÃ©sinstaller les anciennes versions de ton app ! Ã‡a sera lâ€™objet dâ€™un prochain article ğŸ¤“ ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:5:0","tags":["Visual Studio","Setup"],"title":"Cibler diffÃ©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Depuis la sortie officielle de .NET MAUI, il nâ€™est pas possible de crÃ©er de nouveau projet sans que Visual Studio nâ€™y ajoute un Shell par dÃ©faut. Heureusement, il existe une faÃ§on trÃ¨s simple de sâ€™en dÃ©barrasser !","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/","tags":["New Project","Visual Studio","Shell","Setup"],"title":"CrÃ©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Depuis la sortie officielle de .NET MAUI, il nâ€™est pas possible de crÃ©er de nouveau projet sans que Visual Studio nâ€™y ajoute un Shell par dÃ©faut. Heureusement, il existe une faÃ§on trÃ¨s simple de sâ€™en dÃ©barrasser ! ","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/:0:0","tags":["New Project","Visual Studio","Shell","Setup"],"title":"CrÃ©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Avec ou sans Shell ? Ã€ toi de voir ! Quand il sâ€™agit de crÃ©er une nouvelle application en .NET MAUI, Visual Studio ne propose pas beaucoup dâ€™options de configuration : Il y a bien sÃ»r le choix de .NET MAUI Blazor, mais câ€™est un tout autre framework. Seulement, chaque nouvelle application .NET MAUI crÃ©Ã©e avec Visual Studio embarque un Shell par dÃ©faut. Et bien que le Shell peut aider Ã  rÃ©duire la complexitÃ© du dÃ©veloppement dâ€™une application, câ€™est Ã©galement un outil que tout dÃ©butant doit apprendre Ã  maÃ®triser en plus du reste. Voici dâ€™ailleurs un petit tableau comparatif des avantages et inconvÃ©nients du Shell : Les avantages Les inconvÃ©nients Apporte une certaine structure standard Ã  lâ€™application avec un menu latÃ©ral ou des onglets, ainsi quâ€™un systÃ¨me de navigation avec des URLs. Un peu complexe au premier abord pour un dÃ©butant, peut ralentir lâ€™ouverture de lâ€™app, et nâ€™est pas nÃ©cessaire dans les cas les plus simples. Finalement, recourir au Shell dans un projet .NET MAUI reste un choix personnel et ne devrait donc pas Ãªtre imposÃ© par Visual Studio. Mais alors, comment obtenir une application sans Shell, comme dans le cours Ma PremiÃ¨re App ? Tu vas voir, câ€™est trÃ¨s simple. ","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/:1:0","tags":["New Project","Visual Studio","Shell","Setup"],"title":"CrÃ©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Se passer du Shell Dans un premier temps, il te faut un projet .NET MAUI. Tu peux en crÃ©er un nouveau avec Visual Studio, ou bien rÃ©utiliser un projet existant. Une fois ton projet ouvert dans Visual Studio, supprime la classe AppShell en effaÃ§ant les deux fichiers AppShell.xaml et AppShell.xaml.cs. SÃ©lectionne les deux fichiers Ã  la fois, puis fais un clic droit et supprime-les. Visual Studio te demandera probablement une confirmation. VÃ©rifie que les fichiers sÃ©lectionnÃ©s sont les bons et confirme la suppression : On nâ€™est jamais Ã  lâ€™abri dâ€™une fausse manip ! VoilÃ , câ€™est fait ! Il ne reste alors plus quâ€™Ã  reconfigurer la page de dÃ©marrage de lâ€™application. Pour cela, ouvre le fichier App.xaml.cs et repÃ¨re la ligne de code suivante dans le constructeur de la classe : Nom du fichier :App.xaml.cs MainPage = new AppShell(); Maintenant que la classe AppShell ne fait plus rÃ©fÃ©rence Ã  rien, elle doit donc Ãªtre remplacÃ©e. Il te suffit de la remplacer par la classe associÃ©e Ã  la page qui apparaÃ®t en premier lors de lâ€™ouverture de lâ€™app ! Par exemple, pour tous les nouveaux projets, cela donnera : Nom du fichier :App.xaml.cs MainPage = new MainPage(); Et maintenant, Ã  lâ€™ouverture de lâ€™application, câ€™est la page MainPage qui sera chargÃ©e en premier. VoilÃ , tu nâ€™es plus obligÃ©Â·e de dÃ©velopper ton application autour dâ€™un Shell ! Et maintenant, que dirais-tu dâ€™apprendre Ã  naviguer de pages en pages sans le Shell ? ","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/:2:0","tags":["New Project","Visual Studio","Shell","Setup"],"title":"CrÃ©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Allez câ€™est bientÃ´t la fin du premier gros morceau de notre page principale. On passe dÃ©sormais au contrÃ´le du volume !","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":" â€ Afin dâ€™assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  repartir depuis ce chapitre oÃ¹ lâ€™on a dÃ©marrÃ© la mise en place des contrÃ´les du lecteur musical. Lors du dernier chapitre, on sâ€™Ã©tait attelÃ©s Ã  la mise en place des contrÃ´les de lecture du mÃ©dia. On y avait notamment dÃ©couvert un nouveau type de bouton: le composant ImageButton. Aujourdâ€™hui, on va encore dÃ©velopper notre interface utilisateur avec lâ€™intÃ©gration des contrÃ´les du volume. Câ€™est la derniÃ¨re ligne droite avant de commencer Ã  implÃ©menter le cÅ“ur de notre lecteur musical, alors accroche-toi ! ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:0:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Tout lâ€™art de reproduire Allez, reprenons donc la maquette, voici ce que lâ€™on devra reproduire dans lâ€™app : Cette fois-ci, il nâ€™y a que deux contrÃ´les, Ã§a devrait Ãªtre rapide ! Comme tu peux le constater, ce nâ€™est rien dâ€™autre quâ€™un bouton pour couper le son et une barre de contrÃ´le du volume sonore. Ã‡a ne devrait pas Ãªtre trÃ¨s long, commence par tÃ©lÃ©charger les diffÃ©rentes images utilisÃ©es pour afficher lâ€™Ã©tat du volume. Volume_Tracker_-_Images.zip ./files/Volume_Tracker_-_Images.zip En dÃ©compressant ce fichier, tu verras 4 nouvelles images: Ici, on a donc une image pour chaque niveau de volume : quand il est trÃ¨s fort, moyen ou trÃ¨s bas. Dâ€™ailleurs, il y en a mÃªme une pour quand le son sera coupÃ©. Maintenant que tu as les images, il ne te reste alors plus quâ€™Ã  les inclure dans le dossier Resources/Images, exactement comme la derniÃ¨re fois ! â€ Si tu as des doutes, tu peux te rÃ©fÃ©rer au chapitre prÃ©cÃ©dent . ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:1:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Ã€ vos marques, prÃªt ? Codez ! Câ€™est bon, tout est prÃªt ? Allez on passe au code ! Pour cela, on aura besoin dâ€™un ImageButton pour couper le son et dâ€™un Slider pour contrÃ´ler le volume sonore de maniÃ¨re prÃ©cise. â€ ğŸ’â€ â€ Ah ! Mais je les connais ceux-lÃ  ! Eh oui ! Techniquement, câ€™est du dÃ©jÃ -vu, alors essaye de reproduire ces contrÃ´les par toi-mÃªme avant de regarder le code qui suit : Nom du fichier :MusicPlayerView.cs ImageButton MuteButton = new ImageButton { HeightRequest = 25, WidthRequest = 25, Source = \"volume_medium.png\" }; Slider VolumeTracker = new Slider { Minimum = 0, MinimumTrackColor = Colors.Black, Maximum = 100, MaximumTrackColor = Colors.Gray, Value = 60 }; VoilÃ , on a donc dÃ©fini un ImageButton avec une image par dÃ©faut, et un Slider pour contrÃ´ler le volume sonore de 0% Ã  100%. Et tu lâ€™auras sÃ»rement notÃ©, le Slider est composÃ© dâ€™une barre noire qui reprÃ©sente le volume actuel, et dâ€™une barre grise pour le volume supÃ©rieur disponible. Il ne te reste alors plus quâ€™Ã  rajouter les contrÃ´les dans le BottomLayout : Nom du fichier :MusicPlayerView.cs MuteButton.Row(2).Column(1), VolumeTracker.Row(2).Column(2).ColumnSpan(3), Alors, tu avais bien pensÃ© Ã  appliquer un ColumnSpan ? ğŸ˜›Â On en a en effet besoin pour afficher la barre de son Ã  cheval sur trois colonnes de notre Grid. Allez, il est temps de relancer lâ€™appli ! Voyons ce que Ã§a donne : Vu comme Ã§a, on dirait presque que lâ€™application est terminÃ©eâ€¦ ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:2:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Changer dâ€™image quand le son est coupÃ© Ã‡a devient plus facile avec tout cet entraÃ®nement, tu commences Ã  prendre le coup de main ? ğŸ™‚ Bon, cette fois-ci, il nâ€™y avait que deux composants Ã  dÃ©finir, alors on va aller un petit plus loin. Tu te rappelles des diffÃ©rentes images pour notre volume ? Il est temps de leur trouver une utilitÃ© ! Lâ€™idÃ©e, câ€™est que notre MuteButton change dâ€™apparence en fonction du niveau de volume demandÃ©. On aura donc une rÃ©fÃ©rence directe au VolumeTracker pour trouver la bonne image Ã  associer au MuteButton. Pour cela, on utilisera un DataTrigger qui permet de modifier la propriÃ©tÃ© dâ€™un objet lorsquâ€™une certaine valeur est dÃ©tectÃ©e. Prenons le cas le plus simple, celui oÃ¹ le volume sonore dÃ©tectÃ© est de 0 : Nom du fichier :MusicPlayerView.cs DataTrigger VolumeOffTrigger =\u003e new DataTrigger(typeof(ImageButton)) { Binding = new Binding(nameof(Slider.Value), source: VolumeTracker), Value = 0d, Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_off.png\" } } }; Dans un premier temps, on prÃ©cise sur quel type dâ€™objet appliquer des modifications. Dans notre cas, ce sera un ImageButton, puisque câ€™est lâ€™image du MuteButton que lâ€™on veut changer : Nom du fichier :MusicPlayerView.cs DataTrigger VolumeOffTrigger =\u003e new DataTrigger(typeof(ImageButton)) Puis, Ã  lâ€™aide dâ€™un Setter, on demande au VolumeOffTrigger de changer la source dâ€™image du MuteButton pour lâ€™icÃ´ne correspondant au volume Ã©teint : Nom du fichier :MusicPlayerView.cs new Setter { Property = ImageButton.SourceProperty, Value = \"volume_off.png\" } Or, la modification ne doit sâ€™appliquer que dans le cas oÃ¹ la valeur du VolumeTracker atteint 0 ! Ceci est rendu possible par la technique du Binding. On crÃ©e alors un lien vers ce composant pour suivre lâ€™Ã©volution de la propriÃ©tÃ© Value : Nom du fichier :MusicPlayerView.cs Binding = new Binding(nameof(Slider.Value), source: VolumeTracker) Enfin, la valeur cible Ã  atteindre est dÃ©finie dans le VolumeOffTrigger de cette faÃ§on : Nom du fichier :MusicPlayerView.cs Value = 0d En rÃ©sumÃ©, on a donc un dÃ©clencheur qui modifiera lâ€™icÃ´ne au moment oÃ¹ lâ€™utilisateur abaissera la valeur du Slider Ã  zÃ©ro. â€ ğŸ’â€ â€ Ok ! Mais pourquoi mettre un â€œdâ€ aprÃ¨s le â€œ0â€ ? HÃ©hÃ©, bien vu ! En effet, ce nâ€™Ã©tait pas une erreur typographique ğŸ˜„ En fait, la documentation du Slider prÃ©cise que la propriÃ©tÃ© Value est de type double. Cela donne Ã  lâ€™utilisateur un peu plus de contrÃ´le quand il manipule un Slider (Ã  la virgule prÃ¨s !). Or, si tu supprimes le â€œdâ€ et que tu passes ta souris au-dessus du â€œ0â€, tu constateras que ce nâ€™est plus considÃ©rÃ© comme un double, mais un int ! Visual Studio est clair sur ce point, â€œ0â€ est bien un entier ! Et comme la propriÃ©tÃ© Value de notre dÃ©clencheur est de type object, elle accepte potentiellement nâ€™importe quel type de valeur. On doit donc explicitement lui indiquer comment considÃ©rer ce â€œ0â€ : comme un double ! On doit rajouter le â€œdâ€ juste aprÃ¨s : Ã€ prÃ©sent, â€œ0â€ est bien un double ! Visual Studio nâ€™y a vu que du feu. Il ne reste alors plus quâ€™Ã  rattacher ce dÃ©clencheur Ã  notre composant MuteButton. Dâ€™ailleurs, comme il sera sujet Ã  des configurations supplÃ©mentaires, on va isoler son initialisation dans une mÃ©thode InitMuteButton(). Cela permettra de garder notre code clair : Nom du fichier :MusicPlayerView.cs public MusicPlayerView() { ... InitMuteButton(); Content = new Grid { ... }; } void InitMuteButton() { MuteButton.Triggers.Add(VolumeOffTrigger); } Et voilÃ  ! Essaye maintenant de glisser la valeur du Slider tout Ã  gauche : Lâ€™icÃ´ne du son coupÃ© apparaÃ®t aussitÃ´t que le curseur est dÃ©placÃ© tout Ã  gauche. ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:3:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Un bouton dans tous ses Ã©tats ! Maintenant que tu sais comment fonctionnent les dÃ©clencheurs, on va en crÃ©er dâ€™autres pour gÃ©rer tous les diffÃ©rents Ã©tats du bouton. Fonctionnellement, voici ce que lâ€™on aimerait mettre en place : lâ€™icÃ´ne du volume bas apparaÃ®tra pour toutes les valeurs supÃ©rieures Ã  0 et jusquâ€™Ã  15, pour les valeurs supÃ©rieures Ã  15 et jusquâ€™Ã  50, on affichera lâ€™icÃ´ne du volume modÃ©rÃ©, et pour lâ€™icÃ´ne du volume Ã©levÃ©, ce sera pour toutes valeurs supÃ©rieures Ã  50 et jusquâ€™Ã  100. Pour tous ces cas-lÃ , le dÃ©clencheur ne dÃ©pend plus dâ€™une seule valeur bien prÃ©cise, mais plutÃ´t de toute une plage de valeurs. On va donc faire appel Ã  un nouveau dÃ©clencheur spÃ©cifique, le MultiTrigger. Câ€™est le mÃªme principe que pour le DataTrigger, Ã  la diffÃ©rence que le MultiTrigger dÃ©pendra du rÃ©sultat de plusieurs conditions. Je vais tâ€™expliquer juste aprÃ¨s. Pour le moment, dÃ©clarons nos trois nouveaux Ã©tats possibles : Nom du fichier :MusicPlayerView.cs MultiTrigger VolumeLowTrigger = new MultiTrigger(typeof(ImageButton)) { Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_low.png\" } } }; MultiTrigger VolumeMediumTrigger = new MultiTrigger(typeof(ImageButton)) { Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_medium.png\" } } }; MultiTrigger VolumeHighTrigger = new MultiTrigger(typeof(ImageButton)) { Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_high.png\" } } }; Tout ce quâ€™on a fait, câ€™est dÃ©finir les changements dâ€™apparence Ã  lâ€™aide de Setters, pour un volume bas, moyen ou Ã©levÃ©. On peut dÃ©sormais dÃ©finir les conditions de dÃ©clenchement pour ces trois Ã©tats. Modifie la mÃ©thode InitMuteButton() comme indiquÃ© ci-aprÃ¨s : Nom du fichier :MusicPlayerView.cs void InitMuteButton() { BindingCondition CreateRangeCondition(OperatorType comparison, double value) =\u003e new BindingCondition { Binding = new Binding( nameof(Slider.Value), source: VolumeTracker, converter: new CompareConverter { ComparisonOperator = comparison, ComparingValue = value }), Value = true }; BindingCondition CreateMinRangeCondition(double value) =\u003e CreateRangeCondition(OperatorType.Greater, value); BindingCondition CreateMaxRangeCondition(double value) =\u003e CreateRangeCondition(OperatorType.SmallerOrEqual, value); VolumeLowTrigger.Conditions.Add(CreateMinRangeCondition(0d)); VolumeLowTrigger.Conditions.Add(CreateMaxRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMinRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMaxRangeCondition(50d)); VolumeHighTrigger.Conditions.Add(CreateMinRangeCondition(50d)); VolumeHighTrigger.Conditions.Add(CreateMaxRangeCondition(100d)); MuteButton.Triggers.Add(VolumeOffTrigger); MuteButton.Triggers.Add(VolumeLowTrigger); MuteButton.Triggers.Add(VolumeMediumTrigger); MuteButton.Triggers.Add(VolumeHighTrigger); } Oui je sais, Ã§a peut faire beaucoup dâ€™un coup, mais ce nâ€™est pas dur Ã  comprendre. Dâ€™ailleurs, tu peux voir quâ€™on rÃ©pÃ¨te souvent les mÃªmes opÃ©rations dans ce bout de code ! â€ ğŸ’â€ â€ Bah ouais, mÃªme pas peur ! Je fais quoi ensuite ? A ce stade, quelques erreurs auront probablement Ã©tÃ© mises en Ã©vidence par Visual Studio. Pour les rÃ©soudre, dÃ©clare les en-tÃªtes suivantes tout en haut du fichier : Nom du fichier :MusicPlayerView.cs using CommunityToolkit.Maui.Converters; using static CommunityToolkit.Maui.Converters.CompareConverter\u003cobject\u003e; â€ Cette Ã©tape est requise pour que le compilateur comprenne Ã  quoi correspondent les nouveaux objets utilisÃ©s : CompareConverter et Operator.Type. Il est maintenant temps de passer aux explications. DÃ©cortiquons un peu cette mÃ©thode InitMuteButton() en commenÃ§ant par cette portion de code : Nom du fichier :MusicPlayerView.cs VolumeLowTrigger.Conditions.Add(CreateMinRangeCondition(0d)); VolumeLowTrigger.Conditions.Add(CreateMaxRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMinRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMaxRangeCondition(50d)); Volu","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:4:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Des boutons, toujours plus de boutons ! Dans ce chapitre, on va intÃ©grer les contrÃ´les pour manipuler le mÃ©dia.","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/","tags":["Image","ImageButton","Visual Studio","Round Button","ColumnSpan"],"title":"Affichage du lecteur MP3 - ContrÃ´les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":" â€ Afin dâ€™assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  repartir depuis ce chapitre oÃ¹ lâ€™on a dÃ©marrÃ© la mise en place des contrÃ´les du lecteur musical. Lors du dernier chapitre, on sâ€™Ã©tait attelÃ©s Ã  la mise en place des premiers Ã©lÃ©ments visuels du lecteur musical. On y avait notamment dÃ©couvert deux composants: le Label et le Slider. Aujourdâ€™hui, on va continuer sur notre belle lancÃ©e et reproduire toute une sÃ©rie de boutons pour contrÃ´ler le mÃ©dia. ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:0:0","tags":["Image","ImageButton","Visual Studio","Round Button","ColumnSpan"],"title":"Affichage du lecteur MP3 - ContrÃ´les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"La guerre des boutons Pour Ã©couter de la musique, notre utilisateur a besoin de fonctions clÃ©s comme : jouer un morceau, passer Ã  la piste suivante, etc. Si tu te souviens de la maquette, on avait une rangÃ©e principale de 5 boutons : 5 boutons bien alignÃ©s sur la mÃªme rangÃ©e, mais ils nâ€™ont pas tous la mÃªme taille. La diffÃ©rence avec le bouton â€œENTERâ€ de la page dâ€™accueil, câ€™est quâ€™ici, nos 5 boutons reprÃ©sentent une image cliquable. Pour les reproduire dans lâ€™app, on fera donc appel au composant ImageButton. Mais tout dâ€™abord, il faudra ajouter ces fameuses images au projet. Commence donc par les tÃ©lÃ©charger sur ton ordinateur : Media_Control_-_Images.zip ./files/Media_Control_-_Images.zip Puis dÃ©compresse le fichier obtenu. Tu devrais avoir les 6 images suivantes : â€ ğŸ’â€ â€ 6 imagesâ€¦ mais on nâ€™avait pas dit 5 boutons ? En effet, il y aura bien 5 boutons sur cette rangÃ©e. Mais rien ne nous empÃªche de remplacer lâ€™image du bouton par une autre ! Si tu reprends la maquette, il y aura de gauche Ã  droite : un bouton pour rejouer la piste musicale (une seule fois) â‡’ câ€™est lâ€™image repeat_once.png un autre pour revenir Ã  la chanson prÃ©cÃ©dente â‡’ skip_previous.png on aura aussi un gros bouton central pour jouer ou mettre en pause la musique. Câ€™est lâ€™image de ce bouton qui changera automatiquement selon les cas suivants : soit la piste nâ€™est pas en cours de lecture â‡’ ce sera lâ€™image play.png ou bien elle est dÃ©jÃ  en train dâ€™Ãªtre jouÃ©e â‡’ on affichera alors pause.png puis on aura un bouton pour passer Ã  la chanson suivante â‡’ skip_next.png et un dernier pour tÃ©lÃ©charger le morceau â‡’ download.png Oui je sais, cette derniÃ¨re fonction â€œtÃ©lÃ©chargerâ€ nâ€™Ã©tait pas prÃ©vue au programme ! Ã‡Ã  devait initialement Ãªtre pour lire les titres en mode alÃ©atoire, mais jâ€™ai changÃ© dâ€™avis. ğŸ˜„ Comme quoi, câ€™est important de concevoir une maquette aussi fiable que possible ! ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:1:0","tags":["Image","ImageButton","Visual Studio","Round Button","ColumnSpan"],"title":"Affichage du lecteur MP3 - ContrÃ´les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"Ajouter les images au projet Maintenant que tu as tÃ©lÃ©chargÃ© toutes les images, tu dois les importer dans le projet pour quâ€™elles deviennent utilisables par lâ€™application. Pour cela, ouvre le projet dans Visual Studio et fais un clic droit sur le dossier Images : Rappelle-toi, câ€™est dans le dossier Resources quâ€™on stocke tous les mÃ©dias (icÃ´nes, images, pistes audio et vidÃ©o, â€¦) Dans le menu contextuel qui sâ€™affiche, dans la section Ajouter, clique sur lâ€™option pour ajouter des fichiers depuis un dossier : Puis, sÃ©lectionne le dossier oÃ¹ tu as dÃ©compressÃ© les 6 images et valide ton choix. Une fenÃªtre apparaÃ®t alors pour choisir les fichiers Ã  inclure dans le projet. Dans notre cas, on veut importer toutes les images du dossier. SÃ©lectionne donc tous les fichiers disponibles et clique sur OK : â€ Il y a de grandes chances pour que Visual Studio te demande quelle stratÃ©gie appliquer pour importer les fichiers dans le dossier Resources/Images. Je te conseille de choisir de les copier, ou de les dÃ©placer. VoilÃ  câ€™est terminÃ©, vÃ©rifie que tu as bien les 6 nouvelles images importÃ©es dans le dossier ! ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:2:0","tags":["Image","ImageButton","Visual Studio","Round Button","ColumnSpan"],"title":"Affichage du lecteur MP3 - ContrÃ´les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"DÃ©couverte des ImageButton Maintenant que les images sont prÃªtes Ã  lâ€™emploi, on passe au code ! DÃ©finissons dâ€™abord les deux boutons les plus petits (ceux aux extrÃ©mitÃ©s) : Nom du fichier :MusicPlayerView.cs ImageButton RepeatOnceButton =\u003e new ImageButton { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"repeat_once.png\", BackgroundColor = Colors.Black }; ImageButton DownloadButton =\u003e new ImageButton { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"download.png\", BackgroundColor = Colors.Black }; Comme tu peux le constater, on leur a dÃ©fini une petite taille de forme carrÃ©e (25 de hauteur sur 25 de largeur), Ã  fond noir et aux coins lÃ©gÃ¨rement arrondis (via la propriÃ©tÃ© CornerRadius). Puis, ils ont eu chacun leur propre image assignÃ©e grÃ¢ce Ã  la propriÃ©tÃ© Source, en lui passant le nom du fichier correspondant. â€ Si tu ne prÃ©vois pas de cibler la plateforme Windows, alors il nâ€™est pas nÃ©cessaire de prÃ©ciser lâ€™extension â€.pngâ€ dans le nom du fichier. Reste alors Ã  dÃ©finir les 3 boutons pour contrÃ´ler la lecture du morceau, en ayant toujours recours Ã  lâ€™ImageButton : Nom du fichier :MusicPlayerView.cs ImageButton SkipPreviousButton =\u003e new ImageButton { HeightRequest = 75, WidthRequest = 75, Source = \"skip_previous.png\" }; ImageButton PlayButton =\u003e new ImageButton { CornerRadius = 50, HeightRequest = 100, WidthRequest = 100, Source = \"play.png\", BackgroundColor = Colors.Black }; ImageButton SkipNextButton =\u003e new ImageButton { HeightRequest = 75, WidthRequest = 75, Source = \"skip_next.png\" }; Finalement, ce nâ€™est pas tellement diffÃ©rent ! Cependant, tu noteras que ces contrÃ´les sont plus grands, et surtout, les boutons SkipPrevious et SkipNext nâ€™ont pas de couleur de fond. Au contraire, le bouton Jouer, lui, est dotÃ© dâ€™un arriÃ¨re-plan noir et a les coins trÃ¨s arrondisâ€¦ tellement arrondis que la forme nâ€™est plus carrÃ©e, mais ronde ! â€ ğŸ’â€ â€ Ah bon, une forme ronde ? Mais comment as-tu fait ? La technique est trÃ¨s simple : les valeurs de HeightRequest et WidthRequest doivent Ãªtre identiques, tandis que celle du CornerRadius doit leur Ãªtre deux fois infÃ©rieure. Ainsi, si tu veux un bouton de forme ronde avec une hauteur de 200, son arrondissement devra avoir une valeur de 100. ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:3:0","tags":["Image","ImageButton","Visual Studio","Round Button","ColumnSpan"],"title":"Affichage du lecteur MP3 - ContrÃ´les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"PrÃ©paration pour la dÃ©mo Allez, il est dÃ©sormais temps pour toi de rÃ©partir ces nouveaux contrÃ´les sur la deuxiÃ¨me ligne du BottomLayout ! Ã‰tant donnÃ© quâ€™on a 5 boutons pour 7 colonnes, tu auras peut-Ãªtre optÃ© pour la disposition suivante : Nom du fichier :MusicPlayerView.cs RepeatOnceButton.Row(1).Column(1), SkipPreviousButton.Row(1).Column(2), PlayButton.Row(1).Column(3), SkipNextButton.Row(1).Column(4), DownloadButton.Row(1).Column(5) â€ ğŸ’â€ â€ Ben oui câ€™est ce que jâ€™ai faitâ€¦ et alors fallait pas ? ğŸ™ˆ Si, bien sÃ»r ! Tu as forcÃ©ment dÃ» relancer ton app pour vÃ©rifier, et le rendu nâ€™est pas si mal. Pour ma part, jâ€™ai prÃ©fÃ©rÃ© recrÃ©er un Grid spÃ©cialement pour englober les boutons Play, SkipPrevious et SkipNext, comme ceci : Nom du fichier :MusicPlayerView.cs Grid MediaControlLayout =\u003e new Grid { ColumnDefinitions = Columns.Define( Stars(30), Stars(40), Stars(30)), ColumnSpacing = 0, Children = { SkipPreviousButton.Column(0), PlayButton.Column(1), SkipNextButton.Column(2) } }; Il sâ€™agit seulement dâ€™une grille divisÃ©e en trois colonnes, avec chacune une taille spÃ©cifique. Ainsi, le bouton Play prendra un peu plus dâ€™espace que les deux autres. Mais bon, tout Ã§a est devenu facile pour toi, tu commences Ã  maÃ®triser maintenant ! ğŸ˜ Allez, il ne reste plus quâ€™Ã  positionner le MediaControlLayout de cette faÃ§on : RepeatOnceButton.Row(1).Column(1), MediaControlLayout.Row(1).Column(2).ColumnSpan(3), DownloadButton.Row(1).Column(5) Et hop, Ã§a y est, Ã§a commence vraiment Ã  prendre forme ! ğŸ¤© Tu tâ€™en es vraiment bien sorti, continue comme Ã§a ! Dâ€™ailleurs, il nous reste encore la gestion du volume de la musique Ã  reproduire dans lâ€™app, et câ€™est justement lâ€™objet du prochain chapitre ! Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:4:0","tags":["Image","ImageButton","Visual Studio","Round Button","ColumnSpan"],"title":"Affichage du lecteur MP3 - ContrÃ´les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"Maintenant que les fondations de la page principale sont prÃªtes, on va pouvoir commencer Ã  disposer tous les Ã©lÃ©ments de contrÃ´le. CommenÃ§ons avec le minutage !","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - DurÃ©e d'Ã©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":" â€ Pour assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours. Pour cela, rÃ©fÃ¨re-toi au guide dâ€™installation du projet et repars de lâ€™exemple situÃ© dans le dossier â€œ3 - Page Scaffoldingâ€. Dans lâ€™article prÃ©cÃ©dent, on a mis en place un quadrillage pour y disposer tous les contrÃ´les de notre lecteur musical. On va donc pouvoir ajouter des Ã©lÃ©ments concrets pour lâ€™utilisateur ! ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:0:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - DurÃ©e d'Ã©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Afficher le minutage CommenÃ§ons dÃ©jÃ  avec la partie dÃ©diÃ©e au minutage du titre musical. Dâ€™aprÃ¨s la maquette, on aura un texte Ã  gauche pour le temps dâ€™Ã©coute en cours, et Ã  droite, pour la durÃ©e totale de la piste : Lâ€™application indique que le morceau est jouÃ© depuis 36 secondes et quâ€™il dure 2 minutes et 57 secondes. Pour reproduire cela dans lâ€™application, on utilisera le composant Label qui permet dâ€™afficher du texte Ã  lâ€™Ã©cran : Nom du fichier :MusicPlayerView.cs Label ElapsedTime =\u003e new Label { FontSize = 14, Text = \"0:36\", TextColor = Colors.White }.TextCenter(); Label TotalTime =\u003e new Label { FontSize = 14, Text = \"2:57\", TextColor = Colors.White }.TextCenter(); Ces deux nouveaux Ã©lÃ©ments sont dÃ©finis pour afficher un texte statique Ã©crit en blanc et avec une taille relativement petite. Cependant, la taille des caractÃ¨res sâ€™adaptera automatiquement au niveau dâ€™agrandissement du texte dÃ©fini par lâ€™utilisateur dans les rÃ©glages dâ€™accessibilitÃ© de son tÃ©lÃ©phone. â€ Aller plus loin avec lâ€™accessibilitÃ© pour les applications mobiles. ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:1:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - DurÃ©e d'Ã©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Ajuster la tÃªte de lecture Quant Ã  lâ€™Ã©lÃ©ment du milieu, il remplit deux fonctions Ã  la fois : afficher et contrÃ´ler la position de lecture dans le morceau. En effet, lâ€™utilisateur sâ€™en sert pour avancer ou reculer dans le morceau en faisant glisser son doigt horizontalement. De plus, ce composant possÃ¨de une partie en rose qui reprÃ©sente le temps Ã©coulÃ©, et une autre en noir pour le temps restant. Pour reproduire cette barre de navigation, on utilisera le composant Slider : Nom du fichier :MusicPlayerView.cs Slider TimeTracker =\u003e new Slider { Minimum = 0, MinimumTrackColor = Colors.LightSalmon, Maximum = 100, MaximumTrackColor = Colors.Black, Value = 20 }; Un Slider est un contrÃ´le dotÃ© dâ€™un curseur permettant Ã  lâ€™utilisateur de sÃ©lectionner une valeur prÃ©cise parmi toute une plage de valeurs possibles. Dans notre cas, câ€™est comme si lâ€™on avait une rÃ¨gle graduÃ©e de 0 Ã  100 avec un curseur positionnÃ© sur le 20. â€ ğŸ’â€ â€ Ah oui je vois, on se situe en fait Ã  20% du morceau ! On aura donc une barre rose de 0 jusquâ€™Ã  20, et une barre noire de 20 jusquâ€™Ã  100. Oui, câ€™est Ã§a ! Bon Ã©videmment ici, toutes les valeurs de configuration sont statiques, mais lâ€™idÃ©e finale est de permettre Ã  lâ€™utilisateur dâ€™avancer ou de reculer lâ€™Ã©coute de la piste Ã  la seconde prÃ¨s. VoilÃ , on en a terminÃ© avec la premiÃ¨re rangÃ©e dâ€™Ã©lÃ©ments du lecteur musical. Pour vÃ©rifier que lâ€™affichage est correct, jâ€™aimerais que tu effaces tous les Ã©lÃ©ments enfants du BottomLayout pour lui assigner tous les composants dÃ©finis dans ce chapitre. Pour cela, tu seras sÃ»rement tentÃ© dâ€™Ã©crire quelque chose comme : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { ... Children = { ElapsedTime.Row(0).Column(1), TimeTracker.Row(0).Column(2), TotalTime.Row(0).Column(5) } }; Ã€ premiÃ¨re vue, Ã§a semble pas mal ! Cependant, si tu dÃ©marres lâ€™application, tu constateras quâ€™il y a un lÃ©ger problÃ¨me dâ€™affichage : DisposÃ© comme Ã§a, le Slider nâ€™a pas bonne mine. Pas de panique ! On va voir tout de suite comment rÃ©ajuster cela. ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:2:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - DurÃ©e d'Ã©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Bien utiliser les Grid Si tu te rappelles, on a initialement divisÃ© le BottomLayout en 7 colonnes. Or, si notre code positionne bien notre Slider Ã  partir de la case nÂ°3 de la premiÃ¨re ligne, il ne lui dit pas clairement oÃ¹ sâ€™arrÃªter ! On pourrait alors simplement dire au Slider de sâ€™Ã©taler sur les colonnes suivantes, comme ceci : Le Slider est Ã  cheval sur les cases nÂ°3, nÂ°4 et nÂ°5. Pour cela, on utilise la mÃ©thode ColumnSpan() pour demander au Slider de sâ€™Ã©tendre jusquâ€™Ã  3 colonnes Ã  partir de la case nÂ°3 : Nom du fichier :MusicPlayerView.cs TimeTracker.Row(0).Column(2).ColumnSpan(3) Et voilÃ  on en a vraiment fini ! RelanÃ§ons lâ€™application pour voir ce que Ã§a donne : Bon, câ€™est vrai, câ€™est beau mais Ã§a ne fait pas grand chose ! Mais on va dâ€™abord finir la partie visuelle avant de basculer vers la partie plus fonctionnelle de lâ€™application. Dâ€™ailleurs, on a encore plein de boutons Ã  mettre en place ! Notre objectif pour le prochain chapitre : contrÃ´ler la lecture du mÃ©dia. Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:3:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - DurÃ©e d'Ã©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Avant de dÃ©velopper une nouvelle page, il vaut mieux rÃ©flÃ©chir Ã  la disposition des diffÃ©rents Ã©lÃ©ments. Et tu vas voir, câ€™est un vrai travail dâ€™architecte !","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":" â€ Pour assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours. Pour cela, rÃ©fÃ¨re-toi au guide dâ€™installation du projet et repars de lâ€™exemple situÃ© dans le dossier â€œ2 - Navigationâ€. Avec ce nouveau chapitre, on entame une sÃ©rie dâ€™articles axÃ©s autour du visuel de lâ€™app, et il y a de bonnes chances que cela te plaise ! En effet, dÃ©velopper une interface visuelle nÃ©cessite de nombreux tests du rendu Ã  lâ€™Ã©cran, et il nâ€™y a rien de mieux pour apprendre. Et câ€™est par la pratique rÃ©guliÃ¨re que tu vas naturellement comprendre et retenir tout un tas de choses ğŸ™‚ Allez, on est partis pour mettre en place les fondations de la page principale ! ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:0:0","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Le design Mais avant tout dÃ©veloppement graphique, il vaut mieux rÃ©flÃ©chir Ã  la disposition des diffÃ©rents Ã©lÃ©ments que lâ€™on souhaite afficher. Justement, .NET MAUI fournit pour cela plusieurs solutions simples pour structurer nos pages. Et tu vas voir, câ€™est un vrai travail dâ€™architecte ! â€ ğŸ’â€ â€ Mais au fait, Ã  quoi doit ressembler notre page ? Câ€™est une trÃ¨s bonne question ! En gÃ©nÃ©ral, quand imagine une nouvelle page pour notre application, il est conseillÃ© dâ€™en Ã©laborer le design au crayon sur une feuille. En effet, comme les Ã©crans de tÃ©lÃ©phone sont assez petits, il nâ€™est pas facile de disposer tous les Ã©lÃ©ments souhaitÃ©s. Puis, quand on est satisfait du rendu sur papier, on prÃ©pare alors une maquette sur ordinateur pour un rendu plus rÃ©aliste : Ã§a facilite grandement lâ€™intÃ©gration de la page dans lâ€™application. Dans le cadre de notre cours, la page principale devra ressembler Ã  la maquette suivante : ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:1:0","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Structuration de la page Sur cette maquette, on remarque que les Ã©lÃ©ments sont disposÃ©s de faÃ§on assez rÃ©guliÃ¨re. On pourrait mÃªme imaginer des lignes pour aligner les Ã©lÃ©ments les uns par rapport aux autres : Disposer les Ã©lÃ©ments suivant des lignes imaginaires est un exercice un peu spÃ©cial au dÃ©but, mais cela devient une habitude avec le temps. Ces lignes te feront peut-Ãªtre penser Ã  une grilleâ€¦ et si câ€™est le cas, bien vu ! Câ€™est tout le principe du composant Grid, qui comme son nom lâ€™indique, permet de disposer des Ã©lÃ©ments sur une grille. On va lâ€™utiliser plusieurs fois pour cette page. ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:2:0","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Initiation au Grid Pour respecter la maquette, la premiÃ¨re chose Ã  faire est de diviser la page en deux : La partie du haut qui nâ€™affiche rien dâ€™autre quâ€™un fond noir, Et celle du bas pour contrÃ´ler notre lecteur de musique. Tu remarqueras que la partie supÃ©rieure est lÃ©gÃ¨rement plus grande que la partie infÃ©rieure. On pourrait mÃªme dire que la partie noire sâ€™Ã©tale verticalement sur 60% de la page, ce qui laisse 40% dâ€™espace pour le reste. Ce sont des donnÃ©es trÃ¨s utiles ! Mettons-les en application pour dÃ©finir le contenu de notre page MusicPlayerView avec un Grid : Nom du fichier :MusicPlayerView.cs using CommunityToolkit.Maui.Markup; using static CommunityToolkit.Maui.Markup.GridRowsColumns; ... public MusicPlayerView() { ... Content = new Grid { RowDefinitions = Rows.Define( Stars(60), Stars(40)), RowSpacing = 0, Children = { TopLayout.Row(0), BottomLayout.Row(1), } }; } Avec le paramÃ¨tre RowDefinitions, on configure une grille de 2 lignes : la premiÃ¨re pourra sâ€™Ã©tendre jusquâ€™Ã  60% de la page verticalement contre 40% pour la deuxiÃ¨me, comme sur notre design ! A lâ€™initialisation du Grid, on dÃ©finit Ã©galement deux autres paramÃ¨tres : le RowSpacing dÃ©fini Ã  0 pour ne laisser aucun espace entre les lignes de notre grille, et Children qui contiendra tous les Ã©lÃ©ments de notre grille, Ã  rÃ©partir sur deux lignes. Et si tu te demandes dâ€™oÃ¹ sortent ces fameux TopLayout et BottomLayout, il sâ€™agit de deux conteneurs dâ€™Ã©lÃ©ments Ã  dÃ©finir en dehors du constructeur de la page. En effet, on utilise Ã  nouveau un Grid pour chacun de ces deux contrÃ´les pour nous aider dans le placement des Ã©lÃ©ments restants. Le premier Grid (le TopLayout) correspond Ã  la partie supÃ©rieure de notre page et a donc un fond noir. Quant Ã  lâ€™autre Grid (le BottomLayout), on lui dÃ©finit un fond gris foncÃ© pour reprÃ©senter la partie infÃ©rieure. Copie le code suivant et colle-le dans la rÃ©gion dÃ©diÃ©e aux contrÃ´les du fichier MusicPlayerView.cs: Nom du fichier :MusicPlayerView.cs #region Controls Grid TopLayout =\u003e new Grid { BackgroundColor = Colors.Black }; Grid BottomLayout =\u003e new Grid { BackgroundColor = Colors.DimGray }; #endregion ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:3:0","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Les fondations principales Concentrons-nous dans un premier temps sur le contenu du BottomLayout. En regardant dâ€™un peu plus prÃ¨s le design, on remarque de nouvelles lignes, mais Ã©galement des colonnes. Plus exactement : on remarque 3 lignes de haut en bas, Ã  taille identique, et il y a 7 colonnes de gauche Ã  droite (2 petites, 3 grandes et 2 petites Ã  nouveau). En quadrillant la zone infÃ©rieure de la page, on remarque que chaque Ã©lÃ©ment visuel a bien sa case attitrÃ©e. DÃ©finissons maintenant les lignes et colonnes qui composent notre BottomLayout de sorte Ã  respecter lâ€™alignement des Ã©lÃ©ments visuels, comme sur la maquette : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { BackgroundColor = Colors.DimGray, RowDefinitions = Rows.Define( Stars(1), Stars(1), Stars(1)), RowSpacing = 0, ColumnDefinitions = Columns.Define( Stars(10), Stars(10), Stars(20), Stars(20), Stars(20), Stars(10), Stars(10)), ColumnSpacing = 0 }; Comme tu vois, le code ci-dessus propose un dÃ©coupage en 3 lignes de mÃªme taille et 7 colonnes avec des tailles diffÃ©rentes. â€ ğŸ’â€ â€ Euhâ€¦ alors si jâ€™additionne les tailles de chaque colonne, jâ€™obtiens bien 100% ! Mais pour ce qui est des lignes, on a un problÃ¨me non ? TrÃ¨s bonne remarque ! En fait si je suis parti au dÃ©but avec un Ã©chelonnement des tailles sur 100%, câ€™est parce que câ€™est souvent plus facile Ã  comprendre. En rÃ©alitÃ©, quand tu Ã©crisâ€¦ Nom du fichier :MusicPlayerView.cs RowDefinitions = Rows.Define( Stars(60), Stars(40)) â€¦ lâ€™application comprend que la premiÃ¨re ligne aura un poids de 60 par rapport Ã  la deuxiÃ¨me ligne, qui elle nâ€™aura quâ€™un poids de 40. Câ€™est une faÃ§on dynamique dâ€™attribuer une hauteur Ã  nos lignes en fonction de la taille de lâ€™Ã©cran, puisquâ€™elle change dâ€™un modÃ¨le de tÃ©lÃ©phone Ã  un autre. Finalement, tu peux voir ce poids comme un coefficient multiplicateur. Par exemple, ce mÃªme bout de code peut Ãªtre rÃ©Ã©crit de cette faÃ§on: Nom du fichier :MusicPlayerView.cs RowDefinitions = Rows.Define( Stars(1.5), // 1.5 x 40 = 60 Stars(1)) // 1 x 40 = 40 A toi de choisir ce qui te semble plus cohÃ©rent ! ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:4:0","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"VÃ©rification du rendu Ã  lâ€™Ã©cran Maintenant que notre quadrillage de la partie infÃ©rieure est en place, vÃ©rifions si les paramÃ¨tres sont corrects. Avec une Grid configurÃ©e sur 3 lignes et 7 colonnes, Ã§a fait beaucoup de cases Ã  valider ! Mais jâ€™ai une astuce pour tester rapidement si le dÃ©coupage est bien celui attendu ou sâ€™il y a des ajustements Ã  faire. Pour cela, tu peux dessiner une forme gÃ©omÃ©trique dans chaque case du quadrillage, avec chacune sa propre couleur. Avec la BoxView, câ€™est trÃ¨s facile : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { [...] ColumnSpacing = 0, Children = { new BoxView { Color = Color.FromArgb(\"#ffffff\") }.Row(0).Column(0), new BoxView { Color = Color.FromArgb(\"#d0d0d0\") }.Row(0).Column(1), new BoxView { Color = Color.FromArgb(\"#a2a3a3\") }.Row(0).Column(2), new BoxView { Color = Color.FromArgb(\"#777879\") }.Row(0).Column(3), new BoxView { Color = Color.FromArgb(\"#4e5051\") }.Row(0).Column(4), new BoxView { Color = Color.FromArgb(\"#292b2c\") }.Row(0).Column(5), new BoxView { Color = Color.FromArgb(\"#000405\") }.Row(0).Column(6), new BoxView { Color = Color.FromArgb(\"#f3f337\") }.Row(1).Column(0), new BoxView { Color = Color.FromArgb(\"#a2eb5b\") }.Row(1).Column(1), new BoxView { Color = Color.FromArgb(\"#4edb80\") }.Row(1).Column(2), new BoxView { Color = Color.FromArgb(\"#00c89f\") }.Row(1).Column(3), new BoxView { Color = Color.FromArgb(\"#00b1b1\") }.Row(1).Column(4), new BoxView { Color = Color.FromArgb(\"#0098b2\") }.Row(1).Column(5), new BoxView { Color = Color.FromArgb(\"#177ea2\") }.Row(1).Column(6), new BoxView { Color = Color.FromArgb(\"#bf7aef\") }.Row(2).Column(0), new BoxView { Color = Color.FromArgb(\"#ea6cd4\") }.Row(2).Column(1), new BoxView { Color = Color.FromArgb(\"#ff63b3\") }.Row(2).Column(2), new BoxView { Color = Color.FromArgb(\"#ff6590\") }.Row(2).Column(3), new BoxView { Color = Color.FromArgb(\"#ff716e\") }.Row(2).Column(4), new BoxView { Color = Color.FromArgb(\"#ff844e\") }.Row(2).Column(5), new BoxView { Color = Color.FromArgb(\"#f89832\") }.Row(2).Column(6), } }; Et si tu lances lâ€™application, tu pourras alors confirmer avec certitude que notre emploi des Grid est effectivement correct : Ã‡a fait un peu penser aux vieilles tÃ©lÃ©visions en couleur. Bon, il nâ€™y a rien de fonctionnel pour lâ€™utilisateur, mais maintenant que nos fondations sont prÃªtes, Ã§a va grandement nous simplifier la vie ! On va enfin pouvoir sâ€™amuser Ã  disposer tous les Ã©lÃ©ments de contrÃ´le dÃ¨s le prochain chapitre, en commenÃ§ant par la gestion du minutage. Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:5:0","tags":["C# markup","Grid"],"title":"Agencer les Ã©lÃ©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"On attaque dÃ©sormais la crÃ©ation de la page principale de lâ€™application. Mais qui dit nouvelle page dit aussi : permettre Ã  lâ€™utilisateur de se rendre sur cette page ! Voyons donc comment implÃ©menter la navigation dâ€™une page Ã  une autre.","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":" â€ Pour assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours. Pour cela, rÃ©fÃ¨re-toi au guide dâ€™installation du projet et repars de lâ€™exemple situÃ© dans le dossier â€œ1 - MVVMâ€. HÃ©, mais te revoilÃ  ! On en a maintenant fini avec le MVVM et crois-moi, tu viens de faire un grand pas en avant ! Aujourdâ€™hui ce sera bien plus simple, on attaque la crÃ©ation de la page principale de lâ€™application. Mais qui dit nouvelle page dit aussi: permettre Ã  lâ€™utilisateur de sâ€™y rendre ! Voyons donc comment implÃ©menter la navigation dâ€™une page Ã  une autre. ","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/:0:0","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":"Naviguer vers une nouvelle page CommenÃ§ons dÃ©jÃ  par ajouter notre nouvelle page. Pour cela, fais un clic droit sur le dossier Views pour ajouter un nouveau fichier, puis choisis le template â€œ.NET MAUI ContentPage (C#)â€ comme ci-dessous. On va nommer ce fichier : MusicPlayerView.cs. Comme tu lâ€™auras remarquÃ©, le template utilisÃ© pour crÃ©er la page nous fournit un contenu par dÃ©faut. Il nâ€™y a donc plus quâ€™Ã  naviguer vers cette nouvelle page ! Pour cela, rends-toi dans le fichier HomeViewModel.cs et modifie la mÃ©thode Enter() de la faÃ§on suivante : Nom du fichier :HomeViewModel.cs using NightClub.Views; // Rappel: sans cette ligne, Ã§a ne compilerait pas ! ... [RelayCommand] async Task Enter() { await Application.Current.MainPage.Navigation.PushAsync( new MusicPlayerView()); } Tout ce quâ€™on fait ici, câ€™est accÃ©der au service de navigation fourni par lâ€™application pour afficher une nouvelle page de type MusicPlayerView. En fait, lorsquâ€™on fait appel Ã  la mÃ©thode PushAsync(), on ajoute la page MusicPlayerView tout en haut de la pile de pages dÃ©jÃ  existantes, exactement comme sur le schÃ©ma ci-dessous: Comme avec un paquet de cartes Ã  jouer, il nâ€™y a que celle du dessus qui est visible. â€ ğŸ’â€ â€ Ah! Et câ€™est tout, je peux tester alors ? On y est presque ! En effet pour que la navigation fonctionne, on a besoin que la premiÃ¨re page affichÃ©e au dÃ©marrage soit englobÃ©e dans une NavigationPage. Si tu retournes dans le fichier App.cs, il y a justement une mÃ©thode OnStart() qui est automatiquement exÃ©cutÃ©e Ã  chaque fois que lâ€™app est initialisÃ©e. Modifie donc cette mÃ©thode de sorte Ã  dÃ©finir HomeView comme la page racine de lâ€™application, dans une NavigationPage: Nom du fichier :App.cs protected override void OnStart() { base.OnStart(); Console.WriteLine(\"[NightClub] App - OnStart\"); MainPage = new NavigationPage(new HomeView()); } VoilÃ  câ€™est bon, relance lâ€™application et clique sur le bouton Enter ! ","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/:1:0","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":"Supprimer lâ€™en-tÃªte de navigation Comme tu lâ€™auras sÃ»rement compris, notre page dâ€™accueil est dÃ©sormais contenue dans une page spÃ©cialement configurÃ©e pour la navigation. Elle contient donc par dÃ©faut une en-tÃªte de navigation : Dâ€™un point de vue design, ce nâ€™est pas nÃ©cessairement ce que lâ€™on souhaite. Voyons donc rapidement comment supprimer cette en-tÃªte pour la page dâ€™accueil. Rends-toi dans le fichier HomeView.cs et invoque la mÃ©thode SetHasNavigationBar() dans le constructeur de la page, comme ceci: Nom du fichier :HomeView.cs public HomeView() { ... BindingContext = new HomeViewModel(); NavigationPage.SetHasNavigationBar(this, false); BackgroundColor = Colors.Black; ... } Et maintenant, si tu relances lâ€™app, câ€™est quand mÃªme plus joli ! Lâ€™application commence Ã  prendre forme tout doucement, et dâ€™autant plus avec le prochain chapitre ! On se revoit trÃ¨s bientÃ´t pour lâ€™Ã©laboration de notre page principale. Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/:2:0","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":"Dans ce chapitre, nous dÃ©couvrirons un patron de conception majeur pour le dÃ©veloppement dâ€™application mobile, le Model-View-ViewModel (MVVM) !","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application rÃ©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":" â€ Pour assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours. Pour cela, rÃ©fÃ¨re-toi au guide dâ€™installation du projet et repars de lâ€™exemple situÃ© dans le dossier â€œ0 - Get Startedâ€. Dans ce chapitre, nous dÃ©couvrirons un patron de conception majeur pour le dÃ©veloppement dâ€™application mobile, le Model-View-ViewModel ! (plus couramment appelÃ© â€œle MVVMâ€) ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:0:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application rÃ©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Le Model-View-ViewModel Le MVVM est un patron de conception qui propose au dÃ©veloppeur une sÃ©paration logique de son code en 3 couches : La View, qui correspond Ã  lâ€™interface utilisateur, câ€™est-Ã -dire tout ce que lâ€™on va afficher Ã  lâ€™Ã©cran (e.g. la page HomeView), Le Model, qui fait rÃ©fÃ©rence au type de donnÃ©es affichÃ©es dans cette View, Et enfin le ViewModel, qui fait le lien entre la View et le Model. Par exemple, pour rÃ©cupÃ©rer des donnÃ©es depuis le Cloud ou rÃ©pondre aux interactions de lâ€™utilisateur. â€ ğŸ’â€ â€ Je vois bien la sÃ©paration en effet, mais pourquoi est-ce recommandÃ© ? Lâ€™un des principaux avantages du MVVM est de pouvoir isoler la vue (i.e. lâ€™interface utilisateur) de la logique â€œmÃ©tierâ€. Dans le cadre de notre premiÃ¨re page, on obtient finalement deux fichiers : HomeView.cs qui dÃ©finit prÃ©cisÃ©ment comment notre page sâ€™affichera (i.e. une couleur de fond, une image en haut, un bouton en bas), Et HomeViewModel.cs qui regroupe toute la logique pour faire fonctionner notre page (ici, le comportement du bouton quand lâ€™utilisateur appuie dessus). En suivant ce principe, le dÃ©coupage de ton code est clair et tu limites le nombre de lignes de code par fichier. Tu ne voudrais pas dâ€™un fichier de plus de 10 000 lignes ! ğŸ˜„Â En plus, il nâ€™y a aucun risque dâ€™affecter la logique de ton app en changeant seulement la couleur dâ€™un bouton. â€ ğŸ’â€ â€ Câ€™est clair ! Mais il y a un truc que je ne comprends pas, on nâ€™a aucun Model pour la page HomeView ? Bonne remarque ! En effet, certaines pages sont tellement simples quâ€™elles ne nÃ©cessitent pas de Model. Dans ces cas-lÃ , seuls les View et ViewModel seront donc requis. ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:1:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application rÃ©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Le Data Binding On sait dÃ©sormais bien dÃ©couper notre code en plusieurs couches. Par exemple, dÃ©finir un bouton dans une View et dÃ©clarer son action dans un ViewModel. Mais est-ce que tu saurais dire comment elles vont fonctionner ensemble ? â€ ğŸ’â€ â€ Hmmâ€¦ peut-Ãªtre dire au bouton de cette View dâ€™agir selon ce qui a Ã©tÃ© dÃ©clarÃ© dans ce ViewModel ? En effet, câ€™est quasiment Ã§a ! Cela se dÃ©roule en deux temps : On associe dâ€™abord un ViewModel Ã  sa View (gÃ©nÃ©ralement via le BindingContext de la View), Puis on dÃ©finit le comportement de chaque Ã©lÃ©ment de la View dans le ViewModel, en recourant au principe du Data Binding. Le Data Binding est une technique permettant de lier deux objets de sorte que, lorsque lâ€™un des deux est modifiÃ©, lâ€™autre le sera Ã©galement. Ã‡a peut paraÃ®tre un peu flou comme Ã§a, mais tu comprendras mieux son rÃ´le dans la section dâ€™aprÃ¨s. Pour le moment, on continue ! ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:2:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application rÃ©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Appliquer le MVVM Maintenant que tu connais les bases du MVVM, je vais pouvoir tâ€™apprendre Ã  lâ€™appliquer concrÃ¨tement dans lâ€™application. CommenÃ§ons par crÃ©er un fichier qui servira de ViewModel pour notre HomeView. Pour cela, crÃ©e dâ€™abord un nouveau dossier ViewModels dans le projet, puis ajoutes-y un nouveau fichier. Ce sera une nouvelle classe vide appelÃ©e HomeViewModel.cs : Ensuite, remplace son contenu par le suivant: Nom du fichier :HomeViewModel.cs using System; namespace NightClub.ViewModels; public class HomeViewModel { public HomeViewModel() { } async Task Enter() { await Application.Current.MainPage.DisplayAlert( \"Well Done !\", \"You have successfully reached the end of this chapter.\", \"Next !\"); } } Bon, il nâ€™y a vraiment rien de spÃ©cial ici. Câ€™est juste une classe dâ€™objet C# avec une mÃ©thode Enter() qui affiche du texte Ã  lâ€™Ã©cran aprÃ¨s un clic de lâ€™utilisateur sur le bouton â€œENTERâ€. â€ ğŸ’â€ â€ Ah ben quand mÃªme, on vient de dÃ©finir lâ€™action du bouton de la page dâ€™accueil ! Eh oui tu as raison, mais en lâ€™Ã©tat, il reste inutilisable ! Souviens-toi, il nâ€™y a toujours aucun lien entre la HomeView et le HomeViewModel. Heureusement, il existe une librairie mise Ã  disposition par Microsoft qui va grandement nous simplifier la vie: le MVVM Toolkit. Cette librairie a dÃ©jÃ  Ã©tÃ© ajoutÃ©e au projet et tu peux le vÃ©rifier facilement en ouvrant la gestion des paquets NuGet. Fais donc un clic droit sur les dÃ©pendances du projet: Et voilÃ  la librairie en question ! Elle sâ€™appelle CommunityToolkit.Mvvm : â€ Aller plus loin avec les paquets NuGet Voyons dÃ©sormais comment prÃ©parer notre classe HomeViewModel pour Ãªtre un vÃ©ritable ViewModel : PremiÃ¨rement, fais-le hÃ©riter de la classe ObservableObject, puis, dÃ©finis-le comme une classe partielle avec le mot-clÃ© partial. Tu devrais avoir la configuration suivante: Nom du fichier :HomeViewModel.cs using System; using CommunityToolkit.Mvvm.ComponentModel; namespace NightClub.ViewModels; public partial class HomeViewModel : ObservableObject ... â€ En faisant hÃ©riter HomeViewModel de la classe ObservableObject, Visual Studio rajoute automatiquement les using nÃ©cessaires Ã  la compilation. En effet, une rÃ©fÃ©rence Ã  CommunityToolkit.Mvvm.ComponentModel est requise pour que ObservableObject devienne rÃ©ellement comprÃ©hensible par lâ€™application. Ces deux Ã©tapes sont nÃ©cessaires pour permettre au MVVM Toolkit de gÃ©nÃ©rer du code source Ã  la simple mention de mots-clÃ©s spÃ©cifiques. ConcrÃ¨tement, on Ã©crit un seul mot et hop, Ã§a gÃ©nÃ¨re tout seul des dizaines de lignes de code, câ€™est gÃ©nial, non ?! ğŸ¤˜ Par exemple ici, on va dÃ©finir notre mÃ©thode Enter() comme Ã©tant une commande en lui rajoutant un simple attribut [RelayCommand] , voilÃ  comment : Nom du fichier :HomeViewModel.cs [RelayCommand] async Task Enter() { await Application.Current.MainPage.DisplayAlert( \"Well Done !\", \"You have successfully reached the end of this chapter.\", \"Next !\"); } Avec seulement un mot, on a dÃ©sormais une commande Enter() qui supporte la technique du Data Binding ! Et ce uniquement grÃ¢ce Ã  la librairie MVVM Toolkit qui sâ€™occupe de gÃ©nÃ©rer tout le code source nÃ©cessaire. â€ Aller plus loin avec les gÃ©nÃ©rateurs de code source MVVM ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:3:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application rÃ©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"BientÃ´t la dÃ©mo ! On y est presque ! Il ne reste plus quâ€™Ã  actionner la commande Enter() au clic du bouton â€œENTERâ€. Tout dâ€™abord, retourne dans le fichier HomeView.cs pour lier la vue au HomeViewModel via le **BindingContext **: Nom du fichier :HomeView.cs public HomeView() { BindingContext = new HomeViewModel(); BackgroundColor = Colors.Black; Content = ... } Puis dÃ©finissons lâ€™action du bouton EnterButton avec BindCommand pour dÃ©clencher la commande Enter() spÃ©cifiÃ©e dans le HomeViewModel: Nom du fichier :HomeView.cs Button EnterButton =\u003e new Button { Text = \"ENTER\", TextColor = Colors.White, BackgroundColor = Colors.Magenta, CornerRadius = 10 } .Bold() .Paddings(50, 2, 50, 2) .CenterHorizontal() .BindCommand(\"EnterCommand\"); // Note: on doit ajouter \"Command\" aprÃ¨s \"Enter\" Et voilÃ  le travail ! â€ ğŸ’â€ â€ Ok donc si je comprends bien il faut faire Ã§a Ã  peu prÃ¨s sur toutes les pages de lâ€™app, câ€™est pas si compliquÃ© ! Eh bien oui en thÃ©orie ! Mais il manque tout de mÃªme plusieurs fonctionnalitÃ©s clÃ©s dâ€™une application : un systÃ¨me dâ€™authentification, une base de donnÃ©es, etcâ€¦ Tiens par exemple, une fois quâ€™on aura crÃ©Ã© la page principale de lâ€™application, il faudra bien pouvoir sâ€™y rendre depuis la page dâ€™accueil ! Câ€™est ce quâ€™on verra dans le prochain chapitre. Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:4:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application rÃ©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Allez, il est temps de faire tourner lâ€™application. On en profitera aussi pour jeter un Å“il au code source ! ğŸ™‚","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/","tags":["Visual Studio","C# markup"],"title":"PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":" â€ Pour assurer le bon dÃ©roulement de cet article, je tâ€™invite Ã  rÃ©cupÃ©rer le projet reprenant toutes les Ã©tapes appliquÃ©es jusquâ€™ici dans ce cours. Pour cela, rÃ©fÃ¨re-toi au guide dâ€™installation du projet et repars de lâ€™exemple situÃ© dans le dossier â€œ0 - Get Startedâ€. Allez, il est temps de faire tourner lâ€™application. On en profitera aussi pour jeter un Å“il au code source ! ğŸ™‚ Mais pour que notre application puisse fonctionner, il nous reste deux points Ã  aborder : lâ€™initialisation de lâ€™app et surtout, gÃ©rer son Ã©tat dâ€™exÃ©cution. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:0:0","tags":["Visual Studio","C# markup"],"title":"PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Initialisation de lâ€™app Pour chaque plateforme ciblÃ©e (iOS, Android, â€¦), chaque application .NET MAUI sera initialisÃ©e depuis un seul point dâ€™entrÃ©e via la mÃ©thode CreateMauiApp() situÃ©e dans le fichier MauiProgram.cs. Câ€™est ici que lâ€™on configurera tout ce dont a besoin lâ€™app pour fonctionner comme on le souhaite : les services Web, les dÃ©pendances externes, ou bien encore les polices de caractÃ¨res spÃ©cifiques. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:1:0","tags":["Visual Studio","C# markup"],"title":"PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Gestion de lâ€™Ã©tat de lâ€™app Mais on aura aussi besoin de quoi dÃ©finir lâ€™Ã©tat actuel de notre application (quelle page afficher, que faire si lâ€™application est arrÃªtÃ©e, â€¦). Et pour Ã§a on a justement une classe Application dÃ©clarÃ©e dans le fichier App.cs. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:2:0","tags":["Visual Studio","C# markup"],"title":"PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Lancement de lâ€™app Allez, il est temps de faire tourner lâ€™application ! Choisis donc la plateforme que tu souhaites cibler, puis clique sur le bouton encadrÃ© en rouge pour dÃ©marrer le projet: Dans un premier temps, tu verras ton projet Ãªtre compilÃ© avec la configuration choisie (câ€™est lâ€™Ã©tape du build): Sous Visual Studio for Mac, le statut actuel du projet peut facilement Ãªtre consultÃ© en bas Ã  gauche de la fenÃªtre. Puis tu verras ton application se dÃ©ployer automatiquement vers la plateforme choisie (ici, une simulation de lâ€™iPhone 13, iOS 15.5). Et voilÃ  le rÃ©sultat ! â€ ğŸ’â€ â€ HÃ©Ã©Ã©Ã© mais il ne se passe rien quand je clique sur le bouton ! Ce nâ€™est Ã©videmment que le dÃ©but de notre app, le plus gros reste Ã  faire ! ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:3:0","tags":["Visual Studio","C# markup"],"title":"PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"La page dâ€™accueil Ce que tu vois pour le moment, câ€™est la page dâ€™accueil dont le contenu est spÃ©cifiÃ© dans le fichier HomeView.cs. Il sâ€™agit lÃ  dâ€™une ContentPage (littÃ©ralement une page avec du contenu) qui est le type de page le plus courant. Et comme tu peux le voir, ce quâ€™elle dÃ©finit est trÃ¨s simple: Nom du fichier :HomeView.cs public HomeView() { BackgroundColor = Colors.Black; Content = new VerticalStackLayout { Children = { NightClubImage, EnterButton } }.CenterVertical(); } Câ€™est une page avec un arriÃ¨re-plan noir et dont le contenu est dÃ©fini par une image et un bouton qui sont empilÃ©s verticalement dans un VerticalStackLayout. Et si tu veux savoir comment sont dÃ©finis ces deux composants, il te suffit de regarder un peu plus bas dans le code de la page : Nom du fichier :HomeView.cs #region Controls Image NightClubImage =\u003e new Image { // .NET MAUI converts SVG files to PNG files. Source = \"night_club.png\" }; Button EnterButton =\u003e new Button { Text = \"ENTER\", TextColor = Colors.White, BackgroundColor = Colors.Magenta, CornerRadius = 10 } .Bold() .Paddings(50, 2, 50, 2) .CenterHorizontal(); #endregion Rien de trÃ¨s complexe Ã  ce stade: On dÃ©finit lâ€™image du composant NightClubImage via la propriÃ©tÃ© â€œSourceâ€, Et pour le bouton, on dÃ©finit quelques propriÃ©tÃ©s de base comme le texte, la couleur, â€¦ mais tu aurais peut-Ãªtre remarquÃ© quâ€™on applique des fonctions au composant EnterButton : Bold() pour mettre en gras le texte du bouton, Paddings() pour rajouter un peu dâ€™espace autour du texte, notamment Ã  gauche et Ã  droite du texte, Et enfin, CenterHorizontal() pour positionner le texte au centre du bouton. â€ Ces mÃ©thodes sont fournies par un type de programmation particuliÃ¨re appelÃ©e â€œDeclarative UIâ€ ou encore â€œFluent UIâ€. GrÃ¢ce Ã  cela, la page est entiÃ¨rement codÃ©e en C#, comme pour le reste de lâ€™app ! â€ ğŸ’â€ â€ Dâ€™accord ! Et il ne faudrait pas lui dÃ©clarer une action Ã  ce bouton ? Tout juste ! Et on va voir comment dÃ©clencher lâ€™exÃ©cution de code en cliquant sur ce bouton, mais pas nâ€™importe comment. En effet, nous allons appliquer ce merveilleux patron de conception quâ€™est le Model-View-ViewModel (MVVM). Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:4:0","tags":["Visual Studio","C# markup"],"title":"PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Aujourd'hui on attaque la crÃ©ation de notre premiÃ¨re application ! Juste le temps d'installer ton environnement de travail et on aura rapidement quelque chose de concret. Allez c'est parti !","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Tu vas bientÃ´t pouvoir crÃ©er ta premiÃ¨re application mobile ! Juste le temps dâ€™installer ton environnement de travail et on aura rapidement quelque chose de concret. Allez câ€™est parti ! ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:0:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Quels outils pour dÃ©velopper ? Voyons dÃ©jÃ  les outils qui te permettront de dÃ©velopper ton appli. â€ ğŸ’â€ â€ Mais au fait, il faut Ãªtre sous Windows, MacOS ou Linux ? En fait, il nâ€™y a pas de prÃ©-requis particulier pour dÃ©velopper une app avec .NET MAUI, Ã  moins que tu ne traÃ®nes un ordinateur de lâ€™avant-guerre et que tu ne mettes rien Ã  jourâ€¦ ğŸ¤” Sinon, câ€™est surtout une question de prÃ©fÃ©rence ! Personnellement, je dÃ©veloppe sous MacOS car câ€™est un systÃ¨me que jâ€™affectionne, et le simulateur dâ€™iPhone qui y est intÃ©grÃ© est trÃ¨s performant et me permet dâ€™avoir rapidement un rendu de ce que je programme. Mais tu peux tout aussi bien dÃ©velopper sous Windows ou Linux ! Plus concrÃ¨tement : sous Windows ou MacOS, câ€™est facile, Microsoft propose un environnement de dÃ©veloppement intÃ©grÃ© trÃ¨s performant: Visual Studio pour Windows, et Visual Studio for Mac pourâ€¦ eh bien pour MacOS ğŸ˜„ et si tu es sous Linux, il te faudra recourir Ã  un peu plus dâ€™ingÃ©niositÃ© (et câ€™est bien pour cela que tu es sous Linux, nâ€™est-ce pas ? ğŸ˜›). Dans ce cas-lÃ , je te conseille dâ€™utiliser lâ€™excellent Ã©diteur de code source Visual Studio Code. â€ Dans le cadre de ce blog, je me concentrerais uniquement sur le dÃ©veloppement dâ€™application mobile Ã  lâ€™aide de Visual Studio. En effet, son utilisation est bien plus intuitive et câ€™est justement cela qui plaÃ®t Ã  tout vrai nÃ©ophyte. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:1:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Installation de lâ€™environnement Passons maintenant Ã  lâ€™installation de lâ€™environnement de travail: Dans un premier temps, tÃ©lÃ©charge Visual Studio depuis le site officiel de Microsoft, en choisissant la version appropriÃ©e Ã  ton systÃ¨me (Windows ou MacOS), Puis vient le moment dâ€™installer Visual Studio et son environnement de dÃ©veloppement .NET MAUI. Pour amÃ©liorer la lecture de ce blog, je te propose de directement suivre les Ã©tapes dâ€™installation sur le site officiel: suivre les Ã©tapes dâ€™installation sous Windows suivre les Ã©tapes dâ€™installation sous MacOS (depuis lâ€™arrivÃ©e du SDK .NET 8, il y a peut-Ãªtre une Ã©tape supplÃ©mentaire dÃ©taillÃ©e ici) Enfin, tÃ©lÃ©charge mon cours depuis GitHub. Pour cela, rends-toi sur le dÃ©pÃ´t de code du blog, clique sur le bouton â€œCodeâ€ et tÃ©lÃ©charge le tout au format .ZIP â€ Avant dâ€™aller plus loin, si tu es sous MacOS, il te faudra tâ€™assurer dâ€™avoir tÃ©lÃ©chargÃ© la derniÃ¨re version dâ€™Xcode qui est requise pour le simulateur dâ€™iPhone. Son installation peut Ãªtre trÃ¨s longue, aussi, je te conseille de le faire en parallÃ¨le de ta lecture. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:2:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Description du projet Une fois le fichier tÃ©lÃ©chargÃ© dÃ©compressÃ©, rends-toi dans le dossier des exemples associÃ©s Ã  notre cours (Samples/NightClub). Les dossiers qui y sont entreposÃ©s correspondent chacun Ã  une partie diffÃ©rente du cours: Pour le moment, ouvre le premier dossier (0 - Get Started) et double-clique sur NightClub.sln pour ouvrir le projet NightClub dans Visual Studio. La structure du projet NightClub aprÃ¨s ouverture dans Visual Studio. â€ ğŸ’â€ â€ Ok ! Jâ€™ouvre le projet, Ã§a chargeâ€¦ Mais il y a dÃ©jÃ  plein de choses dans ce projet, on ne peut pas partir de zÃ©ro ? En fait, câ€™est dÃ©jÃ  le cas ! Le projet que tu as sous les yeux est tout neuf, mais il embarque plusieurs fichiers de base nÃ©cessaires au bon fonctionnement dâ€™une application .NET MAUI: Toutes les librairies nÃ©cessaires au bon fonctionnement du projet sont regroupÃ©es dans le dossier Dependencies, Dans Platforms, tu retrouveras tous les fichiers nÃ©cessaires Ã  lâ€™exÃ©cution de lâ€™application, et ce pour chaque plateforme cible, Quant au dossier Properties, on y retrouve gÃ©nÃ©ralement des fichiers de configuration (il y en a dâ€™ailleurs une crÃ©Ã©e par dÃ©faut pour Windows), Et puis, tu auras la possibilitÃ© pour chaque application de lui configurer une icÃ´ne et un Ã©cran de chargement ! Pour cela, on recourt gÃ©nÃ©ralement au dossier Resources pour stocker tous nos mÃ©dias (icÃ´nes, images, pistes audio et vidÃ©o, â€¦), Enfin, il faudra bien pouvoir afficher quelque chose Ã  lâ€™ouverture de lâ€™app ! Et pour Ã§a, on a le dossier Views qui contient pour le moment notre premiÃ¨re page, la fameuse page dâ€™accueilâ€¦ â€ Aller plus loin avec la structure de base des projets Visual Studio Et voilÃ  câ€™est tout, et si on lanÃ§ait cette app ? ğŸ™‚ Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:3:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Salut les DevÂ·eÂ·s ! ğŸ¤“ Moi c'est J-E et mon but avec ce blog est dâ€™aider tout dÃ©veloppeur dÃ©butant Ã  se lancer dans son projet dâ€™application mobile au travers de cours trÃ¨s simples. Pas de cours thÃ©oriques Ã  rallonge, ici tu vas vite tâ€™amuser et produire des apps sympas ! Et je tâ€™accompagnerai du dÃ©veloppement jusquâ€™Ã  la mise en ligne de ton application sur les stores.","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/1-introduction/","tags":["New Project"],"title":"Ma toute premiÃ¨re app en .NET MAUI","uri":"/posts/tutos/my-first-app/1-introduction/"},{"categories":null,"content":"Salut les DevÂ·eÂ·s ! ğŸ¤“ Moi câ€™est J-E, ou Jean-Emmanuel si tu prÃ©fÃ¨res, et je suis ravi de te savoir en train de me lire ! ğŸ˜Š En effet, jâ€™avais Ã  cÅ“ur de partager ma passion pour le dÃ©veloppement dâ€™applications mobiles cross-platforms, et tout particuliÃ¨rement avec .NET MAUI (Ã  prononcer â€œdote-net maouiâ€). Avec ce blog, je veux pouvoir aider tout dÃ©veloppeur dÃ©butant Ã  se lancer dans son projet dâ€™application mobile au travers de cours trÃ¨s simples. Pas de cours thÃ©oriques Ã  rallonge, ici tu vas vite tâ€™amuser et produire des apps sympas ! Et je tâ€™accompagnerai du dÃ©veloppement jusquâ€™Ã  la mise en ligne de ton application sur les stores. â€ ğŸ’â€ â€ Mais au fait, câ€™est quoi .NET MAUI ? Tu peux mâ€™en dire plus ? Il sâ€™agit du framework maintenu par Microsoft pour dÃ©velopper des applications mobiles, mais pas que ! En fait, MAUI signifie : â€œMulti-platform App User Interfaceâ€, ce qui veut littÃ©ralement dire â€œapplication dotÃ©e dâ€™une interface utilisateur et qui peut sâ€™exÃ©cuter sur plusieurs plateformesâ€. .NET MAUI a Ã©tÃ© officiellement publiÃ© courant 2022 et se base sur lâ€™excellent framework Xamarin.Forms qui couvre iOS et Android uniquement. Et si tu nâ€™en avais jamais entendu parler, pas de panique ! Moi-mÃªme jâ€™en ai appris lâ€™existence seulement fin 2019, et câ€™est grÃ¢ce Ã  lui que jâ€™ai dÃ©ployÃ© ma toute premiÃ¨re application sur les stores: MyVanity. â€ ğŸ’â€ â€ Et comment as-tu fait pour publier ta premiÃ¨re application ? Ã‡a tâ€™a pris longtemps ? Et câ€™est lÃ  toute la magie de .NET MAUI, tu nâ€™as quâ€™Ã  coder un seul programme pour quâ€™il fonctionne sur Android, iOS, macOS et Windows ! Et tout Ã§a bien-sÃ»r avec un seul langage de programmation. Et donc non, cela ne mâ€™a pas pris trÃ¨s longtemps, mais cela dÃ©pendra surtout: de tes connaissances en dÃ©veloppement, de la complexitÃ© de ton application, et du temps que tu peux lui accorder. Dans mon cas, cela mâ€™a pris exactement un an entre le moment oÃ¹ jâ€™ai imaginÃ© lâ€™application et le jour oÃ¹ je lâ€™ai publiÃ©e sur les stores. â€ ğŸ’â€ â€ Dâ€™accord, alors quâ€™est-ce que je dois savoir avant de dÃ©buter mon application ? Tout dâ€™abord bravo, tu as raison de te lancer ! Alors pour dÃ©marrer ton application, il te faudra : Trouver une idÃ©e, Concevoir la maquette, Comprendre le langage C#. Pour le premier point, câ€™est facile, tu lâ€™as normalement dÃ©jÃ  fait pour arriver jusquâ€™ici. ğŸ˜› Le deuxiÃ¨me, câ€™est simplement pour avoir une idÃ©e prÃ©cise de ce Ã  quoi ton application ressemblera, et pour Ã§a, tu peux utiliser le trÃ¨s bon Adobe XD qui est gratuit ! Enfin pour finir, il te faudra connaÃ®tre le langage C# pour programmer ton application, et pour cela je te propose le parcours dâ€™apprentissage Ã©laborÃ© par Microsoft. Cela dit, si tu as dÃ©jÃ  codÃ© dans ta vie, alors tu peux te lancer mÃªme sans connaÃ®tre le C# ! Tu apprendras trÃ¨s vite en voulant dÃ©velopper ton application. Pour ce premier cours, je te propose de dÃ©velopper une application pour lire des titres musicaux dans une ambiance â€œboÃ®te de nuitâ€. ğŸ’ƒğŸ¾ğŸ•ºğŸ»ğŸª© Tu feras sÃ»rement quelques erreurs, mais se tromper est justement la meilleure faÃ§on dâ€™apprendre, alors surtout: va jusquâ€™au bout de ton idÃ©e ! â€ ğŸ’â€ â€ Jâ€™ai lâ€™idÃ©e en tÃªte, mon design est prÃªt, et coder en C# ne me fait pas peur, on attaque ? Allez câ€™est parti, rendez-vous au prochain article ! Plus dâ€™articles dans la mÃªme sÃ©rie: Ma toute premiÃ¨re app en .NET MAUI Installation du projet .NET MAUI PremiÃ¨re exÃ©cution de lâ€™app .NET MAUI Le MVVM, pour une application rÃ©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les Ã©lÃ©ments d'une page .NET MAUI Affichage du lecteur MP3 - DurÃ©e d'Ã©coute Affichage du lecteur MP3 - ContrÃ´les de lecture Affichage du lecteur MP3 - Volume Ã‰couter de la musique en .NET MAUI avec MediaElement ContrÃ´ler la tÃªte de lecture avec MediaElement ContrÃ´ler le volume avec MediaElement TÃ©lÃ©charger un fichier audio en .NET MAUI Ã‰couter une playlist avec MediaElement ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/1-introduction/:0:0","tags":["New Project"],"title":"Ma toute premiÃ¨re app en .NET MAUI","uri":"/posts/tutos/my-first-app/1-introduction/"}]