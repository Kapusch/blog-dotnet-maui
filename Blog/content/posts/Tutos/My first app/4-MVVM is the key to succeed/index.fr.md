---
Topic: "MVVM is the key to succeed"
Title: "MVVM, la cl√© de la r√©ussite"
Category: "Tutos"
Subcategory: "My first app"
series: ["My first app"]
Index: "4"
PublishDate: "2023-01-12 00:00:04Z"
Language: "French"
Description: "Dans ce chapitre, nous d√©couvrirons un patron de conception majeur pour le d√©veloppement d‚Äôapplication mobile, le Model-View-ViewModel (MVVM) !"
Tags: ["MVVM","Data Binding",".NET Community Toolkit"]
featuredImagePreview: 'featured-image-preview-fr'
resources:
- name: 'featured-image-preview-fr'
  src: 'featured-image-preview-fr.png'
draft: false
---

<!--more-->


{{< admonition type=info title="‚Äé " open=true >}}
Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au <a href="../2-setup-the-project/">guide d‚Äôinstallation du projet</a> et repars de l‚Äôexemple situ√© dans le dossier *‚Äú0 - Get Started‚Äù*.
{{< /admonition >}}


Dans ce chapitre, nous d√©couvrirons un patron de conception majeur pour le d√©veloppement d‚Äôapplication mobile, le [Model-View-ViewModel](https://docs.microsoft.com/fr-fr/dotnet/maui/xaml/fundamentals/mvvm) ! (plus couramment appel√© ‚Äúle MVVM‚Äù)

# Le Model-View-ViewModel
Le MVVM est un patron de conception qui propose au d√©veloppeur une s√©paration logique de son code en 3 couches :

* La **View**, qui correspond √† l‚Äôinterface utilisateur, c‚Äôest-√†-dire tout ce que l‚Äôon va afficher √† l‚Äô√©cran (e.g. la page `HomeView`),

* Le **Model**, qui fait r√©f√©rence au type de donn√©es affich√©es dans cette View, 

* Et enfin le **ViewModel**, qui fait le lien entre la View et le Model. Par exemple, pour r√©cup√©rer des donn√©es depuis le Cloud ou r√©pondre aux interactions de l‚Äôutilisateur.




{{< admonition type=comment title="‚Äé " open=true >}}
üêí‚Äé ‚Äé Je vois bien la s√©paration en effet, mais pourquoi est-ce recommand√© ?
{{< /admonition >}}


L‚Äôun des principaux avantages du MVVM est de pouvoir isoler la vue (i.e. l‚Äôinterface utilisateur) de la logique ‚Äúm√©tier‚Äù. Dans le cadre de notre premi√®re page, on obtient finalement deux fichiers :

1. `HomeView.cs` qui d√©finit pr√©cis√©ment comment notre page s‚Äôaffichera (i.e. une couleur de fond, une image en haut, un bouton en bas),

1. Et `HomeViewModel.cs` qui regroupe toute la logique pour faire fonctionner notre page (ici, le comportement du bouton quand l‚Äôutilisateur appuie dessus).



En suivant ce principe, le d√©coupage de ton code est clair et tu limites le nombre de lignes de code par fichier. Tu ne voudrais pas d‚Äôun fichier de plus de 10 000 lignes ! üòÑ¬†En plus, il n‚Äôy a aucun risque d‚Äôaffecter la logique de ton app en changeant seulement la couleur d‚Äôun bouton.




{{< admonition type=comment title="‚Äé " open=true >}}
üêí‚Äé ‚Äé C‚Äôest clair ! Mais il y a un truc que je ne comprends pas, on n‚Äôa aucun Model pour la page HomeView ?
{{< /admonition >}}


Bonne remarque ! En effet, certaines pages sont tellement simples qu‚Äôelles ne n√©cessitent pas de Model. Dans ces cas-l√†, seuls les View et ViewModel seront donc requis.

# Le Data Binding
On sait d√©sormais bien d√©couper notre code en plusieurs couches. Par exemple, d√©finir un bouton dans une **View** et d√©clarer son action dans un **ViewModel**. Mais est-ce que tu saurais dire comment elles vont fonctionner ensemble ?




{{< admonition type=comment title="‚Äé " open=true >}}
üêí‚Äé ‚Äé Hmm‚Ä¶ peut-√™tre dire au bouton de cette View d‚Äôagir selon ce qui a √©t√© d√©clar√© dans ce ViewModel ?
{{< /admonition >}}


En effet, c‚Äôest quasiment √ßa ! Cela se d√©roule en deux temps :

1. On associe d‚Äôabord un **ViewModel** √† sa **View** (g√©n√©ralement via le `BindingContext` de la View),

1. Puis on d√©finit le comportement de chaque √©l√©ment de la View dans le ViewModel, en recourant au principe du [Data Binding](https://docs.microsoft.com/fr-fr/dotnet/maui/xaml/fundamentals/data-binding-basics).



Le Data Binding est une technique permettant de lier deux objets de sorte que, lorsque l‚Äôun des deux est modifi√©, l‚Äôautre le sera √©galement. √áa peut para√Ætre un peu flou comme √ßa, mais tu comprendras mieux son r√¥le dans la section d‚Äôapr√®s. Pour le moment, on continue !

# Appliquer le MVVM
Maintenant que tu connais les bases du MVVM, je vais pouvoir t‚Äôapprendre √† l‚Äôappliquer concr√®tement dans l‚Äôapplication.

Commen√ßons par cr√©er un fichier qui servira de **ViewModel** pour notre `HomeView`. Pour cela, cr√©e d‚Äôabord un nouveau dossier *ViewModels* dans le projet, puis ajoutes-y un nouveau fichier.

<p align="center"><img max-width="100%" max-height="100%" src="./images/13D069507FD06EEE1219B994B5EF400D.png" /></p>
<figure></figure>



Ce sera une nouvelle classe vide appel√©e `HomeViewModel.cs` :

<p align="center"><img max-width="100%" max-height="100%" src="./images/882B0A5F6566F3663600300CD7ADCD68.png" /></p>
<figure></figure>



Ensuite, remplace son contenu par le suivant:

<p align="center" style="margin-bottom:-10px"><strong>Nom du fichier :</strong><code>HomeViewModel.cs</code></p>

```csharp
using System;

namespace NightClub.ViewModels;

public class HomeViewModel
{
	public HomeViewModel()
	{
	}

	async Task Enter()
	{
		await Application.Current.MainPage.DisplayAlert(
			"Well Done !",
			"You have successfully reached the end of this chapter.",
			"Next !");
	}
}
```


Bon, il n‚Äôy a vraiment rien de sp√©cial ici. C‚Äôest juste une classe d‚Äôobjet C# avec une m√©thode *Enter()* qui affiche du texte √† l‚Äô√©cran apr√®s un clic de l‚Äôutilisateur sur le bouton ‚ÄúENTER‚Äù.




{{< admonition type=comment title="‚Äé " open=true >}}
üêí‚Äé ‚Äé Ah ben quand m√™me, on vient de d√©finir l‚Äôaction du bouton de la page d‚Äôaccueil !
{{< /admonition >}}


Eh oui tu as raison, mais en l‚Äô√©tat, il reste inutilisable ! Souviens-toi, il n‚Äôy a toujours aucun lien entre la `HomeView` et le `HomeViewModel`.

Heureusement, il existe une librairie mise √† disposition par Microsoft qui va grandement nous simplifier la vie: le [MVVM Toolkit](https://learn.microsoft.com/fr-fr/dotnet/communitytoolkit/mvvm/).

Cette librairie a d√©j√† √©t√© ajout√©e au projet et tu peux le v√©rifier facilement en ouvrant la gestion des paquets NuGet. Fais donc un clic droit sur les d√©pendances du projet:

<p align="center"><img max-width="100%" max-height="100%" src="./images/2E26F5F62ECCA8C4F1A9DD30EF1A71E6.png" /></p>
<figure></figure>



Et voil√† la librairie en question ! Elle s‚Äôappelle *CommunityToolkit.Mvvm* :

<p align="center"><img max-width="100%" max-height="100%" src="./images/1B8394B94F3463AE709C4009855A5924.png" /></p>
<figure></figure>




{{< admonition type=tip title="‚Äé " open=true >}}
Aller plus loin avec [les paquets NuGet](https://learn.microsoft.com/fr-fr/nuget/)
{{< /admonition >}}
___
Voyons d√©sormais comment pr√©parer notre classe `HomeViewModel` pour √™tre un v√©ritable **ViewModel** :

1. Premi√®rement, fais-le h√©riter de la classe `ObservableObject`,

1. puis, d√©finis-le comme une classe partielle avec le mot-cl√© **partial**.



Tu devrais avoir la configuration suivante:

<p align="center" style="margin-bottom:-10px"><strong>Nom du fichier :</strong><code>HomeViewModel.cs</code></p>

```csharp
using System;
using CommunityToolkit.Mvvm.ComponentModel;

namespace NightClub.ViewModels;

public partial class HomeViewModel : ObservableObject
...
```



{{< admonition type=info title="‚Äé " open=true >}}
En faisant h√©riter HomeViewModel de la classe **ObservableObject**, Visual Studio rajoute automatiquement les `using` n√©cessaires √† la compilation. En effet, une r√©f√©rence √† *CommunityToolkit.Mvvm.ComponentModel* est requise pour que **ObservableObject** devienne r√©ellement compr√©hensible par l‚Äôapplication.
{{< /admonition >}}


Ces deux √©tapes sont n√©cessaires pour permettre au *MVVM Toolkit* de g√©n√©rer du code source √† la simple mention de mots-cl√©s sp√©cifiques. Concr√®tement, on √©crit un seul mot et hop, √ßa g√©n√®re tout seul des dizaines de lignes de code, c‚Äôest g√©nial, non ?! ü§ò



Par exemple ici, on va d√©finir notre m√©thode *Enter()* comme √©tant une commande en lui rajoutant un simple attribut `[RelayCommand]` , voil√† comment :

<p align="center" style="margin-bottom:-10px"><strong>Nom du fichier :</strong><code>HomeViewModel.cs</code></p>

```csharp
[RelayCommand]
async Task Enter()
{
    await Application.Current.MainPage.DisplayAlert(
        "Well Done !",
        "You have successfully reached the end of this chapter.",
        "Next !");
}
```


Avec seulement un mot, on a d√©sormais une commande *Enter()* qui supporte la technique du **Data Binding** ! Et ce uniquement gr√¢ce √† la librairie *MVVM Toolkit* qui s‚Äôoccupe de g√©n√©rer tout le code source n√©cessaire.




{{< admonition type=tip title="‚Äé " open=true >}}
Aller plus loin avec les [g√©n√©rateurs de code source MVVM](https://learn.microsoft.com/fr-fr/dotnet/communitytoolkit/mvvm/generators/overview)
{{< /admonition >}}


# Bient√¥t la d√©mo !
On y est presque ! Il ne reste plus qu‚Äô√† actionner la commande *Enter()* au clic du bouton ‚ÄúENTER‚Äù.

Tout d‚Äôabord, retourne dans le fichier `HomeView.cs` pour lier la vue au `HomeViewModel` via le **BindingContext **:

<p align="center" style="margin-bottom:-10px"><strong>Nom du fichier :</strong><code>HomeView.cs</code></p>

```csharp
public HomeView()
{
	BindingContext = new HomeViewModel();
	
	BackgroundColor = Colors.Black;
	
	Content = ...
}
```


Puis d√©finissons l‚Äôaction du bouton `EnterButton` avec **BindCommand** pour d√©clencher la commande *Enter()* sp√©cifi√©e dans le `HomeViewModel`:

<p align="center" style="margin-bottom:-10px"><strong>Nom du fichier :</strong><code>HomeView.cs</code></p>

```csharp
Button EnterButton => new Button
{
	Text = "ENTER",
	TextColor = Colors.White,
	BackgroundColor = Colors.Magenta,
	CornerRadius = 10
} .Bold() .Paddings(50, 2, 50, 2) .CenterHorizontal()
	.BindCommand("EnterCommand"); // Note: on doit ajouter "Command" apr√®s "Enter"
```


Et voil√† le travail !

<p align="center"><img max-width="100%" max-height="100%" src="./images/9CC6994A747DC1C4EB08533A14CF2067.gif" /></p>
<figure></figure>






{{< admonition type=comment title="‚Äé " open=true >}}
üêí‚Äé ‚Äé Ok donc si je comprends bien il faut faire √ßa √† peu pr√®s sur toutes les pages de l‚Äôapp, c‚Äôest pas si compliqu√© !
{{< /admonition >}}


Eh bien oui en th√©orie ! Mais il manque tout de m√™me plusieurs fonctionnalit√©s cl√©s d‚Äôune application : un syst√®me d‚Äôauthentification, une base de donn√©es, etc‚Ä¶

Tiens par exemple, une fois qu‚Äôon aura cr√©√© la page principale de l‚Äôapplication, il faudra bien pouvoir s‚Äôy rendre depuis la page d‚Äôaccueil ! C‚Äôest ce qu‚Äôon verra dans <a href="../5-how-to-navigate/">le prochain chapitre</a>.

___
Plus d'articles dans la m√™me s√©rie:
{{< series "My first app" >}}
