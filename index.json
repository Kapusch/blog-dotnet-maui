[{"categories":null,"content":"Dans cet √©pisode final, nous allons cr√©er des animations avec .NET MAUI pour instaurer une ambiance de folie. Mets vite tes lunettes car il va y avoir des flashs de partout !","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":" ‚Äé Cet article fait parti d‚Äôun cours (‚ÄùMa Premi√®re App‚Äù). Pour assurer son bon d√©roulement, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú5 - Music Player‚Äù. Bienvenue dans l‚Äô√©pisode final de cette s√©rie ! ‚úåÔ∏è¬†Si tu as suivi le cours jusqu‚Äôici, alors tu devrais avoir une application aboutie pour √©couter quelques morceaux de musique. Seulement voil√†, l‚Äôambiance reste un peu terne‚Ä¶ Or je t‚Äôavais promis une ambiance disco au tout d√©but de ce cours ! Du coup, aujourd‚Äôhui nous allons apprendre √† utiliser les animations en .NET MAUI pour mettre le feu sur la piste. Alors mets vite tes lunettes car il va y avoir des flashs de partout ! ü™© ","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/:0:0","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":"Mise en place des projecteurs Tu l‚Äôauras compris, je veux qu‚Äôon ait l‚Äôimpression d‚Äô√™tre dans une bo√Æte de nuit. Alors pour commencer, on va ajouter quelques spots lumineux dans la partie sup√©rieure de l‚Äô√©cran qui est repr√©sent√©e par notre Grid TopLayout. Dans l‚Äôid√©al, il faudrait disposer des projecteurs un peu partout, avec diff√©rentes tailles et couleurs‚Ä¶ L√† on parle clairement des param√®tres d‚Äôun objet ! En effet, nous allons d√©finir une nouvelle classe d√©di√©e aux spots de lumi√®re : la classe Spotlight. Commence donc par cr√©er un nouveau dossier Components dans le projet. Puis cr√©e un nouveau fichier Spotlight.cs dans ce dossier avec le contenu suivant : Nom du fichier :Spotlight.cs using Microsoft.Maui.Layouts; namespace NightClub.Views.Components; public class Spotlight : BoxView { public Spotlight(Color color, double size, double positionX, double positionY) { this.Color = color; CornerRadius = size / 2; AbsoluteLayout.SetLayoutBounds(this, new Rect(positionX, positionY, size, size)); AbsoluteLayout.SetLayoutFlags(this, AbsoluteLayoutFlags.PositionProportional); } } Comme tu vois, cette classe prend en param√®tre les 4 propri√©t√©s suivantes : la couleur (color) du spot lumineux, sa taille (size), et enfin, son alignement par rapport √† l‚Äôaxe horizontal (positionX) et vertical (positionY). Au fait, as-tu not√© que Spotlight h√©ritait de BoxView ? Souviens-toi, on avait d√©j√† utilis√© cet objet pour v√©rifier la disposition des √©l√©ments de la MusicPlayerView. ‚Äé üêí‚Äé ‚Äé D‚Äôaccord mais une BoxView, ce n‚Äôest pas rond du tout ! Promis, nos projecteurs ne seront pas rectangulaire. On va en effet les arrondir √† l‚Äôaide de la propri√©t√© CornerRadius, comme on l‚Äôavait fait pour le bouton de lecture ! Pour cela, la valeur du CornerRadius devra √™tre deux fois inf√©rieure √† la taille demand√©e (size). Justement, voyons maintenant comment la taille et la position du Spotlight ont √©t√© d√©finies : Nom du fichier :Spotlight.cs AbsoluteLayout.SetLayoutBounds(this, new Rect(positionX, positionY, size, size)); Avec la m√©thode SetLayoutBounds(), on applique la position et la taille demand√©e √† notre Spotlight (this), en lui passant un objet de type Rect. Il s‚Äôagit d‚Äôune structure repr√©sentant les coordonn√©es de notre composant, ainsi que ses dimensions. Enfin, on fait appel √† la m√©thode SetLayoutFlags() pour que cette position soit prise en compte de fa√ßon proportionnelle : AbsoluteLayout.SetLayoutFlags(this, AbsoluteLayoutFlags.PositionProportional); En r√©sum√©, la taille du Spotlight sera bien configur√©e en valeurs absolues, mais ses coordonn√©es seront pass√©es en valeurs proportionnelles. Seulement, ces m√©thodes ne peuvent fonctionner que sur des √©l√©ments contenus dans un AbsoluteLayout. ‚Äé üêí‚Äé ‚Äé Ah, on n‚Äôutilise plus de Grid finalement ? Si, si ! Mais disons que notre Grid TopLayout jouera le r√¥le de conteneur principal, alors que les projecteurs eux, seront ajout√©s √† un composant interm√©diaire de type AbsoluteLayout. En effet, ce composant permet lui aussi d‚Äôaligner des √©l√©ments, mais de fa√ßon beaucoup plus libre. C‚Äôest d‚Äôailleurs pour √ßa manipule des coordonn√©es ! On peut alors facilement placer nos objets o√π bon nous semble. ‚Äé D‚Äôailleurs, il est possible d‚Äôaligner des √©l√©ments en dehors des limites de la zone √©tablie par l‚ÄôAbsoluteLayout. Voil√† pour la classe Spotlight ! Il ne nous reste donc plus qu‚Äô√† d√©finir un AbsoluteLayout, lui ajouter quelques Spotlight, et rattacher le tout au TopLayout. Pour cela, d√©clarons une nouvelle m√©thode InitDanceFloor() dans la MusicPlayerView : Nom du fichier :MusicPlayerView.cs // Ne pas oublier d'ajouter \"using NightClub.Views.Components;\" ! #region Dance Floor void InitDanceFloor() { // On d√©finit un conteneur interm√©diaire de type AbsoluteLayout... AbsoluteLayout spotlights = new AbsoluteLayout() { Children = { // ... auquel on ajoute quelques Spotlight... new Spotlight(Colors.Blue, 200, 0, 0), new Spotlight(Colors.Orange, 150, 0.8, 0.9), new Spotlight(Colors.Pink, 100, 0.9, 0.2), new Spotlight(Colors.Yellow, 120, 0.3,","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/:1:0","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":"Peaufiner le visuel pour un peu plus de r√©alisme Jusqu‚Äô√† pr√©sent, pour colorer nos √©l√©ments visuels il suffisait de d√©finir une couleur et la magie op√©rait en arri√®re-plan. Cependant, il existe diff√©rentes techniques de coloriage qui vont nous aider √† obtenir un meilleur visuel : ce sont les Brush. Par exemple, nous allons utiliser le RadialGradientBrush pour appliquer un joli d√©grad√© radial : Nom du fichier :Spotlight.cs public Spotlight(Color color, double size, double positionX, double positionY) { // Tu peux d√©sormais supprimer la ligne suivante : // this.Color = color; Background = new RadialGradientBrush() { GradientStops = new GradientStopCollection { new GradientStop(color, 0), new GradientStop(Colors.Transparent, 1) } }; ... } Concr√®tement, on a d√©fini un d√©grad√© de couleurs depuis le centre du Spotlight jusqu‚Äôaux bords, gr√¢ce √† l‚Äôutilisation de deux GradientStop : Avec l‚Äôinstruction GradientStop(color, 0), le centre du Spotlight (0) est d‚Äôabord peint de la couleur demand√©e (color), Puis un d√©grad√© s‚Äôop√®re avec GradientStop(Colors.Transparent, 1) pour aller vers la transparence la plus totale (Colors.Transparent) au niveau de la circonf√©rence du Spotlight (1). Et gr√¢ce √† l‚Äôeffet de transparence, on verra alors appara√Ætre le fond noir du TopLayout. ‚Äé Plus besoin de la propri√©t√© Color en utilisant la propri√©t√© Background. Ensuite, nous allons utiliser le Shadow pour donner un effet de brillance : Nom du fichier :Spotlight.cs public Spotlight(Color color, double size, double positionX, double positionY) { ... Shadow = new Shadow() { Radius = (float)(size / 2), Brush = new SolidColorBrush(color) }; ... } Avec ce code, on ajoute une ombre au Spotlight qui est √† la fois color√©e et floue : C‚Äôest la propri√©t√© Radius qui donne cet effet flout√©, accentu√© selon la taille de l‚Äôobjet (size / 2), Et l‚Äôombre est peinte avec une couleur pleine, gr√¢ce √† l‚Äôutilisation du SolidColorBrush. Voyons de nouveau ce que √ßa rend √† l‚Äô√©cran : Les spots sont bien plus r√©alistes ! C‚Äôest mieux l√†, non ? üôÇ Mais ces nouveaux ajustements contrastent un peu avec le BottomLayout, il faudrait rendre ce Grid moins opaque. ‚Äé üêí‚Äé ‚Äé Justement, on ne peut pas jouer avec la propri√©t√© Opacity ? Pas vraiment‚Ä¶ sinon c‚Äôest tout le contenu du BottomLayout qui deviendra transparent ! On ne verrait alors plus nos contr√¥les, ce ne serait pas tr√®s pratique. On va plut√¥t changer sa couleur en y ajoutant un peu de transparence, comme ceci : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { BackgroundColor = Colors.DimGray.WithAlpha(0.4f), ... }; Tu vois, c‚Äôest toujours la m√™me couleur ! Mais elle contient maintenant 40% de transparence gr√¢ce √† la m√©thode WithAlpha(). Et voil√† le r√©sultat ! Cette transparence, √ßa fait plus moderne ! Bon c‚Äôest joli tout √ßa, mais √ßa reste quand m√™me tr√®s statique. Il nous faudrait un peu de folie, de l‚Äôanimation quoi ! √áa tombe bien, on d√©couvre les animations en .NET MAUI juste apr√®s. ","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/:2:0","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":"C‚Äôest l‚Äôheure du disco! Dans cette partie, nous allons voir comment apporter un peu de dynamisme √† nos spots. Apr√®s tout, ce qu‚Äôon veut c‚Äôest une v√©ritable ambiance de bo√Æte de nuit ! üôÇ Pour cela, on va modifier encore la classe Spotlight pour faire en sorte que nos spots clignotent, un peu comme des flashs, tu vois ? On utilisera pour cela une animation de type fondu pour progressivement faire appara√Ætre ou dispara√Ætre nos projecteurs √† l‚Äô√©cran. Allez, mettons-nous au travail ! Commence par appliquer les modifications suivantes : Nom du fichier :Spotlight.cs public class Spotlight : BoxView { // On a ajout√© 3 nouvelles propri√©t√©s... const string AnimationName = \"fadeInAndOut\"; uint AnimationLength { get; set; } Animation SpotlightAnimation { get; set; } // ... ainsi qu'un nouveau param√®tre au constructeur ! public Spotlight(Color color, double size, double positionX, double positionY, uint animationLength = 0) { ... // Et enfin, on persiste la dur√©e d'animation. this.AnimationLength = animationLength; SetAnimation(); } } Tout d‚Äôabord, nous avons ajout√© un nouveau param√®tre : animationLength. C‚Äôest pour d√©finir la dur√©e (en millisecondes) sur laquelle l‚Äôanimation va se r√©p√©ter en boucle. On en a aussi profit√© pour rajouter quelques propri√©t√©s que nous allons utiliser un peu plus tard. Parmi elles, il y a SpotlightAnimation qui contiendra la d√©finition de l‚Äôanimation du Spotlight. Justement, ajoutons une nouvelle m√©thode √† la classe Spotlight pour d√©finir cette animation : Nom du fichier :Spotlight.cs void SetAnimation() { if (AnimationLength \u003c= 0) return; var fadeInAnimation = new Animation(v =\u003e Opacity = v, start: 0, end: 1, Easing.CubicOut); var fadeOutAnimation = new Animation(v =\u003e Opacity = v, start: 1, end: 0, Easing.CubicOut); SpotlightAnimation = new Animation { { 0, 0.5, fadeInAnimation }, // En action de 0 √† 50% de l'ex√©cution { 0.5, 1, fadeOutAnimation } // En action de 50 √† 100% de l'ex√©cution }; StartAnimation(); } C‚Äôest un peu technique, mais pas compliqu√©. Je vais t‚Äôexpliquer ! ü§ì La propri√©t√© SpotlightAnimation est une animation personnalis√©e compos√©e de deux animations sous-jacentes : Un fondu entrant qui modifie progressivement l‚Äôopacit√© du Spotlight de 0 √† 1, pendant toute la premi√®re moiti√© de l‚Äôanimation : { 0, 0.5, fadeInAnimation }, Et un fondu sortant, qui fait exactement l‚Äôinverse durant toute la deuxi√®me moiti√© de l‚Äôanimation : { 0.5, 1, fadeOutAnimation }. Et quant √† l‚Äôoption Easing.CubicOut, il s‚Äôagit seulement d‚Äôun effet de style pour que l‚Äôanimation ralentisse rapidement apr√®s le d√©but de son ex√©cution. ‚Äé Aller plus loin avec les diff√©rents types de rendu d‚Äôanimation. Voil√†, c‚Äôest tout pour la m√©thode SetAnimation()‚Ä¶ enfin, presque ! ‚Äé üêí‚Äé ‚Äé Quoi, quoi ?! Qu‚Äôest-ce qu‚Äôon a loup√© ? üôà √Ä la fin de la m√©thode, tu peux observer l‚Äôinstruction StartAnimation();. C‚Äôest elle qui va d√©clencher l‚Äôex√©cution de l‚Äôanimation fraichement initialis√©e. En voici la d√©finition : Nom du fichier :Spotlight.cs public void StartAnimation() { if (AnimationLength \u003c= 0) return; SpotlightAnimation.Commit(this, AnimationName, length: AnimationLength, repeat: () =\u003e true); } Tu l‚Äôauras compris, c‚Äôest la m√©thode Commit() qui permet de lancer l‚Äôanimation d√©finie plus haut. D√©composons les param√®tres pass√©s lors du Commit, on a : Un nom d‚Äôanimation (AnimationName), d√©fini arbitrairement par une constante, Une dur√©e d‚Äôex√©cution (AnimationLength), pass√©e en param√®tre du constructeur de la classe Spotlight, Et un mode de r√©p√©tition (repeat: () =\u003e true), pour que l‚Äôanimation soit jou√©e en boucle ind√©finiment. Prends un moment pour assimiler tous ces nouveaux changements ! ‚Äé Dans certains cas, les animations peuvent √™tre d√©sactiv√©es par le syst√®me. Par exemple : pour des raisons d‚Äôaccessibilit√© ou d‚Äô√©conomie d‚Äô√©nergie. Et quand tu te sens pr√™t¬∑e, reviens dans le code de la MusicPlayerView pour modifier la m√©thode InitDanceFloor() et adapter l‚Äôinitialisation des Spotlight, comme ceci : Nom du fichier :MusicPlayerView.cs AbsoluteLayout spot","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/:3:0","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":"La touche finale Tiens bon ! On va aborder encore quelques petites am√©liorations et ce sera la fin de ce cours. Commen√ßons d√©j√† par voir comment arr√™ter une animation en cours d‚Äôex√©cution. Pour cela, reviens dans la classe Spotlight et rajoute la m√©thode suivante : Nom du fichier :Spotlight.cs public void StopAnimation() { this.AbortAnimation(AnimationName); this.Opacity = 0; } On a seulement besoin d‚Äôappeler la m√©thode AbortAnimation() pour annuler une animation en cours d‚Äôex√©cution, √† l‚Äôaide de son nom (AnimationName). Rappelle-toi, c‚Äôest un des param√®tres que l‚Äôon avait pass√© dans la m√©thode Commit() ! ‚Äé On ne peut pas pr√©voir dans quel √©tat une animation va s‚Äôarr√™ter. Du coup, on bascule l‚Äôopacit√© du Spotlight √† 0 pour le cacher compl√®tement quand la musique ne joue plus. Voyons ensuite comment jouer l‚Äôanimation selon si la musique est en cours de lecture ou non. Pour cela, on doit √©tablir un lien entre le Spotlight et le MediaElement. Commen√ßons par modifier la classe Spotlight : Nom du fichier :Spotlight.cs // Attention, 3 nouveaux using sont n√©cessaires ! using CommunityToolkit.Maui.Core.Primitives; using CommunityToolkit.Maui.Markup; using CommunityToolkit.Maui.Views; ... public class Spotlight : BoxView { ... // Un nouveau param√®tre est ajout√© au constructeur... public Spotlight(Color color, double size, double positionX, double positionY, uint animationLength = 0, MediaElement bindableMediaElement = null) { ... // ... pour les besoins de la configuration de l'animation. SetAnimation(bindableMediaElement); } ... } Pour √©viter la r√©p√©tition de code, on a ajout√© un nouveau param√®tre bindableMediaElement de type MediaElement. En effet, on va passer notre composant MusicPlayer √† l‚Äôinitialisation de chaque Spotlight pour les besoins de la configuration de l‚Äôanimation. Nous allons justement modifier la m√©thode SetAnimation() pour appliquer les nouvelles conditions d‚Äôex√©cution de l‚Äôanimation : Nom du fichier :Spotlight.cs void SetAnimation(MediaElement mediaElement = null) { ... if(mediaElement != null) { this.Bind( source: mediaElement, path: nameof(mediaElement.CurrentState), convert: (MediaElementState currentState) =\u003e { if (currentState != MediaElementState.Playing) StopAnimation(); else StartAnimation(); return true; }); } } Maintenant qu‚Äôon a acc√®s √† notre MediaElement, on a appliqu√© la technique du Data Binding sur la propri√©t√© CurrentState pour que l‚Äôanimation soit : D√©marr√©e quand la musique est en cours de lecture, Ou arr√™t√©e si la musique est mise en pause. Et comme toujours, on n‚Äôoublie pas d‚Äôadapter l‚Äôinitialisation des Spotlight dans la m√©thode InitDanceFloor(), comme ceci : Nom du fichier :MusicPlayerView.cs AbsoluteLayout spotlights = new AbsoluteLayout() { Children = { // On passe bien le MusicPlayer √† chaque Spotlight new Spotlight(Colors.Blue, 200, 0, 0, 2000, MusicPlayer), new Spotlight(Colors.Orange, 150, 0.8, 0.9, 1000, MusicPlayer), new Spotlight(Colors.Pink, 100, 0.9, 0.2, 500, MusicPlayer), new Spotlight(Colors.Yellow, 120, 0.3, 0.6, 1500, MusicPlayer), } }; Ici, on a simplement pass√© le MusicPlayer √† l‚Äôinitialisation des Spotlight pour que chacun des projecteurs puisse √™tre √©teint ou allum√© au gr√© de la musique. Voil√†, je te fais confiance pour v√©rifier que √ßa fonctionne bien avant qu‚Äôon ajoute la touche finale. Ben oui, notre piste manque encore de quelques danseurs passionn√©s ! Commence donc par t√©l√©charger les deux nouvelles images suivantes au format .svg : La premi√®re repr√©sente des gros haut-parleurs (speakers.svg), Et l‚Äôautre, nos fameux danseurs (joyful_dancers.svg). Dance_Floor_-_Images.zip ./files/Dance_Floor_-_Images.zip Une fois le fichier .zip d√©compress√©, ajoute les images au dossier Resources/Images. ‚Äé Si tu as des doutes sur comment faire, tu peux te r√©f√©rer √† ce chapitre. Enfin, rajoute-les au TopLayout de cette fa√ßon : void InitDanceFloor() { ... TopLayout.Add(spotlights); // .NET MAUI convertit les fichiers SVG au format PNG. TopLayout.Add(new Image() { Source = \"speakers.png\" }.B","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/:3:1","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":"Conclusion Cet article marque la fin de ce cours, un total de 2h30 de lecture qui je l‚Äôesp√®re t‚Äôaura plu et t‚Äôinspirera plein d‚Äôautres id√©es. Et merci pour ta fid√©lit√© si tu as suivi l‚Äôint√©gralit√© de ce cours ! Si tu as un moment, √©cris-moi un commentaire ou un e-mail pour me dire ce que tu en as pens√©. Au fait, si tu veux t‚Äôamuser √† aller plus loin (et je t‚Äôy encourage chaudement ! üôÇ), tu peux essayer de g√©n√©rer les projecteurs de fa√ßon compl√®tement al√©atoire. Tu pourras toujours comparer ta solution avec la mienne en regardant directement dans le code final du projet ! ‚Äé Pour r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier¬†‚ÄúFull Solution‚Äù. Et si tu en veux encore plus, alors voici d‚Äôautres pistes d‚Äôam√©lioration √† creuser : Calquer la luminosit√© des spots sur le volume de la musique, Ajuster leur vitesse d‚Äôanimation selon le tempo des chansons, Reg√©n√©rer tous les spots lumineux quand on change de chanson, etc. J‚Äôadorerais voir ta cr√©ativit√© √† l‚Äô≈ìuvre, alors si tu peux, partage-moi en commentaire un lien vers ton r√©po GitHub ! Voil√†, c‚Äôest tout pour aujourd‚Äôhui. √Ä bient√¥t pour de nouveaux tutos ! üëã Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"16/01/2024","objectID":"/posts/tutos/my-first-app/15-add-animations-to-an-app/:4:0","tags":["Animation","AbsoluteLayout","Round Effect","Brush"],"title":"Cr√©er des animations avec .NET MAUI pour une ambiance disco","uri":"/posts/tutos/my-first-app/15-add-animations-to-an-app/"},{"categories":null,"content":"L‚Äôapplication est bien, mais √ßa serait plus sympa si on pouvait changer de morceau. √áa tombe bien, on va int√©grer aujourd‚Äôhui une playlist musicale !","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"√âcouter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":" ‚Äé Afin d‚Äôassurer le bon d√©roulement de cet article, je t‚Äôinvite √† repartir depuis ce chapitre o√π l‚Äôon a configur√© le MediaElement. La derni√®re fois, nous avions vu comment t√©l√©charger de la musique directement depuis l‚Äôapp. Seulement, c‚Äôest la m√™me chanson depuis le d√©but ! L‚Äôapplication serait bien plus sympa si on pouvait changer de morceau, non ? √áa tombe bien, on va y int√©grer aujourd‚Äôhui une playlist musicale. ","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:0:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"√âcouter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Cr√©ation de la playlist Pour cela, d√©finissons d√©j√† la liste des morceaux disponibles dans l‚Äôapplication comme ceci : Nom du fichier :MusicPlayerViewModel.cs static readonly MusicTrack[] playlist = new MusicTrack[] { new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1890762\u0026format=mp31\u0026from=b5bSbOTAT1kXawaT8EV9IA%3D%3D%7CGcDX%2BeejT3P%2F0CfPwtSyYA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1890762/mp32/\", Author = \"Alfonso Lugo\", Title = \"Baila\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=619144\u0026format=mp31\u0026from=%2BJv5PkdWd%2BvsByBkyrboJA%3D%3D%7Co%2FKvdc5gcd6iQLjnqacjYA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/619144/mp32/\", Author = \"Pablo G√≥mez\", Title = \"Devastation (remastered)\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1399476\u0026format=mp31\u0026from=LQFaB9%2FDVAE6QaK%2BsXtl%2FA%3D%3D%7CouuozaATpW3zoEvVwprgRw%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1399476/mp32/\", Author = \"Singularity\", Title = \"How many times\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=946449\u0026format=mp31\u0026from=blTB635bS8UiDVL%2FzZC2Xw%3D%3D%7CQO1Fj6AWgTrjIu7LELLCLA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/946449/mp32/\", Author = \"Julien Gathy\", Title = \"Octave (HQ)\", }, new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1026396\u0026format=mp31\u0026from=nWYOo%2FxFcd1oJBINLSQAXg%3D%3D%7CI8xQbXqZfz2bfgmtqxmqyA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1026396/mp32/\", Author = \"dj alike\", Title = \"dj alike (new trance edition)\", } }; Rien d‚Äôextraordinaire ici, si ce n‚Äôest la d√©monstration de l‚Äôutilit√© de notre Model ! ‚Äé üêí‚Äé ‚Äé Oh oui, 5 chansons, √ßa va groover !! üôä Mais c‚Äôest √ßa oui, moque-toi ! üòÇ Le nombre de chansons est limit√© √† 5 pour les besoins de ce cours, mais imagine si on permettait √† l‚Äôutilisateur d‚Äôexplorer des titres du monde entier ! ‚Äé Il n‚Äôest pas improbable que je r√©fl√©chisse √† une suite de ce cours, peut-√™tre en vid√©o ! Mais revenons √† nos moutons. La logique que l‚Äôon va impl√©menter consiste √† passer d‚Äôun morceau √† un autre parmi notre playlist. C‚Äôest un peu comme un pointeur qui glisse sur les cases d‚Äôun tableau d‚Äô√©l√©ments de type MusicTrack pour d√©finir la prochaine musique √† jouer. Pour cela, nous allons am√©liorer la logique autour de la propri√©t√© CurrentTrack introduite dans le chapitre pr√©c√©dent avec le code suivant : Nom du fichier :MusicPlayerViewModel.cs #region Properties ... // Une nouvelle propri√©t√© pour d√©finir la position du \"pointeur\" [ObservableProperty] [NotifyPropertyChangedFor(nameof(CurrentTrack))] int currentTrackPosition = 0; // Attention √† bien renommer la propri√©t√© avec un \"C\" majuscule public MusicTrack CurrentTrack =\u003e playlist[CurrentTrackPosition]; #endregion public MusicPlayerViewModel() { // Nous n'avons plus besoin du code ci-apr√®s, √† supprimer ! // CurrentTrack = new MusicTrack() // { // ... // }; } On a ajout√© une nouvelle propri√©t√© nomm√©e currentTrackPosition qui correspond en quelque sorte √† notre pointeur √©voqu√© plus haut. C‚Äôest elle qui va d√©finir la position de la chanson qu‚Äôil faut jouer parmi la playlist, gr√¢ce √† ce nouvel attribut : NotifyPropertyChangedFor(). Concr√®tement, √† chaque changement de valeur de la propri√©t√© currentTrackPosition, cet attribut va d√©clencher une notification vers la View pour l‚Äôinformer que la propri√©t√© CurrentTrack vient d‚Äô√™tre mise √† jour. En effet, la propri√©t√© CurrentTrack a √©t√© adapt√©e pour retourner un titre musical depuis la playlist √† la position demand√©e (playlist[CurrentTrackPosition]). ‚Äé D‚Äôailleurs, nous n‚Äôavons plus besoin d‚Äôinitialiser CurrentTrack depuis le constructeur du MusicPlayerViewModel ! Tu peux donc supprimer ce bout de code. C‚Äôest d√©j√† l‚Äôheure de relancer l‚Äôapplication ! ‚Äé üêí‚Äé ‚Äé Mais je n‚Äôai vu aucun changement, c‚Äôest normal ? Exact, c‚Äôe","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:1:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"√âcouter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Binding des composants Attention, r√©v√©lation : on va d√©sormais s‚Äôattaquer aux derniers composants factices de l‚Äôapplication ! Si tu te rappelles bien du chapitre sur l‚Äôaffichage des contr√¥les de lecture, il nous reste 3 composants de type ImageButton √† impl√©menter : SkipNextButton pour passer √† la chanson suivante, SkipPreviousButton pour revenir √† la chanson pr√©c√©dente, et RepeatOnceButton pour rejouer la piste musicale (une seule fois). Pour passer √† la prochaine chanson, c‚Äôest tr√®s simple. Commence par ajouter la commande suivante dans le ViewModel : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] void GoToNextTrack() { if (CurrentTrackPosition + 1 \u003c playlist.Length) CurrentTrackPosition++; else CurrentTrackPosition = 0; } ... #endregion Puis associe la nouvelle commande au bouton SkipNextButton depuis la View : Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... ImageButton SkipNextButton = new ImageButton // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù { HeightRequest = 75, WidthRequest = 75, Source = \"skip_next.png\" } .BindCommand(\"GoToNextTrackCommand\"); // et voil√† la commande associ√©e ... #endregion Le comportement d√©fini dans la m√©thode GoToNextTrack() consiste √† simplement d√©placer d‚Äôun cran en avant la position du pointeur sur le tableau. Bien s√ªr, quand la derni√®re case du tableau est atteinte, alors on retourne au d√©but de la playlist. Et si on testait ? Super, on peut enfin √©couter d‚Äôautres chansons ! ‚Äé üêí‚Äé ‚Äé C‚Äô√©tait rapide ! Et pour revenir en arri√®re dans la playlist, on fait juste l‚Äôinverse ? Presque ! Pour revenir √† la chanson pr√©c√©dente, on va en effet impl√©menter une logique similaire √† une condition pr√®s. En effet, j‚Äôaimerais d‚Äôabord que la chanson red√©marre avant de basculer vers la chanson pr√©c√©dente. Je vais t‚Äôexpliquer comment. Ajoute d√©j√† la commande suivante dans le ViewModel : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] void GoToPreviousTrack(double elapsedTimeForCurrentTrack) { if (elapsedTimeForCurrentTrack \u003c 2) { // Soit on revient un cran en arri√®re dans la playlist if (CurrentTrackPosition - 1 \u003e= 0) CurrentTrackPosition--; else CurrentTrackPosition = playlist.Length - 1; } else { // Ou bien on r√©initialise le morceau en cours // en for√ßant la notification vers la View OnPropertyChanged(\"CurrentTrack\"); } } ... #endregion Le comportement d√©fini dans la m√©thode GoToPreviousTrack() consiste √† simplement d√©placer d‚Äôun cran en arri√®re la position du pointeur sur le tableau. Bien s√ªr, quand la premi√®re case du tableau est atteinte, alors on bascule √† la derni√®re chanson de la playlist. Mais as-tu remarqu√© la condition impos√©e dans le if? On ne doit revenir √† la chanson pr√©c√©dente que si la chanson en cours a √©t√© jou√©e depuis moins de 2 secondes. ‚Äé üêí‚Äé ‚Äé Mais comment va-t‚Äôon faire pour obtenir cette information ? Jusqu‚Äô√† pr√©sent, nous n‚Äôavions vu que des commandes sans param√®tre. Mais cette fois-ci, on va partager l‚Äôinformation TimeTracker.Value en param√®tre de la commande √† associer au SkipPreviousButton. Pour cela, applique les changements suivants dans la View : Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... ImageButton SkipPreviousButton = new ImageButton // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù { HeightRequest = 75, WidthRequest = 75, Source = \"skip_previous.png\" } .BindCommand(\"GoToPreviousTrackCommand\", // et voil√† la commande associ√©e, avec un param√®tre ! parameterPath: nameof(TimeTracker.Value), parameterSource: TimeTracker); ... #endregion On emploie toujours BindCommand(), mais on utilise deux param√®tres suppl√©mentaires pour les besoins de notre m√©thode GoToPreviousTrack() : L‚Äôinformation √† passer en param√®tre (parameterPath), c‚Äôest le TimeTracker.Value correspondant au temps de lecture √©coul√©, Et la source de cette propri√©t√© (parameterSource), c‚Äôest bien s√ªr le TimeTracker. Enfin, dans le cas o√π l‚Äôon doit red√©marrer la chanson, on fait preuve d‚Äôun peu d‚Äôastuce en utilisant la m√©thode OnPropertyChanged(). En effet,","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:2:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"√âcouter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Rejouer le morceau une fois C‚Äôest la derni√®re ligne droite de ce cours, accroche-toi ! Pour permettre la r√©p√©tition d‚Äôun morceau, nous devons d‚Äôabord ajouter la propri√©t√© suivante dans le ViewModel : Nom du fichier :MusicPlayerViewModel.cs #region Properties ... [ObservableProperty] bool mustRepeatCurrentTrackOnce; #endregion Il s‚Äôagit d‚Äôun bool√©en classique dont l‚Äô√©tat sera modifi√© via sa commande d√©di√©e : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] void ToggleRepeatOnce() { MustRepeatCurrentTrackOnce = !MustRepeatCurrentTrackOnce; } ... #endregion L‚Äôid√©e est qu‚Äô√† chaque clic de l‚Äôutilisateur, on inverse l‚Äô√©tat du bool√©en afin d‚Äôactiver ou d√©sactiver la r√©p√©tition. Il ne nous reste alors plus qu‚Äô√† associer cette commande au bouton RepeatOnceButton depuis la View : Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... ImageButton RepeatOnceButton = new ImageButton // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"repeat_once.png\", BackgroundColor = Colors.Black, BorderColor = Colors.GreenYellow // On rajoute une bordure color√©e au bouton } .BindCommand(\"ToggleRepeatOnceCommand\"); // Et voil√† la commande associ√©e ... #endregion Comme tu l‚Äôauras peut-√™tre remarqu√©, j‚Äôai d√©fini une couleur pour le contour du RepeatOnceButton avec la propri√©t√© BorderColor. C‚Äôest pour am√©liorer le rendu visuel quand la r√©p√©tition est enclench√©e ! Pour cela, on va se baser √©videmment sur la propri√©t√© MustRepeatCurrentTrackOnce. Modifie donc la m√©thode InitMediaControlPanel() pour appliquer les changements suivants : Nom du fichier :MusicPlayerView.cs void InitMediaControlPanel() { ... RepeatOnceButton.Bind( targetProperty: ImageButton.BorderWidthProperty, path: nameof(MusicPlayerViewModel.MustRepeatCurrentTrackOnce), convert: (bool isEnabled) =\u003e isEnabled ? 2 : 0); } Avec ce code, on joue avec l‚Äô√©paisseur des bordures (BorderWidth) du bouton RepeatOnceButton selon si l‚Äôoption de r√©p√©tition est activ√©e ou non. En effet, il faut savoir que l‚Äô√©paisseur du contour est par d√©faut n√©gative ! On ne risque pas de voir de contour avec une √©paisseur n√©gative ! Autrement dit, on ne verra aucune bordure √† moins de modifier nous-m√™mes la valeur du BorderWidth. C‚Äôest pourquoi, dans le convert, on d√©finit une valeur positive pour faire appara√Ætre un contour color√© quand MustRepeatCurrentTrackOnce est √©gal √† True. On voit bien quand la r√©p√©tition est active. Bon apr√®s, les go√ªts et les couleurs, c‚Äôest autre chose ! ‚Äé üêí‚Äé ‚Äé C‚Äôest tr√®s bien, mais √ßa ne va pas nous aider √† boucler le morceau, non ? C‚Äôest vrai ! En fait, on va se baser sur le param√®tre MustRepeatCurrentTrackOnce pour savoir s‚Äôil faut red√©marrer la chanson √† la fin du morceau, ou passer √† la chanson suivante. Et cette logique sera d√©finie dans le ViewModel avec cette nouvelle m√©thode publique : Nom du fichier :MusicPlayerViewModel.cs public void AssessRepeatOrSkip() // La m√©thode doit √™tre publique { if (MustRepeatCurrentTrackOnce) { // Soit on r√©initialise le morceau en cours // en for√ßant la notification vers la View OnPropertyChanged(\"CurrentTrack\"); MustRepeatCurrentTrackOnce = false; } else { // Ou bien on se d√©place d'une position vers l'avant dans la playlist GoToNextTrack(); } } Selon que MustRepeatCurrentTrackOnce est √† True ou False, on fait soit √† nouveau appel √† la technique du OnPropertyChanged() que l‚Äôon a vue plus haut, ou bien on passe √† la chanson suivante avec la m√©thode GoToNextTrack(). Au fait, on ne veut r√©p√©ter la chanson qu‚Äôune seule fois ! Alors n‚Äôoublie pas de d√©sactiver la r√©p√©tition en passant la propri√©t√© MustRepeatCurrentTrackOnce √† False. Enfin, pour d√©tecter le moment o√π la chanson se termine, on va se baser sur l‚Äô√©v√®nement MediaEnded expos√© par le MediaElement, comme ceci : Nom du fichier :MusicPlayerView.cs void InitMusicPlayer() { ... MusicPlayer.MediaEnded += MusicPlayer_MediaEnded; } Et c‚Äôest au moment o√π l‚Äô√©v√®nement se d√©clenche que l‚Äôon va demander √† r√©p√©ter la chanson","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:3:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"√âcouter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Conclusion Bon eh bien voil√†, est-ce que le r√©sultat te pla√Æt ? On peut d√©sormais profiter de l‚Äôapplication et √©couter quelques titres √† la suite, au volume souhait√©, r√©√©couter quelques passages, et m√™me t√©l√©charger les morceaux ! üòé ‚Äé Pour r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours, r√©f√®re-toi au¬†guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier¬†‚Äú5 - Music Player‚Äù. Mais √ßa manque un peu d‚Äôanimation pour une ambiance ‚Äúbo√Æte de nuit‚Äù‚Ä¶ Or c‚Äô√©tait la promesse du d√©but ! On va rem√©dier √† √ßa dans le prochain article, et ce sera le dernier de cette s√©rie !! Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"26/12/2023","objectID":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/:4:0","tags":["MediaElement","MVVM","ImageButton","Data Binding"],"title":"√âcouter une playlist avec MediaElement","uri":"/posts/tutos/my-first-app/14-skip-next-or-previous-with-mediaelement/"},{"categories":null,"content":"Aujourd‚Äôhui, nous allons voir comment permettre √† l‚Äôutilisateur de t√©l√©charger la musique qui est en cours de lecture. Depuis le temps qu‚Äôon √©coute la m√™me chanson en boucle, je suis s√ªr que tu r√™vais de pouvoir la t√©l√©charger depuis l‚Äôapplication ! üòÑ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"T√©l√©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":" ‚Äé Afin d‚Äôassurer le bon d√©roulement de cet article, je t‚Äôinvite √† repartir depuis ce chapitre o√π l‚Äôon a configur√© le MediaElement. Et nous voil√† reparti pour un nouveau chapitre ! C‚Äôest d√©j√† l‚Äô√©pisode n¬∞13 de cette s√©rie, alors j‚Äôesp√®re que c‚Äôest toujours relativement simple √† suivre ! Mais il se peut que tu aies des questions ou des remarques. Si c‚Äôest le cas, pose-les moi en commentaires en bas de l‚Äôarticle ou √©cris-moi directement par e-mail (jeanemmanuel.baillat@gmail.com) ! Aujourd‚Äôhui, nous allons voir comment permettre √† l‚Äôutilisateur de t√©l√©charger la musique qui est en cours de lecture. Depuis le temps qu‚Äôon √©coute la m√™me chanson en boucle, je suis s√ªr que tu r√™vais de pouvoir la t√©l√©charger depuis l‚Äôapplication ! üòÑ ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:0:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"T√©l√©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"Cr√©ation d‚Äôun nouveau ViewModel Avant tout, nous devons mettre en place un nouveau ViewModel pour la vue MusicPlayerView. Pour cela, ajoute une nouvelle classe nomm√©e MusicPlayerViewModel dans le dossier ViewModels, et d√©finis-la avec le code suivant : Nom du fichier :MusicPlayerViewModel.cs using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace NightClub.ViewModels; public partial class MusicPlayerViewModel : ObservableObject { #region Properties #endregion public MusicPlayerViewModel() { } #region Commands #endregion } ‚Äé Si d√©chiffrer ce bout de code est difficile pour toi, alors ne te d√©courage pas et prends le temps de relire le chapitre sur le MVVM. √âvidemment, ce ViewModel ne fait rien pour le moment, mais il est pr√™t √† √™tre associ√© √† sa View. Ouvre donc le fichier MusicPlayerView.cs et modifie-le comme suit : Nom du fichier :MusicPlayerView.cs ... // Ce using est obligatoire pour retrouver la d√©finition du MusicPlayerViewModel using NightClub.ViewModels; namespace NightClub.Views; public class MusicPlayerView : ContentPage { public MusicPlayerView() { Console.WriteLine(\"[NightClub] MusicPlayerView - Constructor\"); // C'est ici que l'association s'op√®re ! BindingContext = new MusicPlayerViewModel(); NavigationPage.SetHasNavigationBar(this, false); BackgroundColor = Colors.DimGray; ... } ... } Comme pour le HomeViewModel que l‚Äôon avait associ√© avec la HomeView, on a modifi√© ici le BindingContext de la MusicPlayerView pour lui associer le nouveau MusicPlayerViewModel. Bon, c‚Äô√©tait rapide ! Voyons maintenant comment structurer les donn√©es de l‚Äôapplication en d√©finissant le Model des pistes musicales. ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:1:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"T√©l√©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"Une classe pour les pistes musicales Chaque piste musicale lue dans l‚Äôapplication se d√©finit par un panel d‚Äôinformations que l‚Äôon va regrouper dans une classe nomm√©e MusicTrack. Et comme tu l‚Äôauras compris, ce nouvel objet fait parti du Model de notre application. Commence donc par cr√©er un nouveau dossier intitul√© Models, puis ajoutes-y une nouvelle classe d√©finie par le code suivant : Nom du fichier :MusicTrack.cs namespace NightClub.Models; public class MusicTrack { public string AudioURL { get; set; } public string AudioDownloadURL { get; set; } public string Title { get; set; } public string Author { get; set; } } Pour les besoins de ce cours, 4 propri√©t√©s de type string sont n√©cessaires pour contenir les informations suivantes : Le lien d‚Äô√©coute du morceau (AudioURL), Le lien de t√©l√©chargement du morceau (AudioDownloadURL), Le nom du morceau (Title), Et le nom de l‚Äôauteur du morceau (Author). Comme il est d√©sormais possible de manipuler des pistes musicales, on va ajouter une propri√©t√© de type MusicTrack au MusicPlayerViewModel pour d√©finir la chanson en cours de lecture : Nom du fichier :MusicPlayerViewModel.cs ... using NightClub.Models; // Obligatoire pour utiliser la classe MusicTrack ! namespace NightClub.ViewModels; public partial class MusicPlayerViewModel : ObservableObject { #region Properties [ObservableProperty] MusicTrack currentTrack; #endregion ... } Une propri√©t√© qui s‚Äôadapte parfaitement au d√©coupage Model-View-ViewModel (MVVM) puisqu‚Äôon l‚Äôa d√©clar√©e comme √©tant une [ObservableProperty], une annotation fournie par la librairie MVVM Toolkit. Cette annotation va alors g√©n√©rer tout le code n√©cessaire pour d√©clencher des √©v√®nements (g√©n√©ralement vers la View) en cas de changement de valeur. En effet, on souhaite calquer les informations affich√©es dans la View sur le ViewModel qui lui est associ√©. ‚Äé üêí‚Äé ‚Äé Compris ! Mais comment va-t‚Äôon faire pour d√©finir cette chanson ? Pour l‚Äôinstant c‚Äôest facile car notre application ne supporte la lecture que d‚Äôune seule chanson. On va donc tout simplement l‚Äôinitialiser depuis le constructeur du MusicPlayerViewModel, comme ceci : Nom du fichier :MusicPlayerViewModel.cs public MusicPlayerViewModel() { CurrentTrack = new MusicTrack() { AudioURL = \"https://prod-1.storage.jamendo.com/?trackid=1890762\u0026format=mp31\u0026from=b5bSbOTAT1kXawaT8EV9IA%3D%3D%7CGcDX%2BeejT3P%2F0CfPwtSyYA%3D%3D\", AudioDownloadURL = \"https://prod-1.storage.jamendo.com/download/track/1890762/mp32/\", Author = \"Alfonso Lugo\", Title = \"Baila\", }; } ‚Äé Toutes ces informations sont fournies par Jamendo, un site de musique gratuite et ind√©pendante. Mais puisqu‚Äôon a d√©fini la piste musicale dans le MusicPlayerViewModel, il nous faut maintenant retravailler la MusicPlayerView pour reconfigurer le MusicPlayer. Pour cela, il va falloir modifier la m√©thode InitMusicPlayer() dans le MusicPlayerView, et appliquer le Data Binding √† la propri√©t√© Source du MediaElement : Nom du fichier :MusicPlayerView.cs ... using NightClub.Models; // Obligatoire pour utiliser la classe MusicTrack ! namespace NightClub.Views; public class MusicPlayerView : ContentPage { ... #region MusicPlayer MediaElement MusicPlayer = new MediaElement(); // Et voici la nouvelle d√©finition de la m√©thode... void InitMusicPlayer() { MusicPlayer.ShouldAutoPlay = true; // ... avec ici le binding sur le MusicPlayer. MusicPlayer.Bind( MediaElement.SourceProperty, nameof(MusicPlayerViewModel.CurrentTrack), convert: (MusicTrack musicTrack) =\u003e MediaSource.FromUri(musicTrack.AudioURL) ); } #endregion ... } Souviens-toi, la propri√©t√© Source du MediaElement permet de d√©finir la source du m√©dia qu‚Äôil doit jouer. Et d√©sormais, la propri√©t√© MusicPlayer.Source est rattach√©e dynamiquement √† la propri√©t√© CurrentTrack d√©finie dans le MusicPlayerViewModel. Bien-s√ªr, on n‚Äôoublie pas dans le convert de transformer le lien streaming audio (musicTrack.AudioURL) avec la m√©thode MediaSource.FromUri(), pour se conformer au type de la propri√©t√© Source du MediaElement. Et voil√† ! Relance ","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:2:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"T√©l√©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"T√©l√©charger un morceau Continuons maintenant notre petit bout de chemin en impl√©mentant le bouton de t√©l√©chargement. Pour cela, on va d√©j√† associer une action d√©clench√©e au clic sur le DownloadButton‚Ä¶ Nom du fichier :MusicPlayerView.cs #region Media Control Panel ... // N'oublie pas de transformer le signe \"=\u003e\" en \"=\" ! ImageButton DownloadButton = new ImageButton { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"download.png\", BackgroundColor = Colors.Black } .BindCommand(\"DownloadCurrentTrackCommand\"); // Et voici la commande associ√©e #endregion ‚Ä¶ et dont le comportement sera d√©fini dans MusicPlayerViewModel : Nom du fichier :MusicPlayerViewModel.cs ... using CommunityToolkit.Maui.Alerts; // Ce using est nouveau... using CommunityToolkit.Maui.Storage; // ... ainsi que celui-ci ! namespace NightClub.ViewModels; public partial class MusicPlayerViewModel : ObservableObject { ... #region Commands [RelayCommand] async Task DownloadCurrentTrack(CancellationToken cancellationToken) { await Toast .Make($\"[TEST] You have successfully downloaded \\\"{CurrentTrack.Title} - {CurrentTrack.Author}\\\"!\") .Show(cancellationToken); } #endregion } Tu te rappelles de l‚Äôannotation [RelayCommand] ? On y avait d√©j√† eu recours dans le chapitre sur le MVVM.¬†C‚Äôest elle qui permet √† notre m√©thode DownloadCurrentTrack() d‚Äô√™tre appel√©e depuis la View ! Et je t‚Äôarr√™te tout de suite, la m√©thode Toast() n‚Äôa rien √† voir avec ton petit-d√©jeuner ce matin üòÑ Cette m√©thode fournie par la librairie .NET MAUI Community Toolkit permet d‚Äôafficher temporairement un message √† l‚Äô√©cran, √† la mani√®re d‚Äôune notification directement int√©gr√©e dans l‚Äôapplication. √Ä ce stade, on peut d√©j√† tester que notre bouton fonctionne bien : Finalement, ce message est bien utile ! ‚Äé üêí‚Äé ‚Äé Oui mais tu essaies de m‚Äôarnaquer l√†, √ßa ne t√©l√©charge rien du tout ! üòÑ Je vais te partager le code final juste apr√®s‚Ä¶ patience ! ü§ì Juste avant, j‚Äôaurais aim√© attirer ton attention sur le param√®tre requis par notre nouvelle commande, le cancellationToken. Il s‚Äôagit d‚Äôun objet de type CancellationToken qui permet de garder un lien avec le code initiateur de l‚Äôappel √† la m√©thode DownloadCurrentTrack() en cas de demande d‚Äôannulation de son ex√©cution. C‚Äôest tr√®s utile pour les op√©rations un peu longues, par exemple si notre utilisateur d√©cidait d‚Äôannuler le t√©l√©chargement par manque de r√©seau. On ne va pas impl√©menter cette fonctionnalit√© aujourd‚Äôhui, mais √ßa serait une tr√®s bonne am√©lioration ! ‚Äé Aller plus loin avec la gestion des demandes d‚Äôannulation des op√©rations. Passons maintenant au t√©l√©chargement en lui-m√™me avec l‚Äôimpl√©mentation compl√®te de la m√©thode : Nom du fichier :MusicPlayerViewModel.cs #region Commands [RelayCommand] async Task DownloadCurrentTrack(CancellationToken cancellationToken) { // On l√®ve une exception quand l'annulation de l'op√©ration est demand√©e cancellationToken.ThrowIfCancellationRequested(); try { // On a besoin d'un client HTTP pour g√©rer nos requ√™tes sur le r√©seau HttpClient client = new HttpClient(); client.MaxResponseContentBufferSize = 100000000; // On peut t√©l√©charger jusqu'√† ~100Mo de donn√©es par fichier ! // On envoie une requ√™te HTTP vers le lien de t√©l√©chargement du morceau using var httpResponse = await client.GetAsync( new Uri(CurrentTrack.AudioDownloadURL), cancellationToken); httpResponse.EnsureSuccessStatusCode(); var downloadedImage = await httpResponse.Content.ReadAsStreamAsync(cancellationToken); try { string fileName = $\"{CurrentTrack.Title} - {CurrentTrack.Author}.mp3\"; // Puis on transf√®re les donn√©es r√©cup√©r√©es dans un fichier // Note : on a besoin de mettre √† jour CommunityToolkit.Maui au moins vers version 5.1.0 var fileSaveResult = await FileSaver.SaveAsync(fileName, downloadedImage, cancellationToken); fileSaveResult.EnsureSuccess(); await Toast.Make($\"File saved at: {fileSaveResult.FilePath}\").Show(cancellationToken); } catch (Exception ex) { await Toast.Make($\"Cannot save file because: {ex.Message}\").Show(cancellationToken); } } ca","date":"19/12/2023","objectID":"/posts/tutos/my-first-app/13-download-audio-file/:3:0","tags":["Data Binding","MediaElement","MVVM",".NET Community Toolkit"],"title":"T√©l√©charger un fichier audio en .NET MAUI","uri":"/posts/tutos/my-first-app/13-download-audio-file/"},{"categories":null,"content":"On va d√©sormais implementer le contr√¥le du volume ! Comme dans tout bon lecteur musical, on veut que notre utilisateur puisse monter ou baisser le niveau sonore √† sa guise.","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":" ‚Äé Afin d‚Äôassurer le bon d√©roulement de cet article, je t‚Äôinvite √† repartir depuis ce chapitre o√π l‚Äôon a configur√© le MediaElement. Dans l‚Äôarticle pr√©c√©dent, on avait vu comment d√©placer la t√™te de lecture avec notre propre contr√¥le de type Slider. Et je sais que c‚Äô√©tait un peu long ! Accroche-toi, on n‚Äôest plus tr√®s loin de la fin de ce cours üôÇ Nous allons donc voir aujourd‚Äôhui comment impl√©menter le contr√¥le du volume, lui aussi avec l‚Äôaide d‚Äôun Slider. Eh oui, comme dans tout bon lecteur musical, on veut que notre utilisateur puisse monter ou baisser le niveau sonore √† sa guise ! ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:0:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"D√©finir un niveau de volume Si tu te rappelles bien, dans le chapitre sur l‚Äôaffichage du volume, nous avions introduit 2 composants : le MuteButton, qui est un contr√¥le de type ImageButton pour couper le son, et le Slider VolumeTracker, pour contr√¥ler le volume sonore de mani√®re pr√©cise. Comme on a l‚Äôhabitude de le faire, rendons-les maintenant utilisables avec l‚Äôaide du Data Binding, et tout √ßa dans une m√©thode d‚Äôinitialisation nomm√©e InitVolumeTracker() : Nom du fichier :MusicPlayerView.cs // Comme toujours, chaque morceau de code a sa r√©gion ! #region Volume Tracker ... Slider VolumeTracker = new Slider { Minimum = 0, MinimumTrackColor = Colors.Black, Maximum = 100, MaximumTrackColor = Colors.Gray, // On n'a plus besoin de valeur factice, tu peux supprimer cette ligne // Value = 60 }; void InitVolumeTracker() // Et voici la nouvelle m√©thode d'initialisation { VolumeTracker.Bind( Slider.ValueProperty, nameof(MusicPlayer.Volume), source: MusicPlayer, convert: (double mediaElementVolume) =\u003e mediaElementVolume * 100, convertBack: (double sliderValue) =\u003e sliderValue / 100); } #endregion √áa va, pas de probl√®me jusqu‚Äôici ? Finalement, c‚Äôest tr√®s proche de ce qu‚Äôon a mis en place pour le contr√¥le de la t√™te de lecture ! ‚Äé üêí‚Äé ‚Äé Ah oui ! Mais euh‚Ä¶ c‚Äôest nouveau le convertBack ? H√©-h√©, rien ne t‚Äô√©chappe ! Concr√®tement, nous avons associ√© la position du curseur sur le Slider (VolumeTracker.Value) √† la valeur du volume qui est expos√© par le MediaElement (MusicPlayer.Volume). Et si tu as bien lu la documentation du Slider, il est dit que l‚Äôassociation de la propri√©t√© Value du Slider est bidirectionnelle (BindingMode.TwoWay), c‚Äôest-√†-dire que : Tout changement de valeur depuis le composant source (ici, le MusicPlayer) aura un impact sur le composant cible (c‚Äôest le VolumeTracker), Et inversement, toute nouvelle valeur depuis le composant cible (VolumeTracker) aura un impact sur le composant source (MusicPlayer) ! En d‚Äôautres mots, si le volume du MediaElement descendait √† 0, alors le curseur du Slider glisserait tout √† gauche, et si l‚Äôutilisateur d√©pla√ßait le curseur tout √† droite, alors le volume du MediaElement serait d√©fini √† 1. ‚Äé La propri√©t√© convert agit dans le sens ‚Äúsource ‚Üí cible‚Äù, alors que la propri√©t√© convertBack agit dans le sens contraire, ‚Äúcible ‚Üí source‚Äù. Seulement, il est pr√©cis√© dans la documentation du MediaElement que la propri√©t√© Volume n‚Äôaccepte que des valeurs de type double qui sont comprises entre 0 et 1. C‚Äôest pourquoi, lors du convert, nous devons multiplier par 100 la valeur du MusicPlayer.Volume pour d√©finir la position du curseur sur le Slider (VolumeTracker.Value). Et √† l‚Äôinverse dans le convertBack, on doit diviser par 100 la valeur choisie par l‚Äôutilisateur via le Slider pour modifier correctement la valeur du MediaElement. Enfin, tu n‚Äôas plus qu‚Äô√† appeler la m√©thode d‚Äôinitialisation InitVolumeTracker() depuis le constructeur de la page : Nom du fichier :MusicPlayerView.cs ... namespace NightClub.Views; public class MusicPlayerView : ContentPage { public MusicPlayerView() { ... InitVolumeTracker(); // Et voil√†, avec √ßa on est bons ! ... } ... } Allez, relance le projet et v√©rifie que tu peux modifier le volume ! ‚Äé üêí‚Äé ‚Äé D√©j√† !? H√©√©√© mais, et le MuteButton, qu‚Äôest-ce qu‚Äôon en fait ? Parfois, il suffit de peu de code pour d√©bloquer de nouvelles fonctionnalit√©s ! Profites-en pour v√©rifier que √ßa fonctionne bien, on se revoit juste apr√®s pour la suite ! ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:1:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"Couper le son Pour le MuteButton, c‚Äôest encore plus simple ! En effet, c‚Äôest d√©j√† pris en compte par le MediaElement avec la propri√©t√© ShouldMute de type boolean. Et donc, tout ce que nous avons √† faire, c‚Äôest d√©tecter le clic de l‚Äôutilisateur sur le bouton et modifier sa valeur. Pour cela, commen√ßons par d√©finir un nouvel √©v√®nement nomm√© MuteButton_Clicked()‚Ä¶ Nom du fichier :MusicPlayerView.cs #region Events ... void MuteButton_Clicked(object sender, EventArgs e) { MusicPlayer.ShouldMute = !MusicPlayer.ShouldMute; } #endregion ‚Ä¶ qui sera initialis√© depuis notre m√©thode existante, dans le InitMuteButton() : Nom du fichier :MusicPlayerView.cs #region Mute Button Visual States ... void InitMuteButton() { ... MuteButton.Clicked += MuteButton_Clicked; } #endregion Cet √©v√®nement est plut√¥t simple, non ? Il suffit d‚Äôinverser la valeur de la propri√©t√© MusicPlayer.ShouldMute pour alternativement couper ou remettre le son. Bon, mais c‚Äôest pas tout ! Car si jamais tu voulais essayer, voici ce que cela donne : Le bouton fonctionne bien ! Mais il y a quelque chose qui cloche visuellement. Le son est bien coup√© quand on clique une premi√®re fois sur le MuteButton, et il se r√©active au clic suivant. C‚Äôest pas mal du tout ! Cependant, quelque chose d√©range visuellement. √áa donne comme un effet bizarre quand le son est coup√© : L‚Äôic√¥ne du MuteButton aurait du changer pour repr√©senter le son coup√©, Et le curseur du VolumeTracker aurait du glisser tout √† gauche, pour la m√™me raison. En fait, il aurait fallu que ces deux contr√¥les s‚Äôadaptent au niveau de volume sonore‚Ä¶ Aurais-tu une id√©e ? üòä ‚Äé üêí‚Äé ‚Äé Eh bien, on doit modifier la valeur du volume nous-m√™mes, tout simplement ! H√© oui, c‚Äôest √ßa ! Mais as-tu pens√© √† ce qui se passerait quand l‚Äôutilisateur r√©activera le son ? L‚Äôid√©al serait que le volume sonore remonte au niveau o√π il √©tait avant d‚Äô√™tre coup√©. On va donc enregistrer le niveau du volume lorsque l‚Äôutilisateur clique sur le MuteButton ! Pour cela, on aura besoin √† nouveau d‚Äôune variable : Nom du fichier :MusicPlayerView.cs #region Properties bool mustResumePlayback; double savedVolumeBeforeGoingMute; // Une nouvelle variable de type double #endregion La variable savedVolumeBeforeGoingMute doit √™tre de type double pour correspondre √† la valeur contenue dans la propri√©t√© Volume du MediaElement. Et maintenant, tu n‚Äôas plus qu‚Äô√† modifier l‚Äô√©v√®nement MuteButton_Clicked() comme ceci : Nom du fichier :MusicPlayerView.cs #region Events ... void MuteButton_Clicked(object sender, EventArgs e) { if (!MusicPlayer.ShouldMute) { // On enregistre bien le volume actuel avant de couper le son... savedVolumeBeforeGoingMute = MusicPlayer.Volume; MusicPlayer.Volume = 0; } else { // ... et quand le son est r√©activ√©, on le r√©tablit comme avant ! MusicPlayer.Volume = savedVolumeBeforeGoingMute; } // Et bien s√ªr ici, √ßa ne change pas ! MusicPlayer.ShouldMute = !MusicPlayer.ShouldMute; } ... #endregion D√©sormais quand on d√©tecte que le son va √™tre d√©sactiv√©, on garde en m√©moire la valeur du volume sonore dans la variable savedVolumeBeforeGoingMute, puis on modifie nous-m√™mes la valeur de la propri√©t√© MusicPlayer.Volume √† 0. D‚Äôailleurs, je me suis demand√© pourquoi ce n‚Äô√©tait d√©j√† pas int√©gr√© dans la librairie .NET MAUI Community Toolkit. Et j‚Äôai donc pos√© la question sur Github directement √† l‚Äôauteur de la fonctionnalit√© ! C‚Äôest √ßa la magie de l‚ÄôOpen Source. ‚Äé En lisant la r√©ponse √† ma question, tu auras peut-√™tre compris qu‚Äôil existe une autre fa√ßon d‚Äôimpl√©menter la d√©sactivation du son. Partage-moi ton essai en commentaires ! Allez, voyons ce que √ßa donne avec ces derniers changements : Ah, eh bien l√† c‚Äôest plus clair quand on coupe le son ! Super ! Mais on doit parer tous les cas d‚Äôutilisation possibles et imaginables‚Ä¶ C‚Äôest ce que nous allons voir juste apr√®s. ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:2:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"Quelques optimisations On va en effet appliquer quelques am√©liorations, car il reste deux situations o√π le comportement de notre fonctionnalit√© est bancal. Par exemple, on a un premier cas o√π le curseur du volume reste bloqu√© tout √† gauche : On a beau cliquer sur le bouton pour r√©activer le son, rien ne se passe ! C‚Äôest compl√®tement normal ! Bien que le volume ait diminu√© jusqu‚Äô√† 0, la variable MusicPlayer.ShouldMute n‚Äôest finalement pas pass√©e √† true. Techniquement, l‚Äôutilisateur n‚Äôest donc pas en train de r√©activer le son ! ‚Äé Essaye de mettre des points de d√©boggage dans la m√©thode MuteButton_Clicked() ! Dans la deuxi√®me situation inattendue, le son ne se r√©active tout simplement pas : Apr√®s avoir coup√© le son, monter le volume ne change rien du tout ! Mais finalement, l√† aussi, rien d‚Äô√©trange. D‚Äôailleurs, la cause d‚Äôorigine est la m√™me que dans le cas pr√©c√©dent ! En effet, m√™me si le volume a augment√©, la variable MusicPlayer.ShouldMute n‚Äôest jamais pass√©e √† false. Rebelotte donc, l‚Äôutilisateur n‚Äôest pas en train de r√©activer le son ! ‚Äé üêí‚Äé ‚Äé Mais du coup, tout ce qu‚Äôon a fait est faux ? Non, pas du tout ! Il y a √©videmment des dizaines d‚Äôautres fa√ßons d‚Äôimpl√©menter tout √ßa (et libre √† toi d‚Äôessayer !), mais dans notre cas, il nous reste juste une petite partie √† coder. Mais alors, que manque-t‚Äôil d‚Äôapr√®s toi ? Un indice : tout commence par le changement de valeur du volume. Et √ßa, ce n‚Äôest possible qu‚Äôavec le d√©placement du curseur sur le Slider‚Ä¶ Alors, on va optimiser le comportement actuel avec un nouvel √©v√®nement nomm√© VolumeTracker_DragCompleted() : Nom du fichier :MusicPlayerView.cs #region Events ... void VolumeTracker_DragCompleted(object sender, EventArgs e) { // Il est recommand√© de toujours se r√©f√©rer √† l'objet qui est // la source de l'√©v√®nement √† travers le param√®tre \"sender\" if (sender is Slider volumeTrackerControl) { if (volumeTrackerControl.Value == 0) { // Le volume sonore doit toujours √™tre suffisamment // √©lev√© quand le son est r√©activ√© savedVolumeBeforeGoingMute = 0.2; MusicPlayer.ShouldMute = true; } else if(MusicPlayer.ShouldMute) { // On doit r√©activer le son quand le curseur // d√©finit une valeur strictement positive MusicPlayer.ShouldMute = false; } } } #endregion Et bien s√ªr, on n‚Äôoublie pas d‚Äôinitialiser cet √©v√®nement depuis la bonne m√©thode‚Ä¶ Nom du fichier :MusicPlayerView.cs #region Volume Tracker ... void InitVolumeTracker() { VolumeTracker.DragCompleted += VolumeTracker_DragCompleted; ... } #endregion Relance le projet, v√©rifie que tout fonctionne, et surtout, profite du r√©sultat de tes efforts ! J‚Äôesp√®re que tu auras appris plein de nouvelles choses aujourd‚Äôhui. De mani√®re g√©n√©rale, inspire-toi de ce que tu observes pour exp√©rimenter de nouvelles choses. Et en allant un peu plus loin √† chaque fois, tu deviendras de plus en plus √† l‚Äôaise ! Allez, on se revoit tr√®s vite pour un nouveau chapitre ! üôÇ Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"10/12/2023","objectID":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/:3:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler le volume avec MediaElement","uri":"/posts/tutos/my-first-app/12-control-volume-with-mediaelement/"},{"categories":null,"content":"Continuons sur notre lanc√©e avec l‚Äôimpl√©mentation du contr√¥le de la t√™te de lecture ! L‚Äôid√©e est de pouvoir se d√©placer √† un endroit pr√©cis du morceau.","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler la t√™te de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":" ‚Äé Afin d‚Äôassurer le bon d√©roulement de cet article, je t‚Äôinvite √† repartir depuis ce chapitre o√π l‚Äôon a configur√© le MediaElement. Dans l‚Äôarticle pr√©c√©dent, on avait d√©couvert le MediaElement pour lire des fichiers audio, mais avec l‚Äôaide de nos propres contr√¥les. Tu te rappelles des Sliders qu‚Äôon avait mis en place ? Ils sont cools mais ils ne servent √† rien ! üòÑ Alors aujourd‚Äôhui, nous allons commencer par impl√©menter le contr√¥le de la t√™te de lecture, pour permettre √† l‚Äôutilisateur de se d√©placer √† un endroit pr√©cis du morceau. ","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/:0:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler la t√™te de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":"Binding des composants Si tu te rappelles bien, dans le chapitre sur l‚Äôaffichage du temps d‚Äô√©coute, nous avions introduit 3 composants : ElapsedTime qui est un Label pour afficher le temps √©coul√© de lecture, TotalTime qui est aussi un Label, mais pour afficher la dur√©e totale de la piste audio, et enfin le Slider TimeTracker, pour contr√¥ler la t√™te de lecture de la piste. Adieu les donn√©es factices ! Nous allons d√©sormais donner vie √† ces composants avec l‚Äôaide du Data Binding. Et on isolera tout √ßa dans une m√©thode d‚Äôinitialisation InitTimeTracker() : Nom du fichier :MusicPlayerView.cs #region Time Tracker // Rep√®re bien la r√©gion pour ajouter le nouveau code ... void InitTimeTracker() // Voici la nouvelle m√©thode d'initialisation { TimeTracker.Bind( Slider.ValueProperty, nameof(MusicPlayer.Position), source: MusicPlayer, convert: (TimeSpan currentPosition) =\u003e currentPosition.TotalSeconds); TimeTracker.Bind( Slider.MaximumProperty, nameof(MusicPlayer.Duration), source: MusicPlayer, convert: (TimeSpan duration) =\u003e duration.TotalSeconds); ElapsedTime.Bind( Label.TextProperty, nameof(MusicPlayer.Position), source: MusicPlayer, stringFormat: \"{0:mm\\\\:ss}\"); TotalTime.Bind( Label.TextProperty, nameof(MusicPlayer.Duration), source: MusicPlayer, stringFormat: \"{0:mm\\\\:ss}\"); } #endregion Oui je sais c‚Äôest un peu dense, courage ! Tout est d√©taill√© juste apr√®s. Pour commencer, nous avons modifi√© le comportement du TimeTracker pour lui associer deux propri√©t√©s : la position actuelle du curseur sur le Slider, et la valeur maximale du curseur (quand il est positionn√© tout √† droite). Int√©ressons-nous maintenant d‚Äôun peu plus pr√®s au MediaElement incarn√© par notre composant MusicPlayer. Celui-ci expose justement ce qu‚Äôil nous faut : la position de la t√™te de lecture en temps r√©el (MusicPlayer.Position), √† associer √† la position du curseur sur le Slider (TimeTracker.Value), et la dur√©e totale du morceau (MusicPlayer.Duration), √† associer √† la valeur maximale du Slider (TimeTracker.Maximum). Enfin, si tu te rappelles bien, le Slider ne peut consid√©rer que des valeurs de type double. C‚Äôest pourquoi nous avons besoin de convertir les valeurs obtenues avec MusicPlayer.Position et MusicPlayer.Duration, depuis le type TimeSpan vers le type double, avec la propri√©t√© TotalSeconds. ‚Äé üêí‚Äé ‚Äé Et du coup, l‚Äôutilisateur pourra avancer ou reculer la lecture du morceau √† la seconde pr√®s ! Tout juste ! üôÇ Voyons maintenant pour les Labels. Pour le composant ElapsedTime, on veut qu‚Äôil affiche depuis combien de temps le morceau est jou√© en se basant lui aussi sur la propri√©t√© MusicPlayer.Position. Seulement, on ne veut pas afficher n‚Äôimporte quoi ! On veut en effet afficher une dur√©e en minutes et en secondes. Pour cela, on a besoin de lui appliquer le format de texte souhait√© avec l‚Äôaide du code : {0:mm\\\\:ss}. Pour le composant TotalTime, on veut afficher le temps total d‚Äô√©coute du morceau en se basant sur la propri√©t√© MusicPlayer.Duration. Et de la m√™me fa√ßon, on applique le m√™me format de texte pour afficher une dur√©e en minutes et en secondes. ‚Äé Pour plus d‚Äôinformation, voir le StringFormat. Au fait, n‚Äôoublie pas de remplacer le signe ‚Äú=\u003e‚Äù par ‚Äú=‚Äù √† la d√©claration de chacun de ces composants ! Sinon √ßa ne marchera pas puisque le m√™me objet sera retourn√© √† chaque appel √† ces variables. On peut d‚Äôailleurs en profiter aussi pour retirer les valeurs factices qu‚Äôon avait d√©finies par d√©faut pour certaines propri√©t√©s : Text pour les Labels, Maximum et Value pour le Slider. Et voici donc la d√©claration actualis√©e pour ces 3 composants : Nom du fichier :MusicPlayerView.cs #region Time Tracker Label ElapsedTime = new Label // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù { FontSize = 14, TextColor = Colors.White }.TextCenter(); Slider TimeTracker = new Slider // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù { Minimum = 0, MinimumTrackColor = Colors.LightSalmon, MaximumTrackColor = Colors.Black }; Label TotalTime = new Label // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù { FontSize = 14, Tex","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/:1:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler la t√™te de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":"Contr√¥ler la t√™te de lecture Pour contr√¥ler la t√™te de lecture, l‚Äôutilisateur doit simplement glisser le curseur du Slider d‚Äôun point A √† un point B. En d√©composant un peu plus son geste, on pourrait dire que : L‚Äôutilisateur doit d‚Äôabord poser le doigt sur le curseur √† un point A du Slider, Puis il d√©placera ce curseur en maintenant son doigt appuy√© dessus, Et enfin, il le rel√¢chera √† un point B du Slider en levant son doigt de l‚Äô√©cran. En lisant cette description, est-ce que √ßa t‚Äôa mis la puce √† l‚Äôoreille ? ‚Äé üêí‚Äé ‚Äé Je me rappelle qu‚Äôon avait mis en place des events pour d√©tecter les gestes de l‚Äôutilisateur‚Ä¶ c‚Äôest √ßa ? Oui, bravo ! On aura ici besoin de deux √©v√®nements du Slider pour : D√©tecter le moment o√π l‚Äôutilisateur commence √† d√©placer le curseur, Et d√©tecter quand il le rel√¢che. Rattachons ces deux √©v√®nements √† notre TimeTracker depuis la m√©thode InitTimeTracker() : Nom du fichier :MusicPlayerView.cs void InitTimeTracker() { ... TimeTracker.DragStarted += TimeTracker_DragStarted; TimeTracker.DragCompleted += TimeTracker_DragCompleted; } ‚Äé On aurait pu tout aussi bien utiliser les commandes fournies par le Slider et travailler depuis le ViewModel, mais on avait d√©j√† expliqu√© ici qu‚Äôil √©tait pr√©f√©rable de garder la logique dans la View du fait que le MediaElement est un composant purement UI. Maintenant, d√©finis ces nouveaux √©v√®nements dans la r√©gion des Events avec le code suivant : Nom du fichier :MusicPlayerView.cs #region Events ... void TimeTracker_DragStarted(object sender, EventArgs e) { if (MusicPlayer.CurrentState == MediaElementState.Playing) { mustResumePlayback = true; MusicPlayer.Pause(); } } void TimeTracker_DragCompleted(object sender, EventArgs e) { // Il est recommand√© de toujours se r√©f√©rer √† l'objet qui est // la source de l'√©v√®nement √† travers le param√®tre \"sender\" if (sender is Slider timeTrackerControl) { // On met √† jour la position selon l'endroit o√π l'utilisateur // a arr√™t√© son doigt MusicPlayer.SeekTo(TimeSpan.FromSeconds(timeTrackerControl.Value)); if (mustResumePlayback) { // La musique reprend si elle √©tait jou√©e avant que // l'utilisateur d√©place le curseur MusicPlayer.Play(); mustResumePlayback = false; } } } #endregion Le premier √©v√®nement TimeTracker_DragStarted() correspond au moment o√π l‚Äôutilisateur commence √† d√©placer le curseur sur le Slider. Quand cela se produit, la lecture du morceau est mise en pause pour ne pas que la musique continue de jouer. Et d‚Äôailleurs, le curseur continuerait de se d√©placer tout seul ! Bien s√ªr, pour que l‚Äôexp√©rience utilisateur soit bonne, il faut que la lecture du morceau reprenne aussit√¥t que l‚Äôutilisateur a termin√© son mouvement. Pour cela, nous devons garder en m√©moire le fait de devoir reprendre la lecture avec l‚Äôaide de la variable mustResumePlayback. ‚Äé üêí‚Äé ‚Äé Mais d‚Äôo√π elle sort cette variable ? Jamais vue ! üòÑ C‚Äôest normal, on va l‚Äôajouter tout de suite ! Nous avons une nouvelle r√©gion d√©di√©e en haut de la classe : Nom du fichier :MusicPlayerView.cs #region Properties bool mustResumePlayback; #endregion Pour le second √©v√®nement TimeTracker_DragCompleted(), c‚Äôest le moment o√π l‚Äôutilisateur a fini de d√©placer le curseur sur le Slider. Quand cela arrive, on rep√®re la position du curseur pour alors r√©ajuster la t√™te de lecture du MusicPlayer conform√©ment. Pour cela, on a recours √† la m√©thode SeekTo() expos√©e par la classe du MediaElement, avec un temps de r√©f√©rence pour param√®tre (au format TimeSpan). ‚Äé Cela aura un effet imm√©diat sur la valeur sur la propri√©t√© MusicPlayer.Position. Enfin, la lecture du morceau reprendra aussit√¥t apr√®s, √† partir de la nouvelle position choisie. Relance le projet et v√©rifie que tu peux avancer ou reculer dans le morceau ! Et hop, je reviens au tout d√©but du morceau ! Tu viens de terminer l‚Äôimpl√©mentation d‚Äôune belle fonctionnalit√© pour l‚Äôutilisateur, bravo ! La prochaine fois, nous verrons comment impl√©menter la gestion du volume. √Ä tr√®s vite ! Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installat","date":"01/12/2023","objectID":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/:2:0","tags":["MVVM","Data Binding","MediaElement","Slider"],"title":"Contr√¥ler la t√™te de lecture avec MediaElement","uri":"/posts/tutos/my-first-app/11-control-playback-position-with-mediaelement/"},{"categories":null,"content":"Notre application prend forme ! Mais ce n‚Äôest que visuel pour le moment‚Ä¶ Dans ce chapitre, on va d√©couvrir comment jouer de la musique depuis l‚Äôapplication !","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"√âcouter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":" ‚Äé Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú4 - All Media Controls‚Äù. Avant d‚Äôentamer ce nouveau chapitre, je voulais te f√©liciter pour tout ce chemin parcouru ! Maintenant qu‚Äôon a bien avanc√© sur la partie visuelle, on va pouvoir d√©velopper le c≈ìur de l‚Äôapplication et ainsi la rendre un peu plus fonctionnelle. Et s‚Äôil y a bien une fonctionnalit√© √† impl√©menter en priorit√©, c‚Äôest la lecture de titres musicaux ! ","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:0:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"√âcouter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Le MediaElement Dans l‚Äôunivers du mobile, la manipulation des m√©dias est compl√®tement diff√©rente d‚Äôun syst√®me √† un autre. Heureusement, Microsoft nous simplifie la vie avec son Community Toolkit qui propose justement de quoi lire des fichiers audio depuis n‚Äôimporte quelle plateforme: le MediaElement ! D‚Äôapr√®s la documentation, ce composant est fourni dans un paquet NuGet qui lui est d√©di√©. Pour installer cette d√©pendance, ouvre le gestionnaire de paquets NuGet et recherche la librairie nomm√©e CommunityToolkit.Maui.MediaElement. Une fois trouv√©e, ajoute la version la plus r√©cente au projet et accepte toutes les licences associ√©es : ‚Äé Un fichier ReadMe.txt s‚Äôouvre automatiquement dans Visual Studio. Il donne des indications suppl√©mentaires que nous allons appliquer pour utiliser le MediaElement. Maintenant que la librairie est ajout√©e au projet, il reste une derni√®re √©tape pour utiliser le composant MediaElement. En effet, il est n√©cessaire de l‚Äôinitialiser au d√©marrage de l‚Äôapplication dans le fichier MauiProgram.cs. Ouvre donc ce fichier et modifie la m√©thode CreateMauiApp() de la fa√ßon suivante : Nom du fichier :MauiProgram.cs public static MauiApp CreateMauiApp() { Console.WriteLine(\"[NightClub] MauiProgram - CreateMauiApp\"); var builder = MauiApp.CreateBuilder() .UseMauiCommunityToolkit() .UseMauiCommunityToolkitMarkup() // Tu dois ajouter la ligne ci-dessous: .UseMauiCommunityToolkitMediaElement() .UseMauiApp\u003cApp\u003e(); return builder.Build(); } ‚Äé üêí‚Äé ‚Äé Ok, mais qu‚Äôest-ce qu‚Äôelle fait exactement cette m√©thode UseMauiCommunityToolkitMediaElement() ? Bon r√©flexe ! Quand on manipule des nouveaux bouts de code, c‚Äôest toujours mieux de comprendre ce qu‚Äôils d√©clenchent derri√®re. Et dans le cas pr√©sent, le code est open-source et peut √™tre consult√© ici. Sans grande surprise, la m√©thode UseMauiCommunityToolkitMediaElement() n‚Äôa pour but que de mettre √† disposition le fameux MediaElement pour notre application. Dans les grandes lignes, cela consiste √† pr√©ciser quelles classes impl√©mentent son comportement, pour chacune des plateformes cibl√©es. ‚Äé Pour plus d‚Äôinformation, consulte la documentation sur les contr√¥les personnalis√©s. √áa y‚Äôest, on va pouvoir √©couter de la musique ! ","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:1:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"√âcouter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Faites du bruit ! Voyons d√©sormais comment d√©finir une instance du MediaElement dans la vue MusicPlayerView. ‚Äé üêí‚Äé ‚Äé Mais finalement, est-ce qu‚Äôon ne devrait pas consid√©rer le MediaElement comme un service et l‚Äôajouter au ViewModel ? C‚Äôest une tr√®s bonne remarque ! En effet, dans le chapitre sur le MVVM, on a pr√©sent√© la View comme la couche correspondant √† l‚Äôinterface utilisateur. En toute logique, on pourrait donc penser que la lecture de m√©dias intervient uniquement dans le ViewModel ! Seulement, apr√®s avoir lu la documentation, tu constateras que le MediaElement fournit les contr√¥les visuels de base pour manipuler des m√©dias selon la plateforme cible. Et m√™me si nous ne les utiliserons pas (puisque nous cr√©ons nos propres contr√¥les), le MediaElement est bien un √©l√©ment de l‚Äôinterface utilisateur ! Et c‚Äôest pour respecter le d√©coupage du MVVM que je pr√©f√®re d√©finir une instance du MediaElement dans la vue MusicPlayerView. ‚Äé Il est tout √† fait possible d‚Äôaccomplir la m√™me chose en pla√ßant le MediaElement dans le ViewModel au lieu de la View, mais il y a des chances que cela complexifie la maintenance du projet. Ouvre donc le fichier MusicPlayerView.cs, puis d√©finis une nouvelle propri√©t√© de type MediaElement dans la region d√©di√©e aux contr√¥les, ainsi qu‚Äôune m√©thode InitMusicPlayer() pour l‚Äôinitialiser : Nom du fichier :MusicPlayerView.cs #region Controls ... #region MusicPlayer // Et pourquoi pas une nouvelle r√©gion ! MediaElement MusicPlayer = new MediaElement(); void InitMusicPlayer() { MusicPlayer.ShouldAutoPlay = true; string trackURL = \"https://prod-1.storage.jamendo.com/?trackid=1890762\u0026format=mp31\u0026from=b5bSbOTAT1kXawaT8EV9IA%3D%3D%7CGcDX%2BeejT3P%2F0CfPwtSyYA%3D%3D\"; MusicPlayer.Source = MediaSource.FromUri(trackURL); } #endregion ... #endregion Avec le param√®tre ShouldAutoPlay, on configure notre nouveau contr√¥le pour automatiquement jouer le prochain titre, aussit√¥t qu‚Äôil est d√©fini. En effet, nos boutons sont toujours factices, or on a besoin d‚Äôentendre de la musique pour v√©rifier que le MediaElement fonctionne ! ‚Äé üêí‚Äé ‚Äé Et la musique en question, c‚Äôest du streaming audio ? Oui c‚Äôest √ßa ! Pour notre application, j‚Äôai r√©cup√©r√© quelques chansons depuis Jamendo, un site Web gratuit de musique produite par des artistes ind√©pendants. Comme tu as du le remarquer, nous avons donc d√©fini un morceau √† jouer par d√©faut √† travers la variable trackURL. En effet, cette URL est alors d√©clar√©e comme une Source de m√©dia pour le MediaElement, avec l‚Äôaide de la m√©thode MediaSource.FromUri(). Retournons maintenant au constructeur de notre page. Dans un premier temps, nous devons initialiser le MediaPlayer avec la m√©thode InitMusicPlayer() que l‚Äôon vient de pr√©senter. Enfin, nous devons √©galement rajouter ce composant en tant qu‚Äô√©l√©ment de la vue pour le rendre disponible. Autrement, il ne serait pas d√©tect√© par la page et ne pourrait pas fonctionner ! Voici donc √† quoi ressemble d√©sormais le constructeur de la vue MusicPlayerView : Nom du fichier :MusicPlayerView.cs using CommunityToolkit.Maui.Views; // Attention √† bien ajouter ce using ! ... namespace NightClub.Views; public class MusicPlayerView : ContentPage { public MusicPlayerView() { Console.WriteLine(\"[NightClub] MusicPlayerView - Constructor\"); NavigationPage.SetHasNavigationBar(this, false); BackgroundColor = Colors.DimGray; InitMusicPlayer(); // On initialise le contr√¥le avec sa m√©thode d√©di√©e InitMuteButton(); Content = new Grid { RowDefinitions = Rows.Define( Stars(60), Stars(40)), RowSpacing = 0, Children = { MusicPlayer, // Et on ajoute le contr√¥le au contenu de la page ! TopLayout.Row(0), BottomLayout.Row(1) } }; } ... } ‚Äé Il n‚Äôest pas n√©cessaire de pr√©ciser o√π l‚Äô√©l√©ment sera d√©fini dans la grille. En effet, le MusicPlayer restera de toute mani√®re invisible pour l‚Äôutilisateur ! Et si on faisait un essai ? Prends d‚Äôabord le temps de r√©gler le volume de ton appareil de sorte √† ce que cela ne soit ni trop fort, ni trop faible. Puis, relance le projet pour d√©marrer l‚Äôapplica","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:2:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"√âcouter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Contr√¥ler la lecture du m√©dia Maintenant qu‚Äôon a v√©rifi√© que la lecture de m√©dia fonctionnait, ce serait mieux de pouvoir la contr√¥ler directement avec le bouton ‚ÄúPlay‚Äù ! Suivant le m√™me principe que tout √† l‚Äôheure, initialisons le contr√¥le PlayButton via une nouvelle m√©thode InitMediaControlPanel(), appel√©e depuis le constructeur de la page. Voici les modifications apport√©es √† la vue MusicPlayerView : Nom du fichier :MusicPlayerView.cs public class MusicPlayerView : ContentPage { public MusicPlayerView() { ... InitMusicPlayer(); InitMediaControlPanel(); // Une nouvelle m√©thode d'initialisation ... InitMuteButton(); ... } ... #region Media Control Panel ... // Le signe ‚Äú=\u003e‚Äù a √©t√© remplac√© par ‚Äú=‚Äù ImageButton PlayButton = new ImageButton { CornerRadius = 50, HeightRequest = 100, WidthRequest = 100, BackgroundColor = Colors.Black, Source = \"play.png\" }; void InitMediaControlPanel() // ... dont voici la d√©finition ! { PlayButton.Bind( targetProperty: ImageButton.SourceProperty, source: MusicPlayer, path: nameof(MusicPlayer.CurrentState), convert: (MediaElementState currentState) =\u003e currentState != MediaElementState.Playing ? \"play.png\" : \"pause.png\"); PlayButton.Clicked += PlayButton_Clicked; } ... #endregion } Dans un premier temps, on souhaite que l‚Äôic√¥ne associ√©e √† notre bouton central change d‚Äôapparence selon si la chanson est en train d‚Äô√™tre jou√©e (image: pause.png) ou pas (image: play.png). Pour cela, on applique la technique du Binding (cf: MVVM) sur la propri√©t√© Source du PlayButton qui n‚Äôest autre que la propri√©t√© pour d√©finir l‚Äôic√¥ne du bouton. Voici donc la logique mise en place pour en modifier la valeur automatiquement : On surveille les changements de valeur de la propri√©t√© CurrentState rattach√©e √† l‚Äôobjet MusicPlayer, Et on modifie l‚Äôimage du PlayButton selon si la valeur du CurrentState √©quivaut √† l‚Äô√©tat de lecture ou l‚Äô√©tat de pause. ‚Äé Attention √† bien remplacer le signe ‚Äú=\u003e‚Äù par ‚Äú=‚Äù √† la d√©claration du PlayButton. En effet, on ne veut cr√©er qu‚Äôune seule instance d‚ÄôImageButton et la modifier dans la m√©thode InitMediaControlPanel(). Ensuite, on d√©finit un comportement sp√©cifique au clic de l‚Äôutilisateur sur le PlayButton avec la m√©thode PlayButton_Clicked(). Voici √† quoi correspond cette m√©thode : Nom du fichier :MusicPlayerView.cs public class MusicPlayerView : ContentPage { ... #region Events // Quand on aime l'organisation, on utilise les r√©gions ! protected override void OnAppearing()... protected override void OnDisappearing()... void PlayButton_Clicked(object sender, EventArgs e) { if (MusicPlayer.CurrentState != MediaElementState.Playing) { MusicPlayer.Play(); } else { MusicPlayer.Pause(); } } #endregion } Comme tu peux le voir, cet √©v√©nement est plut√¥t simple. √Ä chaque clic, on d√©tecte quel est l‚Äô√©tat actuel du lecteur de musique, et selon, on demande la mise en lecture ou la mise en pause du morceau. Voil√†, c‚Äôest tout pour ce chapitre. Recompile le projet et mets en pause la musique ! Le morceau est jou√© d√®s que la page du lecteur de musique appara√Æt, puis on peut stopper la lecture avec le bouton pause. Quel plaisir de pouvoir interagir avec notre app, n‚Äôest-ce pas ? Personnellement, c‚Äôest la partie que je pr√©f√®re dans le d√©veloppement d‚Äôune application ! √áa se concr√©tise et ce n‚Äôest que le d√©but. La prochaine fois, on verra comment impl√©menter la gestion du volume et de la t√™te de lecture. Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des anima","date":"18/09/2023","objectID":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/:3:0","tags":["MediaElement",".NET Community Toolkit","MVVM","Data Binding","ImageButton"],"title":"√âcouter de la musique en .NET MAUI avec MediaElement","uri":"/posts/tutos/my-first-app/10-play-music-with-mediaelement/"},{"categories":null,"content":"Pour valider les nouvelles fonctionnalit√©s d‚Äôune application, il vaut mieux les tester dans un environnement isol√©. En effet, tu ne voudrais pas risquer les donn√©es de tes utilisateurs ! D√©couvre alors comment configurer diff√©rents environnements pour ton application mobile.","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Que ce soit pour le d√©veloppement d‚Äôapplications mobiles, de logiciels ou de sites Web, il est courant de mettre en place plusieurs environnements pour son projet. En effet, cela facilite le test de nouvelles fonctionnalit√©s sans risquer d‚Äôimpacter les donn√©es de nos utilisateurs. Dans le cadre de cet article, nous verrons comment une application .NET MAUI peut cibler diff√©rents environnements, gr√¢ce √† plusieurs configurations de projet. ‚Äé Pour simplifier la lecture de cet article, nous nous concentrerons uniquement sur les plateformes iOS \u0026 Android. Cependant, le proc√©d√© est similaire pour les autres plateformes. ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:0:0","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Identifier toutes les configurations n√©cessaires au projet Dans un premier temps, tu dois d√©terminer combien de configurations diff√©rentes tu as besoin selon le nombre d‚Äôenvironnements cr√©√©s pour ton projet. Cependant, si tu n‚Äôes qu‚Äôau d√©but de ton projet, tu ne disposes peut-√™tre que d‚Äôun environnement de d√©veloppement. Voici donc quelques pistes de r√©flexion pour t‚Äôaider : Es-tu seul¬∑e √† d√©velopper cette application ? Y-a-t‚Äôil des testeurs dans ton √©quipe ? Ton projet est-il soumis √† des crit√®res de s√©curit√© ou de performance ? Est-ce que tu dois l‚Äôexposer au client avant sa publication ? ‚Äé Par d√©faut, il est important d‚Äôisoler l‚Äôenvironnement de production de ton environnement de d√©veloppement. Pour notre d√©monstration, nous nous r√©f√©rerons aux 3 environnements suivants : une configuration ‚ÄúDEV‚Äù pour travailler de mani√®re totalement isol√©e sur sa machine (i.e. ‚Äúen local‚Äù) et ne pas impacter l‚Äôactivit√© des autres d√©veloppeurs de son √©quipe, une configuration ‚ÄúTEST‚Äù pour faire valider tous les d√©veloppements avant leur publication, et une configuration ‚ÄúPROD‚Äù qui repr√©sente l‚Äô√©tat final de l‚Äôapplication, une fois disponible sur les stores. Allez, il est temps de passer √† la pratique ! Dans la prochaine section, nous allons cr√©er ces 3 configurations pour ex√©cuter notre application mobile dans 3 environnements distincts. ‚Äé Je t‚Äôinvite √† sauter la partie suivante dans le cas o√π tu aurais d√©j√† d√©fini toutes les configurations n√©cessaires √† ton projet dans Visual Studio. ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:1:0","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Cr√©er les diff√©rentes configurations du projet dans Visual Studio Maintenant que nous avons identifi√© tous les environnements cibl√©s, voyons comment cr√©er les diff√©rentes configurations pour notre application. Commence par ouvrir le fichier de configuration du projet dans Visual Studio. Comment acc√©der au fichier de configuration du projet ? Il est possible d‚Äôacc√©der au fichier de configuration √† l‚Äôaide d‚Äôun clic droit sur le projet dans Visual Studio. Le fichier de configuration d‚Äôun projet se termine par l‚Äôextension .csproj et peut √™tre √©dit√© par n‚Äôimporte quel √©diteur de texte (e.g. Visual Studio Code). On le retrouve g√©n√©ralement via l‚Äôexplorateur de fichiers √† la racine du projet. Une fois le fichier .csproj ouvert, ajoute √† la fin du fichier le code suivant : Nom du fichier :MultiEnvMauiApp.csproj \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e ... \u003cPropertyGroup\u003e \u003cConfigurations\u003eDEV;TEST;PROD\u003c/Configurations\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e Nous venons d‚Äôajouter un param√®tre qui, comme son nom l‚Äôindique, d√©finit les 3 nouvelles configurations possibles du projet : ‚ÄúDEV‚Äù, ‚ÄúTEST‚Äù et ‚ÄúPROD‚Äù. Nous pouvons alors personnaliser la configuration du projet pour chacun des environnements cibl√©s. Pour cela, rajoute le code suivant √† la fin du fichier .csproj : Nom du fichier :MultiEnvMauiApp.csproj \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e ... \u003cPropertyGroup Condition=\" '$(Configuration)' == 'DEV' \"\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'TEST' \"\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'PROD' \"\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e Comme tu l‚Äôauras remarqu√©, nous avons ajout√© une condition d‚Äôex√©cution √† chacun de ces nouveaux groupes de propri√©t√©s. De cette fa√ßon, Visual Studio pourra appliquer la bonne configuration selon l‚Äôenvironnement cibl√©. Voyons maintenant pour ce qui est du contenu en lui-m√™me (√† adapter selon tes besoins) : Nom du fichier :MultiEnvMauiApp.csproj \u003cPropertyGroup Condition=\" '$(Configuration)' == 'DEV' \"\u003e \u003cDebugSymbols\u003etrue\u003c/DebugSymbols\u003e \u003cOptimize\u003efalse\u003c/Optimize\u003e \u003cMtouchDebug\u003etrue\u003c/MtouchDebug\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'TEST' \"\u003e \u003cDebugSymbols\u003efalse\u003c/DebugSymbols\u003e \u003cOptimize\u003etrue\u003c/Optimize\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'PROD' \"\u003e \u003cDebugSymbols\u003efalse\u003c/DebugSymbols\u003e \u003cOptimize\u003etrue\u003c/Optimize\u003e \u003c/PropertyGroup\u003e Dans notre cas, on veut pouvoir d√©bogguer l‚Äôapplication quand elle tourne en ‚ÄúDEV‚Äù, mais pas quand elle tourne en ‚ÄúTEST‚Äù ou en ‚ÄúPROD‚Äù. On a donc recours au param√®tre DebugSymbols pour activer le d√©boggage de l‚Äôapplication, tandis que le param√®tre Optimize permet d‚Äôoptimiser les performances de l‚Äôapp et son poids. ‚Äé En raison d‚Äôun probl√®me connu des √©quipes de Visual Studio, au moment de l‚Äô√©criture de cet article, il est n√©cessaire d‚Äôappliquer \u003cMtouchDebug\u003etrue\u003c/MtouchDebug\u003e pour chaque configuration de d√©boggage. Voil√†, on en a fini avec le fichier .csproj ! Mais apr√®s avoir sauvegard√© ce fichier, il est fort possible que Visual Studio affiche une petite ic√¥ne rouge. Heureusement, c‚Äôest tout √† fait normal ! Visual Studio est rarement content qu‚Äôon bidouille les r√©glages du projet sans passer par son interface graphique. Le message indique qu‚Äôil y a un probl√®me d‚Äôassociation des configurations. En effet, Visual Studio ne sait pas encore quoi faire de nos configurations ‚ÄúDEV‚Äù, ‚ÄúTEST‚Äù et ‚ÄúPROD‚Äù. Il nous faut donc aller un peu plus loin en d√©finissant leur comportement au niveau de la solution. Pour Visual Studio, une solution est comme un espace de travail : elle peut contenir plusieurs projets en m√™me temps. Or il est possible de g√©rer des configurations pour la solution, comme pour les projets ! Et pour que cela fonctionne, chaque configuration de la solution doit √™tre associ√©e √† une configuration de chaque projet pr√©sent dans l‚Äôespace de travail. Tu vas vite comprendre. Commence par ouvrir les param√®tres de la solution dans Visual Studio. Comment acc√©der aux param√®tres de la solution ? On peut √©galement acc√©der","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:2:0","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"D√©finir un nom d‚Äôapplication pour chaque environnement cibl√© Maintenant que les configurations de ton projet sont pr√™tes, nous allons donner un nom d‚Äôapplication sp√©cifique pour chacun des environnements cibl√©s, afin d‚Äô√©viter toute confusion entre l‚Äôapplication de d√©veloppement et celle de production. Le nom de l‚Äôapplication peut √™tre modifi√© via le fichier de configuration du projet. Par d√©faut, tu y verras normalement un titre et un identifiant d‚Äôapplication d√©j√† d√©finis pour chaque nouveau projet .NET MAUI : Nom du fichier :MultiEnvMauiApp.csproj \u003cPropertyGroup\u003e ... \u003c!-- Display name --\u003e \u003cApplicationTitle\u003eMy App\u003c/ApplicationTitle\u003e \u003c!-- App Identifier --\u003e \u003cApplicationId\u003ecom.companyname.multienvmauiapp\u003c/ApplicationId\u003e ... \u003c/PropertyGroup\u003e Dans l‚Äôexemple ci-dessus, ‚ÄùMy App‚Äù correspond au nom de base de l‚Äôapplication, et notre but est de le personnaliser pour chacune des configurations du projet. Dans notre cas, nous allons inclure la d√©nomination de l‚Äôenvironnement cibl√© dans le titre et dans l‚Äôidentifiant d‚Äôapplication : Nom du fichier :MultiEnvMauiApp.csproj \u003cPropertyGroup Condition=\" '$(Configuration)' == 'DEV' \"\u003e ... \u003c!-- Display name (Overridden) --\u003e \u003cApplicationTitle\u003e(DEV) My App\u003c/ApplicationTitle\u003e \u003c!-- App Identifier (Overridden) --\u003e \u003cApplicationId\u003ecom.companyname.multienvmauiapp.dev\u003c/ApplicationId\u003e ... \u003c/PropertyGroup\u003e \u003cPropertyGroup Condition=\" '$(Configuration)' == 'TEST' \"\u003e ... \u003c!-- Display name (Overridden) --\u003e \u003cApplicationTitle\u003e(TEST) My App\u003c/ApplicationTitle\u003e \u003c!-- App Identifier (Overridden) --\u003e \u003cApplicationId\u003ecom.companyname.multienvmauiapp.test\u003c/ApplicationId\u003e ... \u003c/PropertyGroup\u003e D√©sormais, pour les configurations ‚ÄúDEV‚Äù et ‚ÄúTEST‚Äù, l‚Äôappellation de l‚Äôenvironnement cibl√© appara√Ætra au d√©but du nom d‚Äôapplication et √† la fin de l‚Äôidentifiant d‚Äôapplication. Cette mesure n‚Äôest pas n√©cessaire pour la configuration ‚ÄúPROD‚Äù, car le titre et l‚Äôidentifiant de base seront utilis√©s par d√©faut pour toutes les configurations. ‚Äé C‚Äôest parce que le param√®tre ApplicationId a une valeur diff√©rente pour chaque configuration qu‚Äôil est possible d‚Äôinstaller plusieurs versions de l‚Äôapplication. Tu peux maintenant diff√©rencier l‚Äôapplication de d√©veloppement de celle de production sur ton t√©l√©phone. Cool ! Et si on allait un peu plus loin ? Dans la section suivante, tu apprendras √† personnaliser l‚Äôic√¥ne de l‚Äôapp. ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:3:0","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"D√©finir une ic√¥ne d‚Äôapplication pour chaque environnement cibl√© En plus de nommer l‚Äôapplication selon l‚Äôenvironnement cibl√©, nous allons voir comment d√©finir une ic√¥ne pour chacune des configurations du projet. Pour cela, il te faut d‚Äôabord concevoir une ic√¥ne pour chaque environnement. Une fois que c‚Äôest fait, ajoute-les au projet dans un dossier adapt√©. Par d√©faut, tout projet .NET MAUI comporte un dossier AppIcon. Tout comme pour le nom de l‚Äôapplication, tu auras peut-√™tre remarqu√© que l‚Äôic√¥ne se d√©finit aussi dans le fichier de configuration du projet, avec la propri√©t√© MauiIcon. Commence par supprimer ce param√®tre du fichier .csproj, puis ajoute le code suivant : Nom du fichier :MultiEnvMauiApp.csproj \u003cItemGroup\u003e \u003c!-- App Icon --\u003e \u003cMauiIcon Include=\"Resources\\AppIcon\\icon_dev.png\" Condition=\" '$(Configuration)' == 'DEV' \" /\u003e \u003cMauiIcon Include=\"Resources\\AppIcon\\icon_test.png\" Condition=\" '$(Configuration)' == 'TEST' \" /\u003e \u003cMauiIcon Include=\"Resources\\AppIcon\\icon.png\" Condition=\" '$(Configuration)' == 'PROD' \" /\u003e \u003c/ItemGroup\u003e Et hop ! √áa y‚Äôest, on a d√©fini une ic√¥ne diff√©rente en fonction de la configuration choisie ! Enfin‚Ä¶ presque ! Comme tu le sais, chaque application .NET MAUI s‚Äôappuie sur des fichiers de configuration li√©s √† la plateforme cible. Il est √©galement n√©cessaire de d√©finir l‚Äôic√¥ne de l‚Äôapplication dans ces fichiers : dans le fichier AndroidManifest.xml sur Android, et dans le fichier Info.plist sur iOS. ‚Äé √Ä l‚Äôheure o√π j‚Äô√©cris cet article, il n‚Äôest pas possible de g√©n√©rer automatiquement l‚Äôic√¥ne sur iOS et Android sans modifier ces fichiers. Peut-√™tre une fonctionnalit√© pour .NET 8 ? Tout d‚Äôabord, nous devons associer chacun de ces fichiers √† une configuration diff√©rente. Dans notre cas, nous aurons besoin de 3 fichiers .plist sur iOS et de 3 fichiers .xml sur Android : Android iOS DEV AndroidManifest.dev.xml Info.dev.plist TEST AndroidManifest.test.xml Info.test.plist PROD AndroidManifest.xml Info.plist Commen√ßons par iOS, rends-toi dans le dossier Platforms/iOS et cr√©e deux copies du fichier Info.plist d‚Äôorigine. Puis, renomme-les en Info.dev.plist et Info.test.plist. Pour chaque fichier .plist, nous allons modifier la valeur du param√®tre XSAppIconAssets de sorte √† d√©finir une ic√¥ne par configuration. La documentation indique que la valeur suit le format Assets.xcassets/{name}.appiconset et qu‚Äôil nous faut remplacer {name} par le nom de l‚Äôic√¥ne souhait√©e (sans mentionner son chemin d‚Äôacc√®s, ni son extension). Dans notre cas, voici ce que cela donne pour le fichier Info.dev.plist : Nom du fichier :Info.dev.plist \u003ckey\u003eXSAppIconAssets\u003c/key\u003e \u003cstring\u003eAssets.xcassets/icon_dev.appiconset\u003c/string\u003e Enfin, lorsque tu as modifi√© l‚Äôic√¥ne dans tous les fichiers .plist, retourne dans le fichier de configuration du projet. En effet, nous devons lui indiquer quel fichier .plist consid√©rer selon la configuration choisie : Nom du fichier :MultiEnvMauiApp.csproj \u003cItemGroup Condition=\" '$(TargetFramework)' == 'net7.0-ios' \"\u003e \u003cPartialAppManifest Include=\"Platforms\\iOS\\Info.dev.plist\" Condition=\" '$(Configuration)' == 'DEV' \" /\u003e \u003cPartialAppManifest Include=\"Platforms\\iOS\\Info.test.plist\" Condition=\" '$(Configuration)' == 'TEST' \" /\u003e \u003c/ItemGroup\u003e Par d√©faut, Visual Studio choisira le fichier Info.plist. On doit donc uniquement pr√©ciser quel fichier consid√©rer pour les configurations ‚ÄúDEV‚Äù et ‚ÄúTEST‚Äù. ‚Äé Aller plus loin avec la propri√©t√© PartialAppManifest. Enfin, m√™me chose pour Android. Rends-toi dans le dossier Platforms/Android et cr√©e deux copies du fichier AndroidManifest.xml. Puis, renomme-les en AndroidManifest.dev.xml et AndroidManifest.test.xml. Cependant, ici nous devons renommer le AndroidManifest.xml d‚Äôorigine en AndroidManifest.prod.xml. Sans quoi, tu aurais des soucis √† la compilation de l‚Äôapp. Pour chaque fichier .xml, nous allons modifier la valeur des param√®tres android:icon et android:roundIcon de sorte √† d√©finir une ic√¥ne par configuration. La documentation indique que les valeurs suivent respectivement le forma","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:4:0","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"D√©monstration Il est grand temps de v√©rifier que toute cette mise en place fonctionne. Tu peux maintenant d√©ployer l‚Äôapp pour chaque configuration, et pour chaque plateforme ! Pour les configurations n‚Äôautorisant pas le d√©boggage, tu dois d√©marrer l‚Äôapplication sans d√©boggage pour qu‚Äôelle se d√©ploie sur le simulateur. On doit passer par cette option pour les configurations ‚ÄúTEST‚Äù et ‚ÄúPROD‚Äù. Il y a bien 3 applications install√©es sur mon simulateur iOS avec chacune un nom et une ic√¥ne diff√©rents. Il y a bien 3 applications install√©es sur mon √©mulateur Android avec chacune un nom et une ic√¥ne diff√©rents. Bravo ! üëè Tu vas pouvoir maintenant d√©velopper de nouvelles fonctionnalit√©s sans risquer les donn√©es de tes utilisateurs ! Et puis, c‚Äôest quand m√™me pratique de pouvoir comparer le comportement de l‚Äôapplication entre l‚Äôenvironnement de d√©veloppement et de production. ‚Äé Si tu rencontres des probl√®mes, il se peut que cela soit li√© aux donn√©es en m√©moire sur le t√©l√©phone ou dans Visual Studio. Aussi, pense √† nettoyer la solution et √† supprimer l‚Äôapplication de ton t√©l√©phone avant tout d√©ploiement ! Mais d‚Äôailleurs, et s‚Äôil √©tait possible d‚Äôinstaller une application pour chaque nouveau d√©veloppement ? Tu pourrais alors tester s√©par√©ment chaque nouvelle fonctionnalit√© (ou correctif) sans avoir besoin de d√©sinstaller les anciennes versions de ton app ! √áa sera l‚Äôobjet d‚Äôun prochain article ü§ì ","date":"08/06/2023","objectID":"/posts/tips/multi-environments-project-configuration/:5:0","tags":["Visual Studio","Setup"],"title":"Cibler diff√©rents environnements avec .NET MAUI","uri":"/posts/tips/multi-environments-project-configuration/"},{"categories":null,"content":"Depuis la sortie officielle de .NET MAUI, il n‚Äôest pas possible de cr√©er de nouveau projet sans que Visual Studio n‚Äôy ajoute un Shell par d√©faut. Heureusement, il existe une fa√ßon tr√®s simple de s‚Äôen d√©barrasser !","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/","tags":["New Project","Visual Studio","Shell","Setup"],"title":"Cr√©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Depuis la sortie officielle de .NET MAUI, il n‚Äôest pas possible de cr√©er de nouveau projet sans que Visual Studio n‚Äôy ajoute un Shell par d√©faut. Heureusement, il existe une fa√ßon tr√®s simple de s‚Äôen d√©barrasser ! ","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/:0:0","tags":["New Project","Visual Studio","Shell","Setup"],"title":"Cr√©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Avec ou sans Shell ? √Ä toi de voir ! Quand il s‚Äôagit de cr√©er une nouvelle application en .NET MAUI, Visual Studio ne propose pas beaucoup d‚Äôoptions de configuration : Il y a bien s√ªr le choix de .NET MAUI Blazor, mais c‚Äôest un tout autre framework. Seulement, chaque nouvelle application .NET MAUI cr√©√©e avec Visual Studio embarque un Shell par d√©faut. Et bien que le Shell peut aider √† r√©duire la complexit√© du d√©veloppement d‚Äôune application, c‚Äôest √©galement un outil que tout d√©butant doit apprendre √† ma√Ætriser en plus du reste. Voici d‚Äôailleurs un petit tableau comparatif des avantages et inconv√©nients du Shell : Les avantages Les inconv√©nients Apporte une certaine structure standard √† l‚Äôapplication avec un menu lat√©ral ou des onglets, ainsi qu‚Äôun syst√®me de navigation avec des URLs. Un peu complexe au premier abord pour un d√©butant, peut ralentir l‚Äôouverture de l‚Äôapp, et n‚Äôest pas n√©cessaire dans les cas les plus simples. Finalement, recourir au Shell dans un projet .NET MAUI reste un choix personnel et ne devrait donc pas √™tre impos√© par Visual Studio. Mais alors, comment obtenir une application sans Shell, comme dans le cours Ma Premi√®re App ? Tu vas voir, c‚Äôest tr√®s simple. ","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/:1:0","tags":["New Project","Visual Studio","Shell","Setup"],"title":"Cr√©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Se passer du Shell Dans un premier temps, il te faut un projet .NET MAUI. Tu peux en cr√©er un nouveau avec Visual Studio, ou bien r√©utiliser un projet existant. Une fois ton projet ouvert dans Visual Studio, supprime la classe AppShell en effa√ßant les deux fichiers AppShell.xaml et AppShell.xaml.cs. S√©lectionne les deux fichiers √† la fois, puis fais un clic droit et supprime-les. Visual Studio te demandera probablement une confirmation. V√©rifie que les fichiers s√©lectionn√©s sont les bons et confirme la suppression : On n‚Äôest jamais √† l‚Äôabri d‚Äôune fausse manip ! Voil√†, c‚Äôest fait ! Il ne reste alors plus qu‚Äô√† reconfigurer la page de d√©marrage de l‚Äôapplication. Pour cela, ouvre le fichier App.xaml.cs et rep√®re la ligne de code suivante dans le constructeur de la classe : Nom du fichier :App.xaml.cs MainPage = new AppShell(); Maintenant que la classe AppShell ne fait plus r√©f√©rence √† rien, elle doit donc √™tre remplac√©e. Il te suffit de la remplacer par la classe associ√©e √† la page qui appara√Æt en premier lors de l‚Äôouverture de l‚Äôapp ! Par exemple, pour tous les nouveaux projets, cela donnera : Nom du fichier :App.xaml.cs MainPage = new MainPage(); Et maintenant, √† l‚Äôouverture de l‚Äôapplication, c‚Äôest la page MainPage qui sera charg√©e en premier. Voil√†, tu n‚Äôes plus oblig√©¬∑e de d√©velopper ton application autour d‚Äôun Shell ! Et maintenant, que dirais-tu d‚Äôapprendre √† naviguer de pages en pages sans le Shell ? ","date":"10/04/2023","objectID":"/posts/tips/maui-app-with-no-shell/:2:0","tags":["New Project","Visual Studio","Shell","Setup"],"title":"Cr√©er une app .NET MAUI sans Shell","uri":"/posts/tips/maui-app-with-no-shell/"},{"categories":null,"content":"Allez c‚Äôest bient√¥t la fin du premier gros morceau de notre page principale. On passe d√©sormais au contr√¥le du volume !","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":" ‚Äé Afin d‚Äôassurer le bon d√©roulement de cet article, je t‚Äôinvite √† repartir depuis ce chapitre o√π l‚Äôon a d√©marr√© la mise en place des contr√¥les du lecteur musical. Lors du dernier chapitre, on s‚Äô√©tait attel√©s √† la mise en place des contr√¥les de lecture du m√©dia. On y avait notamment d√©couvert un nouveau type de bouton: le composant ImageButton. Aujourd‚Äôhui, on va encore d√©velopper notre interface utilisateur avec l‚Äôint√©gration des contr√¥les du volume. C‚Äôest la derni√®re ligne droite avant de commencer √† impl√©menter le c≈ìur de notre lecteur musical, alors accroche-toi ! ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:0:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Tout l‚Äôart de reproduire Allez, reprenons donc la maquette, voici ce que l‚Äôon devra reproduire dans l‚Äôapp : Cette fois-ci, il n‚Äôy a que deux contr√¥les, √ßa devrait √™tre rapide ! Comme tu peux le constater, ce n‚Äôest rien d‚Äôautre qu‚Äôun bouton pour couper le son et une barre de contr√¥le du volume sonore. √áa ne devrait pas √™tre tr√®s long, commence par t√©l√©charger les diff√©rentes images utilis√©es pour afficher l‚Äô√©tat du volume. Volume_Tracker_-_Images.zip ./files/Volume_Tracker_-_Images.zip En d√©compressant ce fichier, tu verras 4 nouvelles images: Ici, on a donc une image pour chaque niveau de volume : quand il est tr√®s fort, moyen ou tr√®s bas. D‚Äôailleurs, il y en a m√™me une pour quand le son sera coup√©. Maintenant que tu as les images, il ne te reste alors plus qu‚Äô√† les inclure dans le dossier Resources/Images, exactement comme la derni√®re fois ! ‚Äé Si tu as des doutes, tu peux te r√©f√©rer au chapitre pr√©c√©dent. ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:1:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"√Ä vos marques, pr√™t ? Codez ! C‚Äôest bon, tout est pr√™t ? Allez on passe au code ! Pour cela, on aura besoin d‚Äôun ImageButton pour couper le son et d‚Äôun Slider pour contr√¥ler le volume sonore de mani√®re pr√©cise. ‚Äé üêí‚Äé ‚Äé Ah ! Mais je les connais ceux-l√† ! Eh oui ! Techniquement, c‚Äôest du d√©j√†-vu, alors essaye de reproduire ces contr√¥les par toi-m√™me avant de regarder le code qui suit : Nom du fichier :MusicPlayerView.cs ImageButton MuteButton = new ImageButton { HeightRequest = 25, WidthRequest = 25, Source = \"volume_medium.png\" }; Slider VolumeTracker = new Slider { Minimum = 0, MinimumTrackColor = Colors.Black, Maximum = 100, MaximumTrackColor = Colors.Gray, Value = 60 }; Voil√†, on a donc d√©fini un ImageButton avec une image par d√©faut, et un Slider pour contr√¥ler le volume sonore de 0% √† 100%. Et tu l‚Äôauras s√ªrement not√©, le Slider est compos√© d‚Äôune barre noire qui repr√©sente le volume actuel, et d‚Äôune barre grise pour le volume sup√©rieur disponible. Il ne te reste alors plus qu‚Äô√† rajouter les contr√¥les dans le BottomLayout : Nom du fichier :MusicPlayerView.cs MuteButton.Row(2).Column(1), VolumeTracker.Row(2).Column(2).ColumnSpan(3), Alors, tu avais bien pens√© √† appliquer un ColumnSpan ? üòõ¬†On en a en effet besoin pour afficher la barre de son √† cheval sur trois colonnes de notre Grid. Allez, il est temps de relancer l‚Äôappli ! Voyons ce que √ßa donne : Vu comme √ßa, on dirait presque que l‚Äôapplication est termin√©e‚Ä¶ ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:2:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Changer d‚Äôimage quand le son est coup√© √áa devient plus facile avec tout cet entra√Ænement, tu commences √† prendre le coup de main ? üôÇ Bon, cette fois-ci, il n‚Äôy avait que deux composants √† d√©finir, alors on va aller un petit plus loin. Tu te rappelles des diff√©rentes images pour notre volume ? Il est temps de leur trouver une utilit√© ! L‚Äôid√©e, c‚Äôest que notre MuteButton change d‚Äôapparence en fonction du niveau de volume demand√©. On aura donc une r√©f√©rence directe au VolumeTracker pour trouver la bonne image √† associer au MuteButton. Pour cela, on utilisera un DataTrigger qui permet de modifier la propri√©t√© d‚Äôun objet lorsqu‚Äôune certaine valeur est d√©tect√©e. Prenons le cas le plus simple, celui o√π le volume sonore d√©tect√© est de 0 : Nom du fichier :MusicPlayerView.cs DataTrigger VolumeOffTrigger =\u003e new DataTrigger(typeof(ImageButton)) { Binding = new Binding(nameof(Slider.Value), source: VolumeTracker), Value = 0d, Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_off.png\" } } }; Dans un premier temps, on pr√©cise sur quel type d‚Äôobjet appliquer des modifications. Dans notre cas, ce sera un ImageButton, puisque c‚Äôest l‚Äôimage du MuteButton que l‚Äôon veut changer : Nom du fichier :MusicPlayerView.cs DataTrigger VolumeOffTrigger =\u003e new DataTrigger(typeof(ImageButton)) Puis, √† l‚Äôaide d‚Äôun Setter, on demande au VolumeOffTrigger de changer la source d‚Äôimage du MuteButton pour l‚Äôic√¥ne correspondant au volume √©teint : Nom du fichier :MusicPlayerView.cs new Setter { Property = ImageButton.SourceProperty, Value = \"volume_off.png\" } Or, la modification ne doit s‚Äôappliquer que dans le cas o√π la valeur du VolumeTracker atteint 0 ! Ceci est rendu possible par la technique du Binding. On cr√©e alors un lien vers ce composant pour suivre l‚Äô√©volution de la propri√©t√© Value : Nom du fichier :MusicPlayerView.cs Binding = new Binding(nameof(Slider.Value), source: VolumeTracker) Enfin, la valeur cible √† atteindre est d√©finie dans le VolumeOffTrigger de cette fa√ßon : Nom du fichier :MusicPlayerView.cs Value = 0d En r√©sum√©, on a donc un d√©clencheur qui modifiera l‚Äôic√¥ne au moment o√π l‚Äôutilisateur abaissera la valeur du Slider √† z√©ro. ‚Äé üêí‚Äé ‚Äé Ok ! Mais pourquoi mettre un ‚Äúd‚Äù apr√®s le ‚Äú0‚Äù ? H√©h√©, bien vu ! En effet, ce n‚Äô√©tait pas une erreur typographique üòÑ En fait, la documentation du Slider pr√©cise que la propri√©t√© Value est de type double. Cela donne √† l‚Äôutilisateur un peu plus de contr√¥le quand il manipule un Slider (√† la virgule pr√®s !). Or, si tu supprimes le ‚Äúd‚Äù et que tu passes ta souris au-dessus du ‚Äú0‚Äù, tu constateras que ce n‚Äôest plus consid√©r√© comme un double, mais un int ! Visual Studio est clair sur ce point, ‚Äú0‚Äù est bien un entier ! Et comme la propri√©t√© Value de notre d√©clencheur est de type object, elle accepte potentiellement n‚Äôimporte quel type de valeur. On doit donc explicitement lui indiquer comment consid√©rer ce ‚Äú0‚Äù : comme un double ! On doit rajouter le ‚Äúd‚Äù juste apr√®s : √Ä pr√©sent, ‚Äú0‚Äù est bien un double ! Visual Studio n‚Äôy a vu que du feu. Il ne reste alors plus qu‚Äô√† rattacher ce d√©clencheur √† notre composant MuteButton. D‚Äôailleurs, comme il sera sujet √† des configurations suppl√©mentaires, on va isoler son initialisation dans une m√©thode InitMuteButton(). Cela permettra de garder notre code clair : Nom du fichier :MusicPlayerView.cs public MusicPlayerView() { ... InitMuteButton(); Content = new Grid { ... }; } void InitMuteButton() { MuteButton.Triggers.Add(VolumeOffTrigger); } Et voil√† ! Essaye maintenant de glisser la valeur du Slider tout √† gauche : L‚Äôic√¥ne du son coup√© appara√Æt aussit√¥t que le curseur est d√©plac√© tout √† gauche. ","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:3:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Un bouton dans tous ses √©tats ! Maintenant que tu sais comment fonctionnent les d√©clencheurs, on va en cr√©er d‚Äôautres pour g√©rer tous les diff√©rents √©tats du bouton. Fonctionnellement, voici ce que l‚Äôon aimerait mettre en place : l‚Äôic√¥ne du volume bas appara√Ætra pour toutes les valeurs sup√©rieures √† 0 et jusqu‚Äô√† 15, pour les valeurs sup√©rieures √† 15 et jusqu‚Äô√† 50, on affichera l‚Äôic√¥ne du volume mod√©r√©, et pour l‚Äôic√¥ne du volume √©lev√©, ce sera pour toutes valeurs sup√©rieures √† 50 et jusqu‚Äô√† 100. Pour tous ces cas-l√†, le d√©clencheur ne d√©pend plus d‚Äôune seule valeur bien pr√©cise, mais plut√¥t de toute une plage de valeurs. On va donc faire appel √† un nouveau d√©clencheur sp√©cifique, le MultiTrigger. C‚Äôest le m√™me principe que pour le DataTrigger, √† la diff√©rence que le MultiTrigger d√©pendra du r√©sultat de plusieurs conditions. Je vais t‚Äôexpliquer juste apr√®s. Pour le moment, d√©clarons nos trois nouveaux √©tats possibles : Nom du fichier :MusicPlayerView.cs MultiTrigger VolumeLowTrigger = new MultiTrigger(typeof(ImageButton)) { Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_low.png\" } } }; MultiTrigger VolumeMediumTrigger = new MultiTrigger(typeof(ImageButton)) { Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_medium.png\" } } }; MultiTrigger VolumeHighTrigger = new MultiTrigger(typeof(ImageButton)) { Setters = { new Setter { Property = ImageButton.SourceProperty, Value = \"volume_high.png\" } } }; Tout ce qu‚Äôon a fait, c‚Äôest d√©finir les changements d‚Äôapparence √† l‚Äôaide de Setters, pour un volume bas, moyen ou √©lev√©. On peut d√©sormais d√©finir les conditions de d√©clenchement pour ces trois √©tats. Modifie la m√©thode InitMuteButton() comme indiqu√© ci-apr√®s : Nom du fichier :MusicPlayerView.cs void InitMuteButton() { BindingCondition CreateRangeCondition(OperatorType comparison, double value) =\u003e new BindingCondition { Binding = new Binding( nameof(Slider.Value), source: VolumeTracker, converter: new CompareConverter { ComparisonOperator = comparison, ComparingValue = value }), Value = true }; BindingCondition CreateMinRangeCondition(double value) =\u003e CreateRangeCondition(OperatorType.Greater, value); BindingCondition CreateMaxRangeCondition(double value) =\u003e CreateRangeCondition(OperatorType.SmallerOrEqual, value); VolumeLowTrigger.Conditions.Add(CreateMinRangeCondition(0d)); VolumeLowTrigger.Conditions.Add(CreateMaxRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMinRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMaxRangeCondition(50d)); VolumeHighTrigger.Conditions.Add(CreateMinRangeCondition(50d)); VolumeHighTrigger.Conditions.Add(CreateMaxRangeCondition(100d)); MuteButton.Triggers.Add(VolumeOffTrigger); MuteButton.Triggers.Add(VolumeLowTrigger); MuteButton.Triggers.Add(VolumeMediumTrigger); MuteButton.Triggers.Add(VolumeHighTrigger); } Oui je sais, √ßa peut faire beaucoup d‚Äôun coup, mais ce n‚Äôest pas dur √† comprendre. D‚Äôailleurs, tu peux voir qu‚Äôon r√©p√®te souvent les m√™mes op√©rations dans ce bout de code ! ‚Äé üêí‚Äé ‚Äé Bah ouais, m√™me pas peur ! Je fais quoi ensuite ? A ce stade, quelques erreurs auront probablement √©t√© mises en √©vidence par Visual Studio. Pour les r√©soudre, d√©clare les en-t√™tes suivantes tout en haut du fichier : Nom du fichier :MusicPlayerView.cs using CommunityToolkit.Maui.Converters; using static CommunityToolkit.Maui.Converters.CompareConverter\u003cobject\u003e; ‚Äé Cette √©tape est requise pour que le compilateur comprenne √† quoi correspondent les nouveaux objets utilis√©s : CompareConverter et Operator.Type. Il est maintenant temps de passer aux explications. D√©cortiquons un peu cette m√©thode InitMuteButton() en commen√ßant par cette portion de code : Nom du fichier :MusicPlayerView.cs VolumeLowTrigger.Conditions.Add(CreateMinRangeCondition(0d)); VolumeLowTrigger.Conditions.Add(CreateMaxRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMinRangeCondition(15d)); VolumeMediumTrigger.Conditions.Add(CreateMaxRangeCondition(50d)); Volu","date":"20/03/2023","objectID":"/posts/tutos/my-first-app/9-music-player-display-volume/:4:0","tags":["Image","ImageButton","DataTrigger","Slider","MultiTrigger",".NET Community Toolkit","C# markup"],"title":"Affichage du lecteur MP3 - Volume","uri":"/posts/tutos/my-first-app/9-music-player-display-volume/"},{"categories":null,"content":"Des boutons, toujours plus de boutons ! Dans ce chapitre, on va int√©grer les contr√¥les pour manipuler le m√©dia.","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/","tags":["Image","ImageButton","Visual Studio","Round Effect","ColumnSpan"],"title":"Affichage du lecteur MP3 - Contr√¥les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":" ‚Äé Afin d‚Äôassurer le bon d√©roulement de cet article, je t‚Äôinvite √† repartir depuis ce chapitre o√π l‚Äôon a d√©marr√© la mise en place des contr√¥les du lecteur musical. Lors du dernier chapitre, on s‚Äô√©tait attel√©s √† la mise en place des premiers √©l√©ments visuels du lecteur musical. On y avait notamment d√©couvert deux composants: le Label et le Slider. Aujourd‚Äôhui, on va continuer sur notre belle lanc√©e et reproduire toute une s√©rie de boutons pour contr√¥ler le m√©dia. ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:0:0","tags":["Image","ImageButton","Visual Studio","Round Effect","ColumnSpan"],"title":"Affichage du lecteur MP3 - Contr√¥les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"La guerre des boutons Pour √©couter de la musique, notre utilisateur a besoin de fonctions cl√©s comme : jouer un morceau, passer √† la piste suivante, etc. Si tu te souviens de la maquette, on avait une rang√©e principale de 5 boutons : 5 boutons bien align√©s sur la m√™me rang√©e, mais ils n‚Äôont pas tous la m√™me taille. La diff√©rence avec le bouton ‚ÄúENTER‚Äù de la page d‚Äôaccueil, c‚Äôest qu‚Äôici, nos 5 boutons repr√©sentent une image cliquable. Pour les reproduire dans l‚Äôapp, on fera donc appel au composant ImageButton. Mais tout d‚Äôabord, il faudra ajouter ces fameuses images au projet. Commence donc par les t√©l√©charger sur ton ordinateur : Media_Control_-_Images.zip ./files/Media_Control_-_Images.zip Puis d√©compresse le fichier obtenu. Tu devrais avoir les 6 images suivantes : ‚Äé üêí‚Äé ‚Äé 6 images‚Ä¶ mais on n‚Äôavait pas dit 5 boutons ? En effet, il y aura bien 5 boutons sur cette rang√©e. Mais rien ne nous emp√™che de remplacer l‚Äôimage du bouton par une autre ! Si tu reprends la maquette, il y aura de gauche √† droite : un bouton pour rejouer la piste musicale (une seule fois) ‚áí c‚Äôest l‚Äôimage repeat_once.png un autre pour revenir √† la chanson pr√©c√©dente ‚áí skip_previous.png on aura aussi un gros bouton central pour jouer ou mettre en pause la musique. C‚Äôest l‚Äôimage de ce bouton qui changera automatiquement selon les cas suivants : soit la piste n‚Äôest pas en cours de lecture ‚áí ce sera l‚Äôimage play.png ou bien elle est d√©j√† en train d‚Äô√™tre jou√©e ‚áí on affichera alors pause.png puis on aura un bouton pour passer √† la chanson suivante ‚áí skip_next.png et un dernier pour t√©l√©charger le morceau ‚áí download.png Oui je sais, cette derni√®re fonction ‚Äút√©l√©charger‚Äù n‚Äô√©tait pas pr√©vue au programme ! √á√† devait initialement √™tre pour lire les titres en mode al√©atoire, mais j‚Äôai chang√© d‚Äôavis. üòÑ Comme quoi, c‚Äôest important de concevoir une maquette aussi fiable que possible ! ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:1:0","tags":["Image","ImageButton","Visual Studio","Round Effect","ColumnSpan"],"title":"Affichage du lecteur MP3 - Contr√¥les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"Ajouter les images au projet Maintenant que tu as t√©l√©charg√© toutes les images, tu dois les importer dans le projet pour qu‚Äôelles deviennent utilisables par l‚Äôapplication. Pour cela, ouvre le projet dans Visual Studio et fais un clic droit sur le dossier Images : Rappelle-toi, c‚Äôest dans le dossier Resources qu‚Äôon stocke tous les m√©dias (ic√¥nes, images, pistes audio et vid√©o, ‚Ä¶) Dans le menu contextuel qui s‚Äôaffiche, dans la section Ajouter, clique sur l‚Äôoption pour ajouter des fichiers depuis un dossier : Puis, s√©lectionne le dossier o√π tu as d√©compress√© les 6 images et valide ton choix. Une fen√™tre appara√Æt alors pour choisir les fichiers √† inclure dans le projet. Dans notre cas, on veut importer toutes les images du dossier. S√©lectionne donc tous les fichiers disponibles et clique sur OK : ‚Äé Il y a de grandes chances pour que Visual Studio te demande quelle strat√©gie appliquer pour importer les fichiers dans le dossier Resources/Images. Je te conseille de choisir de les copier, ou de les d√©placer. Voil√† c‚Äôest termin√©, v√©rifie que tu as bien les 6 nouvelles images import√©es dans le dossier ! ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:2:0","tags":["Image","ImageButton","Visual Studio","Round Effect","ColumnSpan"],"title":"Affichage du lecteur MP3 - Contr√¥les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"D√©couverte des ImageButton Maintenant que les images sont pr√™tes √† l‚Äôemploi, on passe au code ! D√©finissons d‚Äôabord les deux boutons les plus petits (ceux aux extr√©mit√©s) : Nom du fichier :MusicPlayerView.cs ImageButton RepeatOnceButton =\u003e new ImageButton { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"repeat_once.png\", BackgroundColor = Colors.Black }; ImageButton DownloadButton =\u003e new ImageButton { CornerRadius = 5, HeightRequest = 25, WidthRequest = 25, Source = \"download.png\", BackgroundColor = Colors.Black }; Comme tu peux le constater, on leur a d√©fini une petite taille de forme carr√©e (25 de hauteur sur 25 de largeur), √† fond noir et aux coins l√©g√®rement arrondis (via la propri√©t√© CornerRadius). Puis, ils ont eu chacun leur propre image assign√©e gr√¢ce √† la propri√©t√© Source, en lui passant le nom du fichier correspondant. ‚Äé Si tu ne pr√©vois pas de cibler la plateforme Windows, alors il n‚Äôest pas n√©cessaire de pr√©ciser l‚Äôextension ‚Äù.png‚Äù dans le nom du fichier. Reste alors √† d√©finir les 3 boutons pour contr√¥ler la lecture du morceau, en ayant toujours recours √† l‚ÄôImageButton : Nom du fichier :MusicPlayerView.cs ImageButton SkipPreviousButton =\u003e new ImageButton { HeightRequest = 75, WidthRequest = 75, Source = \"skip_previous.png\" }; ImageButton PlayButton =\u003e new ImageButton { CornerRadius = 50, HeightRequest = 100, WidthRequest = 100, Source = \"play.png\", BackgroundColor = Colors.Black }; ImageButton SkipNextButton =\u003e new ImageButton { HeightRequest = 75, WidthRequest = 75, Source = \"skip_next.png\" }; Finalement, ce n‚Äôest pas tellement diff√©rent ! Cependant, tu noteras que ces contr√¥les sont plus grands, et surtout, les boutons SkipPrevious et SkipNext n‚Äôont pas de couleur de fond. Au contraire, le bouton Jouer, lui, est dot√© d‚Äôun arri√®re-plan noir et a les coins tr√®s arrondis‚Ä¶ tellement arrondis que la forme n‚Äôest plus carr√©e, mais ronde ! ‚Äé üêí‚Äé ‚Äé Ah bon, une forme ronde ? Mais comment as-tu fait ? La technique est tr√®s simple : les valeurs de HeightRequest et WidthRequest doivent √™tre identiques, tandis que celle du CornerRadius doit leur √™tre deux fois inf√©rieure. Ainsi, si tu veux un bouton de forme ronde avec une hauteur de 200, son arrondissement devra avoir une valeur de 100. ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:3:0","tags":["Image","ImageButton","Visual Studio","Round Effect","ColumnSpan"],"title":"Affichage du lecteur MP3 - Contr√¥les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"Pr√©paration pour la d√©mo Allez, il est d√©sormais temps pour toi de r√©partir ces nouveaux contr√¥les sur la deuxi√®me ligne du BottomLayout ! √âtant donn√© qu‚Äôon a 5 boutons pour 7 colonnes, tu auras peut-√™tre opt√© pour la disposition suivante : Nom du fichier :MusicPlayerView.cs RepeatOnceButton.Row(1).Column(1), SkipPreviousButton.Row(1).Column(2), PlayButton.Row(1).Column(3), SkipNextButton.Row(1).Column(4), DownloadButton.Row(1).Column(5) ‚Äé üêí‚Äé ‚Äé Ben oui c‚Äôest ce que j‚Äôai fait‚Ä¶ et alors fallait pas ? üôà Si, bien s√ªr ! Tu as forc√©ment d√ª relancer ton app pour v√©rifier, et le rendu n‚Äôest pas si mal. Pour ma part, j‚Äôai pr√©f√©r√© recr√©er un Grid sp√©cialement pour englober les boutons Play, SkipPrevious et SkipNext, comme ceci : Nom du fichier :MusicPlayerView.cs Grid MediaControlLayout =\u003e new Grid { ColumnDefinitions = Columns.Define( Stars(30), Stars(40), Stars(30)), ColumnSpacing = 0, Children = { SkipPreviousButton.Column(0), PlayButton.Column(1), SkipNextButton.Column(2) } }; Il s‚Äôagit seulement d‚Äôune grille divis√©e en trois colonnes, avec chacune une taille sp√©cifique. Ainsi, le bouton Play prendra un peu plus d‚Äôespace que les deux autres. Mais bon, tout √ßa est devenu facile pour toi, tu commences √† ma√Ætriser maintenant ! üòé Allez, il ne reste plus qu‚Äô√† positionner le MediaControlLayout de cette fa√ßon : RepeatOnceButton.Row(1).Column(1), MediaControlLayout.Row(1).Column(2).ColumnSpan(3), DownloadButton.Row(1).Column(5) Et hop, √ßa y est, √ßa commence vraiment √† prendre forme ! ü§© Tu t‚Äôen es vraiment bien sorti, continue comme √ßa ! D‚Äôailleurs, il nous reste encore la gestion du volume de la musique √† reproduire dans l‚Äôapp, et c‚Äôest justement l‚Äôobjet du prochain chapitre ! Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"27/02/2023","objectID":"/posts/tutos/my-first-app/8-music-player-display-media-playback/:4:0","tags":["Image","ImageButton","Visual Studio","Round Effect","ColumnSpan"],"title":"Affichage du lecteur MP3 - Contr√¥les de lecture","uri":"/posts/tutos/my-first-app/8-music-player-display-media-playback/"},{"categories":null,"content":"Maintenant que les fondations de la page principale sont pr√™tes, on va pouvoir commencer √† disposer tous les √©l√©ments de contr√¥le. Commen√ßons avec le minutage !","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - Dur√©e d'√©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":" ‚Äé Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú3 - Page Scaffolding‚Äù. Dans l‚Äôarticle pr√©c√©dent, on a mis en place un quadrillage pour y disposer tous les contr√¥les de notre lecteur musical. On va donc pouvoir ajouter des √©l√©ments concrets pour l‚Äôutilisateur ! ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:0:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - Dur√©e d'√©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Afficher le minutage Commen√ßons d√©j√† avec la partie d√©di√©e au minutage du titre musical. D‚Äôapr√®s la maquette, on aura un texte √† gauche pour le temps d‚Äô√©coute en cours, et √† droite, pour la dur√©e totale de la piste : L‚Äôapplication indique que le morceau est jou√© depuis 36 secondes et qu‚Äôil dure 2 minutes et 57 secondes. Pour reproduire cela dans l‚Äôapplication, on utilisera le composant Label qui permet d‚Äôafficher du texte √† l‚Äô√©cran : Nom du fichier :MusicPlayerView.cs Label ElapsedTime =\u003e new Label { FontSize = 14, Text = \"0:36\", TextColor = Colors.White }.TextCenter(); Label TotalTime =\u003e new Label { FontSize = 14, Text = \"2:57\", TextColor = Colors.White }.TextCenter(); Ces deux nouveaux √©l√©ments sont d√©finis pour afficher un texte statique √©crit en blanc et avec une taille relativement petite. Cependant, la taille des caract√®res s‚Äôadaptera automatiquement au niveau d‚Äôagrandissement du texte d√©fini par l‚Äôutilisateur dans les r√©glages d‚Äôaccessibilit√© de son t√©l√©phone. ‚Äé Aller plus loin avec l‚Äôaccessibilit√© pour les applications mobiles. ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:1:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - Dur√©e d'√©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Ajuster la t√™te de lecture Quant √† l‚Äô√©l√©ment du milieu, il remplit deux fonctions √† la fois : afficher et contr√¥ler la position de lecture dans le morceau. En effet, l‚Äôutilisateur s‚Äôen sert pour avancer ou reculer dans le morceau en faisant glisser son doigt horizontalement. De plus, ce composant poss√®de une partie en rose qui repr√©sente le temps √©coul√©, et une autre en noir pour le temps restant. Pour reproduire cette barre de navigation, on utilisera le composant Slider : Nom du fichier :MusicPlayerView.cs Slider TimeTracker =\u003e new Slider { Minimum = 0, MinimumTrackColor = Colors.LightSalmon, Maximum = 100, MaximumTrackColor = Colors.Black, Value = 20 }; Un Slider est un contr√¥le dot√© d‚Äôun curseur permettant √† l‚Äôutilisateur de s√©lectionner une valeur pr√©cise parmi toute une plage de valeurs possibles. Dans notre cas, c‚Äôest comme si l‚Äôon avait une r√®gle gradu√©e de 0 √† 100 avec un curseur positionn√© sur le 20. ‚Äé üêí‚Äé ‚Äé Ah oui je vois, on se situe en fait √† 20% du morceau ! On aura donc une barre rose de 0 jusqu‚Äô√† 20, et une barre noire de 20 jusqu‚Äô√† 100. Oui, c‚Äôest √ßa ! Bon √©videmment ici, toutes les valeurs de configuration sont statiques, mais l‚Äôid√©e finale est de permettre √† l‚Äôutilisateur d‚Äôavancer ou de reculer l‚Äô√©coute de la piste √† la seconde pr√®s. Voil√†, on en a termin√© avec la premi√®re rang√©e d‚Äô√©l√©ments du lecteur musical. Pour v√©rifier que l‚Äôaffichage est correct, j‚Äôaimerais que tu effaces tous les √©l√©ments enfants du BottomLayout pour lui assigner tous les composants d√©finis dans ce chapitre. Pour cela, tu seras s√ªrement tent√© d‚Äô√©crire quelque chose comme : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { ... Children = { ElapsedTime.Row(0).Column(1), TimeTracker.Row(0).Column(2), TotalTime.Row(0).Column(5) } }; √Ä premi√®re vue, √ßa semble pas mal ! Cependant, si tu d√©marres l‚Äôapplication, tu constateras qu‚Äôil y a un l√©ger probl√®me d‚Äôaffichage : Dispos√© comme √ßa, le Slider n‚Äôa pas bonne mine. Pas de panique ! On va voir tout de suite comment r√©ajuster cela. ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:2:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - Dur√©e d'√©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Bien utiliser les Grid Si tu te rappelles, on a initialement divis√© le BottomLayout en 7 colonnes. Or, si notre code positionne bien notre Slider √† partir de la case n¬∞3 de la premi√®re ligne, il ne lui dit pas clairement o√π s‚Äôarr√™ter ! On pourrait alors simplement dire au Slider de s‚Äô√©taler sur les colonnes suivantes, comme ceci : Le Slider est √† cheval sur les cases n¬∞3, n¬∞4 et n¬∞5. Pour cela, on utilise la m√©thode ColumnSpan() pour demander au Slider de s‚Äô√©tendre jusqu‚Äô√† 3 colonnes √† partir de la case n¬∞3 : Nom du fichier :MusicPlayerView.cs TimeTracker.Row(0).Column(2).ColumnSpan(3) Et voil√† on en a vraiment fini ! Relan√ßons l‚Äôapplication pour voir ce que √ßa donne : Bon, c‚Äôest vrai, c‚Äôest beau mais √ßa ne fait pas grand chose ! Mais on va d‚Äôabord finir la partie visuelle avant de basculer vers la partie plus fonctionnelle de l‚Äôapplication. D‚Äôailleurs, on a encore plein de boutons √† mettre en place ! Notre objectif pour le prochain chapitre : contr√¥ler la lecture du m√©dia. Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"06/02/2023","objectID":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/:3:0","tags":["Accessibility","Slider","Label","ColumnSpan"],"title":"Affichage du lecteur MP3 - Dur√©e d'√©coute","uri":"/posts/tutos/my-first-app/7-music-player-display-time-tracker/"},{"categories":null,"content":"Avant de d√©velopper une nouvelle page, il vaut mieux r√©fl√©chir √† la disposition des diff√©rents √©l√©ments. Et tu vas voir, c‚Äôest un vrai travail d‚Äôarchitecte !","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":" ‚Äé Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú2 - Navigation‚Äù. Avec ce nouveau chapitre, on entame une s√©rie d‚Äôarticles ax√©s autour du visuel de l‚Äôapp, et il y a de bonnes chances que cela te plaise ! En effet, d√©velopper une interface visuelle n√©cessite de nombreux tests du rendu √† l‚Äô√©cran, et il n‚Äôy a rien de mieux pour apprendre. Et c‚Äôest par la pratique r√©guli√®re que tu vas naturellement comprendre et retenir tout un tas de choses üôÇ Allez, on est partis pour mettre en place les fondations de la page principale ! ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:0:0","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Le design Mais avant tout d√©veloppement graphique, il vaut mieux r√©fl√©chir √† la disposition des diff√©rents √©l√©ments que l‚Äôon souhaite afficher. Justement, .NET MAUI fournit pour cela plusieurs solutions simples pour structurer nos pages. Et tu vas voir, c‚Äôest un vrai travail d‚Äôarchitecte ! ‚Äé üêí‚Äé ‚Äé Mais au fait, √† quoi doit ressembler notre page ? C‚Äôest une tr√®s bonne question ! En g√©n√©ral, quand imagine une nouvelle page pour notre application, il est conseill√© d‚Äôen √©laborer le design au crayon sur une feuille. En effet, comme les √©crans de t√©l√©phone sont assez petits, il n‚Äôest pas facile de disposer tous les √©l√©ments souhait√©s. Puis, quand on est satisfait du rendu sur papier, on pr√©pare alors une maquette sur ordinateur pour un rendu plus r√©aliste : √ßa facilite grandement l‚Äôint√©gration de la page dans l‚Äôapplication. Dans le cadre de notre cours, la page principale devra ressembler √† la maquette suivante : ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:1:0","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Structuration de la page Sur cette maquette, on remarque que les √©l√©ments sont dispos√©s de fa√ßon assez r√©guli√®re. On pourrait m√™me imaginer des lignes pour aligner les √©l√©ments les uns par rapport aux autres : Disposer les √©l√©ments suivant des lignes imaginaires est un exercice un peu sp√©cial au d√©but, mais cela devient une habitude avec le temps. Ces lignes te feront peut-√™tre penser √† une grille‚Ä¶ et si c‚Äôest le cas, bien vu ! C‚Äôest tout le principe du composant Grid, qui comme son nom l‚Äôindique, permet de disposer des √©l√©ments sur une grille. On va l‚Äôutiliser plusieurs fois pour cette page. ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:2:0","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Initiation au Grid Pour respecter la maquette, la premi√®re chose √† faire est de diviser la page en deux : La partie du haut qui n‚Äôaffiche rien d‚Äôautre qu‚Äôun fond noir, Et celle du bas pour contr√¥ler notre lecteur de musique. Tu remarqueras que la partie sup√©rieure est l√©g√®rement plus grande que la partie inf√©rieure. On pourrait m√™me dire que la partie noire s‚Äô√©tale verticalement sur 60% de la page, ce qui laisse 40% d‚Äôespace pour le reste. Ce sont des donn√©es tr√®s utiles ! Mettons-les en application pour d√©finir le contenu de notre page MusicPlayerView avec un Grid : Nom du fichier :MusicPlayerView.cs using CommunityToolkit.Maui.Markup; using static CommunityToolkit.Maui.Markup.GridRowsColumns; ... public MusicPlayerView() { ... Content = new Grid { RowDefinitions = Rows.Define( Stars(60), Stars(40)), RowSpacing = 0, Children = { TopLayout.Row(0), BottomLayout.Row(1), } }; } Avec le param√®tre RowDefinitions, on configure une grille de 2 lignes : la premi√®re pourra s‚Äô√©tendre jusqu‚Äô√† 60% de la page verticalement contre 40% pour la deuxi√®me, comme sur notre design ! A l‚Äôinitialisation du Grid, on d√©finit √©galement deux autres param√®tres : le RowSpacing d√©fini √† 0 pour ne laisser aucun espace entre les lignes de notre grille, et Children qui contiendra tous les √©l√©ments de notre grille, √† r√©partir sur deux lignes. Et si tu te demandes d‚Äôo√π sortent ces fameux TopLayout et BottomLayout, il s‚Äôagit de deux conteneurs d‚Äô√©l√©ments √† d√©finir en dehors du constructeur de la page. En effet, on utilise √† nouveau un Grid pour chacun de ces deux contr√¥les pour nous aider dans le placement des √©l√©ments restants. Le premier Grid (le TopLayout) correspond √† la partie sup√©rieure de notre page et a donc un fond noir. Quant √† l‚Äôautre Grid (le BottomLayout), on lui d√©finit un fond gris fonc√© pour repr√©senter la partie inf√©rieure. Copie le code suivant et colle-le dans la r√©gion d√©di√©e aux contr√¥les du fichier MusicPlayerView.cs: Nom du fichier :MusicPlayerView.cs #region Controls Grid TopLayout =\u003e new Grid { BackgroundColor = Colors.Black }; Grid BottomLayout =\u003e new Grid { BackgroundColor = Colors.DimGray }; #endregion ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:3:0","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"Les fondations principales Concentrons-nous dans un premier temps sur le contenu du BottomLayout. En regardant d‚Äôun peu plus pr√®s le design, on remarque de nouvelles lignes, mais √©galement des colonnes. Plus exactement : on remarque 3 lignes de haut en bas, √† taille identique, et il y a 7 colonnes de gauche √† droite (2 petites, 3 grandes et 2 petites √† nouveau). En quadrillant la zone inf√©rieure de la page, on remarque que chaque √©l√©ment visuel a bien sa case attitr√©e. D√©finissons maintenant les lignes et colonnes qui composent notre BottomLayout de sorte √† respecter l‚Äôalignement des √©l√©ments visuels, comme sur la maquette : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { BackgroundColor = Colors.DimGray, RowDefinitions = Rows.Define( Stars(1), Stars(1), Stars(1)), RowSpacing = 0, ColumnDefinitions = Columns.Define( Stars(10), Stars(10), Stars(20), Stars(20), Stars(20), Stars(10), Stars(10)), ColumnSpacing = 0 }; Comme tu vois, le code ci-dessus propose un d√©coupage en 3 lignes de m√™me taille et 7 colonnes avec des tailles diff√©rentes. ‚Äé üêí‚Äé ‚Äé Euh‚Ä¶ alors si j‚Äôadditionne les tailles de chaque colonne, j‚Äôobtiens bien 100% ! Mais pour ce qui est des lignes, on a un probl√®me non ? Tr√®s bonne remarque ! En fait si je suis parti au d√©but avec un √©chelonnement des tailles sur 100%, c‚Äôest parce que c‚Äôest souvent plus facile √† comprendre. En r√©alit√©, quand tu √©cris‚Ä¶ Nom du fichier :MusicPlayerView.cs RowDefinitions = Rows.Define( Stars(60), Stars(40)) ‚Ä¶ l‚Äôapplication comprend que la premi√®re ligne aura un poids de 60 par rapport √† la deuxi√®me ligne, qui elle n‚Äôaura qu‚Äôun poids de 40. C‚Äôest une fa√ßon dynamique d‚Äôattribuer une hauteur √† nos lignes en fonction de la taille de l‚Äô√©cran, puisqu‚Äôelle change d‚Äôun mod√®le de t√©l√©phone √† un autre. Finalement, tu peux voir ce poids comme un coefficient multiplicateur. Par exemple, ce m√™me bout de code peut √™tre r√©√©crit de cette fa√ßon: Nom du fichier :MusicPlayerView.cs RowDefinitions = Rows.Define( Stars(1.5), // 1.5 x 40 = 60 Stars(1)) // 1 x 40 = 40 A toi de choisir ce qui te semble plus coh√©rent ! ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:4:0","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"V√©rification du rendu √† l‚Äô√©cran Maintenant que notre quadrillage de la partie inf√©rieure est en place, v√©rifions si les param√®tres sont corrects. Avec une Grid configur√©e sur 3 lignes et 7 colonnes, √ßa fait beaucoup de cases √† valider ! Mais j‚Äôai une astuce pour tester rapidement si le d√©coupage est bien celui attendu ou s‚Äôil y a des ajustements √† faire. Pour cela, tu peux dessiner une forme g√©om√©trique dans chaque case du quadrillage, avec chacune sa propre couleur. Avec la BoxView, c‚Äôest tr√®s facile : Nom du fichier :MusicPlayerView.cs Grid BottomLayout =\u003e new Grid { [...] ColumnSpacing = 0, Children = { new BoxView { Color = Color.FromArgb(\"#ffffff\") }.Row(0).Column(0), new BoxView { Color = Color.FromArgb(\"#d0d0d0\") }.Row(0).Column(1), new BoxView { Color = Color.FromArgb(\"#a2a3a3\") }.Row(0).Column(2), new BoxView { Color = Color.FromArgb(\"#777879\") }.Row(0).Column(3), new BoxView { Color = Color.FromArgb(\"#4e5051\") }.Row(0).Column(4), new BoxView { Color = Color.FromArgb(\"#292b2c\") }.Row(0).Column(5), new BoxView { Color = Color.FromArgb(\"#000405\") }.Row(0).Column(6), new BoxView { Color = Color.FromArgb(\"#f3f337\") }.Row(1).Column(0), new BoxView { Color = Color.FromArgb(\"#a2eb5b\") }.Row(1).Column(1), new BoxView { Color = Color.FromArgb(\"#4edb80\") }.Row(1).Column(2), new BoxView { Color = Color.FromArgb(\"#00c89f\") }.Row(1).Column(3), new BoxView { Color = Color.FromArgb(\"#00b1b1\") }.Row(1).Column(4), new BoxView { Color = Color.FromArgb(\"#0098b2\") }.Row(1).Column(5), new BoxView { Color = Color.FromArgb(\"#177ea2\") }.Row(1).Column(6), new BoxView { Color = Color.FromArgb(\"#bf7aef\") }.Row(2).Column(0), new BoxView { Color = Color.FromArgb(\"#ea6cd4\") }.Row(2).Column(1), new BoxView { Color = Color.FromArgb(\"#ff63b3\") }.Row(2).Column(2), new BoxView { Color = Color.FromArgb(\"#ff6590\") }.Row(2).Column(3), new BoxView { Color = Color.FromArgb(\"#ff716e\") }.Row(2).Column(4), new BoxView { Color = Color.FromArgb(\"#ff844e\") }.Row(2).Column(5), new BoxView { Color = Color.FromArgb(\"#f89832\") }.Row(2).Column(6), } }; Et si tu lances l‚Äôapplication, tu pourras alors confirmer avec certitude que notre emploi des Grid est effectivement correct : √áa fait un peu penser aux vieilles t√©l√©visions en couleur. Bon, il n‚Äôy a rien de fonctionnel pour l‚Äôutilisateur, mais maintenant que nos fondations sont pr√™tes, √ßa va grandement nous simplifier la vie ! On va enfin pouvoir s‚Äôamuser √† disposer tous les √©l√©ments de contr√¥le d√®s le prochain chapitre, en commen√ßant par la gestion du minutage. Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"30/01/2023","objectID":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/:5:0","tags":["C# markup","Grid"],"title":"Agencer les √©l√©ments d'une page .NET MAUI","uri":"/posts/tutos/my-first-app/6-arrange-elements-on-a-page/"},{"categories":null,"content":"On attaque d√©sormais la cr√©ation de la page principale de l‚Äôapplication. Mais qui dit nouvelle page dit aussi : permettre √† l‚Äôutilisateur de se rendre sur cette page ! Voyons donc comment impl√©menter la navigation d‚Äôune page √† une autre.","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":" ‚Äé Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú1 - MVVM‚Äù. H√©, mais te revoil√† ! On en a maintenant fini avec le MVVM et crois-moi, tu viens de faire un grand pas en avant ! Aujourd‚Äôhui ce sera bien plus simple, on attaque la cr√©ation de la page principale de l‚Äôapplication. Mais qui dit nouvelle page dit aussi: permettre √† l‚Äôutilisateur de s‚Äôy rendre ! Voyons donc comment impl√©menter la navigation d‚Äôune page √† une autre. ","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/:0:0","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":"Naviguer vers une nouvelle page Commen√ßons d√©j√† par ajouter notre nouvelle page. Pour cela, fais un clic droit sur le dossier Views pour ajouter un nouveau fichier, puis choisis le template ‚Äú.NET MAUI ContentPage (C#)‚Äù comme ci-dessous. On va nommer ce fichier : MusicPlayerView.cs. Comme tu l‚Äôauras remarqu√©, le template utilis√© pour cr√©er la page nous fournit un contenu par d√©faut. Il n‚Äôy a donc plus qu‚Äô√† naviguer vers cette nouvelle page ! Pour cela, rends-toi dans le fichier HomeViewModel.cs et modifie la m√©thode Enter() de la fa√ßon suivante : Nom du fichier :HomeViewModel.cs using NightClub.Views; // Rappel: sans cette ligne, √ßa ne compilerait pas ! ... [RelayCommand] async Task Enter() { await Application.Current.MainPage.Navigation.PushAsync( new MusicPlayerView()); } Tout ce qu‚Äôon fait ici, c‚Äôest acc√©der au service de navigation fourni par l‚Äôapplication pour afficher une nouvelle page de type MusicPlayerView. En fait, lorsqu‚Äôon fait appel √† la m√©thode PushAsync(), on ajoute la page MusicPlayerView tout en haut de la pile de pages d√©j√† existantes, exactement comme sur le sch√©ma ci-dessous: Comme avec un paquet de cartes √† jouer, il n‚Äôy a que celle du dessus qui est visible. ‚Äé üêí‚Äé ‚Äé Ah! Et c‚Äôest tout, je peux tester alors ? On y est presque ! En effet pour que la navigation fonctionne, on a besoin que la premi√®re page affich√©e au d√©marrage soit englob√©e dans une NavigationPage. Si tu retournes dans le fichier App.cs, il y a justement une m√©thode OnStart() qui est automatiquement ex√©cut√©e √† chaque fois que l‚Äôapp est initialis√©e. Modifie donc cette m√©thode de sorte √† d√©finir HomeView comme la page racine de l‚Äôapplication, dans une NavigationPage: Nom du fichier :App.cs protected override void OnStart() { base.OnStart(); Console.WriteLine(\"[NightClub] App - OnStart\"); MainPage = new NavigationPage(new HomeView()); } Voil√† c‚Äôest bon, relance l‚Äôapplication et clique sur le bouton Enter ! ","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/:1:0","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":"Supprimer l‚Äôen-t√™te de navigation Comme tu l‚Äôauras s√ªrement compris, notre page d‚Äôaccueil est d√©sormais contenue dans une page sp√©cialement configur√©e pour la navigation. Elle contient donc par d√©faut une en-t√™te de navigation : D‚Äôun point de vue design, ce n‚Äôest pas n√©cessairement ce que l‚Äôon souhaite. Voyons donc rapidement comment supprimer cette en-t√™te pour la page d‚Äôaccueil. Rends-toi dans le fichier HomeView.cs et invoque la m√©thode SetHasNavigationBar() dans le constructeur de la page, comme ceci: Nom du fichier :HomeView.cs public HomeView() { ... BindingContext = new HomeViewModel(); NavigationPage.SetHasNavigationBar(this, false); BackgroundColor = Colors.Black; ... } Et maintenant, si tu relances l‚Äôapp, c‚Äôest quand m√™me plus joli ! L‚Äôapplication commence √† prendre forme tout doucement, et d‚Äôautant plus avec le prochain chapitre ! On se revoit tr√®s bient√¥t pour l‚Äô√©laboration de notre page principale. Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"23/01/2023","objectID":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/:2:0","tags":["Navigation"],"title":"Naviguer vers une nouvelle page en .NET MAUI","uri":"/posts/tutos/my-first-app/5-navigate-to-a-new-page/"},{"categories":null,"content":"Dans ce chapitre, nous d√©couvrirons un patron de conception majeur pour le d√©veloppement d‚Äôapplication mobile, le Model-View-ViewModel (MVVM) !","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application r√©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":" ‚Äé Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú0 - Get Started‚Äù. Dans ce chapitre, nous d√©couvrirons un patron de conception majeur pour le d√©veloppement d‚Äôapplication mobile, le Model-View-ViewModel ! (plus couramment appel√© ‚Äúle MVVM‚Äù) ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:0:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application r√©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Le Model-View-ViewModel Le MVVM est un patron de conception qui propose au d√©veloppeur une s√©paration logique de son code en 3 couches : La View, qui correspond √† l‚Äôinterface utilisateur, c‚Äôest-√†-dire tout ce que l‚Äôon va afficher √† l‚Äô√©cran (e.g. la page HomeView), Le Model, qui fait r√©f√©rence au type de donn√©es affich√©es dans cette View, Et enfin le ViewModel, qui fait le lien entre la View et le Model. Par exemple, pour r√©cup√©rer des donn√©es depuis le Cloud ou r√©pondre aux interactions de l‚Äôutilisateur. ‚Äé üêí‚Äé ‚Äé Je vois bien la s√©paration en effet, mais pourquoi est-ce recommand√© ? L‚Äôun des principaux avantages du MVVM est de pouvoir isoler la vue (i.e. l‚Äôinterface utilisateur) de la logique ‚Äúm√©tier‚Äù. Dans le cadre de notre premi√®re page, on obtient finalement deux fichiers : HomeView.cs qui d√©finit pr√©cis√©ment comment notre page s‚Äôaffichera (i.e. une couleur de fond, une image en haut, un bouton en bas), Et HomeViewModel.cs qui regroupe toute la logique pour faire fonctionner notre page (ici, le comportement du bouton quand l‚Äôutilisateur appuie dessus). En suivant ce principe, le d√©coupage de ton code est clair et tu limites le nombre de lignes de code par fichier. Tu ne voudrais pas d‚Äôun fichier de plus de 10 000 lignes ! üòÑ¬†En plus, il n‚Äôy a aucun risque d‚Äôaffecter la logique de ton app en changeant seulement la couleur d‚Äôun bouton. ‚Äé üêí‚Äé ‚Äé C‚Äôest clair ! Mais il y a un truc que je ne comprends pas, on n‚Äôa aucun Model pour la page HomeView ? Bonne remarque ! En effet, certaines pages sont tellement simples qu‚Äôelles ne n√©cessitent pas de Model. Dans ces cas-l√†, seuls les View et ViewModel seront donc requis. ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:1:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application r√©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Le Data Binding On sait d√©sormais bien d√©couper notre code en plusieurs couches. Par exemple, d√©finir un bouton dans une View et d√©clarer son action dans un ViewModel. Mais est-ce que tu saurais dire comment elles vont fonctionner ensemble ? ‚Äé üêí‚Äé ‚Äé Hmm‚Ä¶ peut-√™tre dire au bouton de cette View d‚Äôagir selon ce qui a √©t√© d√©clar√© dans ce ViewModel ? En effet, c‚Äôest quasiment √ßa ! Cela se d√©roule en deux temps : On associe d‚Äôabord un ViewModel √† sa View (g√©n√©ralement via le BindingContext de la View), Puis on d√©finit le comportement de chaque √©l√©ment de la View dans le ViewModel, en recourant au principe du Data Binding. Le Data Binding est une technique permettant de lier deux objets de sorte que, lorsque l‚Äôun des deux est modifi√©, l‚Äôautre le sera √©galement. √áa peut para√Ætre un peu flou comme √ßa, mais tu comprendras mieux son r√¥le dans la section d‚Äôapr√®s. Pour le moment, on continue ! ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:2:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application r√©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Appliquer le MVVM Maintenant que tu connais les bases du MVVM, je vais pouvoir t‚Äôapprendre √† l‚Äôappliquer concr√®tement dans l‚Äôapplication. Commen√ßons par cr√©er un fichier qui servira de ViewModel pour notre HomeView. Pour cela, cr√©e d‚Äôabord un nouveau dossier ViewModels dans le projet, puis ajoutes-y un nouveau fichier. Ce sera une nouvelle classe vide appel√©e HomeViewModel.cs : Ensuite, remplace son contenu par le suivant: Nom du fichier :HomeViewModel.cs using System; namespace NightClub.ViewModels; public class HomeViewModel { public HomeViewModel() { } async Task Enter() { await Application.Current.MainPage.DisplayAlert( \"Well Done !\", \"You have successfully reached the end of this chapter.\", \"Next !\"); } } Bon, il n‚Äôy a vraiment rien de sp√©cial ici. C‚Äôest juste une classe d‚Äôobjet C# avec une m√©thode Enter() qui affiche du texte √† l‚Äô√©cran apr√®s un clic de l‚Äôutilisateur sur le bouton ‚ÄúENTER‚Äù. ‚Äé üêí‚Äé ‚Äé Ah ben quand m√™me, on vient de d√©finir l‚Äôaction du bouton de la page d‚Äôaccueil ! Eh oui tu as raison, mais en l‚Äô√©tat, il reste inutilisable ! Souviens-toi, il n‚Äôy a toujours aucun lien entre la HomeView et le HomeViewModel. Heureusement, il existe une librairie mise √† disposition par Microsoft qui va grandement nous simplifier la vie: le MVVM Toolkit. Cette librairie a d√©j√† √©t√© ajout√©e au projet et tu peux le v√©rifier facilement en ouvrant la gestion des paquets NuGet. Fais donc un clic droit sur les d√©pendances du projet: Et voil√† la librairie en question ! Elle s‚Äôappelle CommunityToolkit.Mvvm : ‚Äé Aller plus loin avec les paquets NuGet Voyons d√©sormais comment pr√©parer notre classe HomeViewModel pour √™tre un v√©ritable ViewModel : Premi√®rement, fais-le h√©riter de la classe ObservableObject, puis, d√©finis-le comme une classe partielle avec le mot-cl√© partial. Tu devrais avoir la configuration suivante: Nom du fichier :HomeViewModel.cs using System; using CommunityToolkit.Mvvm.ComponentModel; namespace NightClub.ViewModels; public partial class HomeViewModel : ObservableObject ... ‚Äé En faisant h√©riter HomeViewModel de la classe ObservableObject, Visual Studio rajoute automatiquement les using n√©cessaires √† la compilation. En effet, une r√©f√©rence √† CommunityToolkit.Mvvm.ComponentModel est requise pour que ObservableObject devienne r√©ellement compr√©hensible par l‚Äôapplication. Ces deux √©tapes sont n√©cessaires pour permettre au MVVM Toolkit de g√©n√©rer du code source √† la simple mention de mots-cl√©s sp√©cifiques. Concr√®tement, on √©crit un seul mot et hop, √ßa g√©n√®re tout seul des dizaines de lignes de code, c‚Äôest g√©nial, non ?! ü§ò Par exemple ici, on va d√©finir notre m√©thode Enter() comme √©tant une commande en lui rajoutant un simple attribut [RelayCommand] , voil√† comment : Nom du fichier :HomeViewModel.cs [RelayCommand] async Task Enter() { await Application.Current.MainPage.DisplayAlert( \"Well Done !\", \"You have successfully reached the end of this chapter.\", \"Next !\"); } Avec seulement un mot, on a d√©sormais une commande Enter() qui supporte la technique du Data Binding ! Et ce uniquement gr√¢ce √† la librairie MVVM Toolkit qui s‚Äôoccupe de g√©n√©rer tout le code source n√©cessaire. ‚Äé Aller plus loin avec les g√©n√©rateurs de code source MVVM ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:3:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application r√©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Bient√¥t la d√©mo ! On y est presque ! Il ne reste plus qu‚Äô√† actionner la commande Enter() au clic du bouton ‚ÄúENTER‚Äù. Tout d‚Äôabord, retourne dans le fichier HomeView.cs pour lier la vue au HomeViewModel via le **BindingContext **: Nom du fichier :HomeView.cs public HomeView() { BindingContext = new HomeViewModel(); BackgroundColor = Colors.Black; Content = ... } Puis d√©finissons l‚Äôaction du bouton EnterButton avec BindCommand pour d√©clencher la commande Enter() sp√©cifi√©e dans le HomeViewModel: Nom du fichier :HomeView.cs Button EnterButton =\u003e new Button { Text = \"ENTER\", TextColor = Colors.White, BackgroundColor = Colors.Magenta, CornerRadius = 10 } .Bold() .Paddings(50, 2, 50, 2) .CenterHorizontal() .BindCommand(\"EnterCommand\"); // Note: on doit ajouter \"Command\" apr√®s \"Enter\" Et voil√† le travail ! ‚Äé üêí‚Äé ‚Äé Ok donc si je comprends bien il faut faire √ßa √† peu pr√®s sur toutes les pages de l‚Äôapp, c‚Äôest pas si compliqu√© ! Eh bien oui en th√©orie ! Mais il manque tout de m√™me plusieurs fonctionnalit√©s cl√©s d‚Äôune application : un syst√®me d‚Äôauthentification, une base de donn√©es, etc‚Ä¶ Tiens par exemple, une fois qu‚Äôon aura cr√©√© la page principale de l‚Äôapplication, il faudra bien pouvoir s‚Äôy rendre depuis la page d‚Äôaccueil ! C‚Äôest ce qu‚Äôon verra dans le prochain chapitre. Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"12/01/2023","objectID":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/:4:0","tags":["MVVM","Data Binding",".NET Community Toolkit"],"title":"Le MVVM, pour une application r√©ussie","uri":"/posts/tutos/my-first-app/4-mvvm-for-successful-apps/"},{"categories":null,"content":"Allez, il est temps de faire tourner l‚Äôapplication. On en profitera aussi pour jeter un ≈ìil au code source ! üôÇ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/","tags":["Visual Studio","C# markup"],"title":"Premi√®re ex√©cution de l‚Äôapp .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":" ‚Äé Pour assurer le bon d√©roulement de cet article, je t‚Äôinvite √† r√©cup√©rer le projet reprenant toutes les √©tapes appliqu√©es jusqu‚Äôici dans ce cours. Pour cela, r√©f√®re-toi au guide d‚Äôinstallation du projet et repars de l‚Äôexemple situ√© dans le dossier ‚Äú0 - Get Started‚Äù. Allez, il est temps de faire tourner l‚Äôapplication. On en profitera aussi pour jeter un ≈ìil au code source ! üôÇ Mais pour que notre application puisse fonctionner, il nous reste deux points √† aborder : l‚Äôinitialisation de l‚Äôapp et surtout, g√©rer son √©tat d‚Äôex√©cution. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:0:0","tags":["Visual Studio","C# markup"],"title":"Premi√®re ex√©cution de l‚Äôapp .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Initialisation de l‚Äôapp Pour chaque plateforme cibl√©e (iOS, Android, ‚Ä¶), chaque application .NET MAUI sera initialis√©e depuis un seul point d‚Äôentr√©e via la m√©thode CreateMauiApp() situ√©e dans le fichier MauiProgram.cs. C‚Äôest ici que l‚Äôon configurera tout ce dont a besoin l‚Äôapp pour fonctionner comme on le souhaite : les services Web, les d√©pendances externes, ou bien encore les polices de caract√®res sp√©cifiques. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:1:0","tags":["Visual Studio","C# markup"],"title":"Premi√®re ex√©cution de l‚Äôapp .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Gestion de l‚Äô√©tat de l‚Äôapp Mais on aura aussi besoin de quoi d√©finir l‚Äô√©tat actuel de notre application (quelle page afficher, que faire si l‚Äôapplication est arr√™t√©e, ‚Ä¶). Et pour √ßa on a justement une classe Application d√©clar√©e dans le fichier App.cs. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:2:0","tags":["Visual Studio","C# markup"],"title":"Premi√®re ex√©cution de l‚Äôapp .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Lancement de l‚Äôapp Allez, il est temps de faire tourner l‚Äôapplication ! Choisis donc la plateforme que tu souhaites cibler, puis clique sur le bouton encadr√© en rouge pour d√©marrer le projet: Dans un premier temps, tu verras ton projet √™tre compil√© avec la configuration choisie (c‚Äôest l‚Äô√©tape du build): Sous Visual Studio for Mac, le statut actuel du projet peut facilement √™tre consult√© en bas √† gauche de la fen√™tre. Puis tu verras ton application se d√©ployer automatiquement vers la plateforme choisie (ici, une simulation de l‚ÄôiPhone 13, iOS 15.5). Et voil√† le r√©sultat ! ‚Äé üêí‚Äé ‚Äé H√©√©√©√© mais il ne se passe rien quand je clique sur le bouton ! Ce n‚Äôest √©videmment que le d√©but de notre app, le plus gros reste √† faire ! ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:3:0","tags":["Visual Studio","C# markup"],"title":"Premi√®re ex√©cution de l‚Äôapp .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"La page d‚Äôaccueil Ce que tu vois pour le moment, c‚Äôest la page d‚Äôaccueil dont le contenu est sp√©cifi√© dans le fichier HomeView.cs. Il s‚Äôagit l√† d‚Äôune ContentPage (litt√©ralement une page avec du contenu) qui est le type de page le plus courant. Et comme tu peux le voir, ce qu‚Äôelle d√©finit est tr√®s simple: Nom du fichier :HomeView.cs public HomeView() { BackgroundColor = Colors.Black; Content = new VerticalStackLayout { Children = { NightClubImage, EnterButton } }.CenterVertical(); } C‚Äôest une page avec un arri√®re-plan noir et dont le contenu est d√©fini par une image et un bouton qui sont empil√©s verticalement dans un VerticalStackLayout. Et si tu veux savoir comment sont d√©finis ces deux composants, il te suffit de regarder un peu plus bas dans le code de la page : Nom du fichier :HomeView.cs #region Controls Image NightClubImage =\u003e new Image { // .NET MAUI convertit les fichiers SVG au format PNG. Source = \"night_club.png\" }; Button EnterButton =\u003e new Button { Text = \"ENTER\", TextColor = Colors.White, BackgroundColor = Colors.Magenta, CornerRadius = 10 } .Bold() .Paddings(50, 2, 50, 2) .CenterHorizontal(); #endregion Rien de tr√®s complexe √† ce stade: On d√©finit l‚Äôimage du composant NightClubImage via la propri√©t√© ‚ÄúSource‚Äù, Et pour le bouton, on d√©finit quelques propri√©t√©s de base comme le texte, la couleur, ‚Ä¶ mais tu aurais peut-√™tre remarqu√© qu‚Äôon applique des fonctions au composant EnterButton : Bold() pour mettre en gras le texte du bouton, Paddings() pour rajouter un peu d‚Äôespace autour du texte, notamment √† gauche et √† droite du texte, Et enfin, CenterHorizontal() pour positionner le texte au centre du bouton. ‚Äé Ces m√©thodes sont fournies par un type de programmation particuli√®re appel√©e ‚ÄúDeclarative UI‚Äù ou encore ‚ÄúFluent UI‚Äù. Gr√¢ce √† cela, la page est enti√®rement cod√©e en C#, comme pour le reste de l‚Äôapp ! ‚Äé üêí‚Äé ‚Äé D‚Äôaccord ! Et il ne faudrait pas lui d√©clarer une action √† ce bouton ? Tout juste ! Et on va voir comment d√©clencher l‚Äôex√©cution de code en cliquant sur ce bouton, mais pas n‚Äôimporte comment. En effet, nous allons appliquer ce merveilleux patron de conception qu‚Äôest le Model-View-ViewModel (MVVM). Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/3-first-run-of-the-project/:4:0","tags":["Visual Studio","C# markup"],"title":"Premi√®re ex√©cution de l‚Äôapp .NET MAUI","uri":"/posts/tutos/my-first-app/3-first-run-of-the-project/"},{"categories":null,"content":"Aujourd'hui on attaque la cr√©ation de notre premi√®re application ! Juste le temps d'installer ton environnement de travail et on aura rapidement quelque chose de concret. Allez c'est parti !","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Tu vas bient√¥t pouvoir cr√©er ta premi√®re application mobile ! Juste le temps d‚Äôinstaller ton environnement de travail et on aura rapidement quelque chose de concret. Allez c‚Äôest parti ! ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:0:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Quels outils pour d√©velopper ? Voyons d√©j√† les outils qui te permettront de d√©velopper ton appli. ‚Äé üêí‚Äé ‚Äé Mais au fait, il faut √™tre sous Windows, MacOS ou Linux ? En fait, il n‚Äôy a pas de pr√©-requis particulier pour d√©velopper une app avec .NET MAUI, √† moins que tu ne tra√Ænes un ordinateur de l‚Äôavant-guerre et que tu ne mettes rien √† jour‚Ä¶ ü§î Sinon, c‚Äôest surtout une question de pr√©f√©rence ! Personnellement, je d√©veloppe sous MacOS car c‚Äôest un syst√®me que j‚Äôaffectionne, et le simulateur d‚ÄôiPhone qui y est int√©gr√© est tr√®s performant et me permet d‚Äôavoir rapidement un rendu de ce que je programme. Mais tu peux tout aussi bien d√©velopper sous Windows ou Linux ! Plus concr√®tement : sous Windows ou MacOS, c‚Äôest facile, Microsoft propose un environnement de d√©veloppement int√©gr√© tr√®s performant: Visual Studio pour Windows, et Visual Studio for Mac pour‚Ä¶ eh bien pour MacOS üòÑ et si tu es sous Linux, il te faudra recourir √† un peu plus d‚Äôing√©niosit√© (et c‚Äôest bien pour cela que tu es sous Linux, n‚Äôest-ce pas ? üòõ). Dans ce cas-l√†, je te conseille d‚Äôutiliser l‚Äôexcellent √©diteur de code source Visual Studio Code. ‚Äé Dans le cadre de ce blog, je me concentrerais uniquement sur le d√©veloppement d‚Äôapplication mobile √† l‚Äôaide de Visual Studio. En effet, son utilisation est bien plus intuitive et c‚Äôest justement cela qui pla√Æt √† tout vrai n√©ophyte. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:1:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Installation de l‚Äôenvironnement Passons maintenant √† l‚Äôinstallation de l‚Äôenvironnement de travail: Dans un premier temps, t√©l√©charge Visual Studio depuis le site officiel de Microsoft, en choisissant la version appropri√©e √† ton syst√®me (Windows ou MacOS), Puis vient le moment d‚Äôinstaller Visual Studio et son environnement de d√©veloppement .NET MAUI. Pour am√©liorer la lecture de ce blog, je te propose de directement suivre les √©tapes d‚Äôinstallation sur le site officiel: suivre les √©tapes d‚Äôinstallation sous Windows suivre les √©tapes d‚Äôinstallation sous MacOS (depuis l‚Äôarriv√©e du SDK .NET 8, il y a peut-√™tre une √©tape suppl√©mentaire d√©taill√©e ici) Enfin, t√©l√©charge mon cours depuis GitHub. Pour cela, rends-toi sur le d√©p√¥t de code du blog, clique sur le bouton ‚ÄúCode‚Äù et t√©l√©charge le tout au format .ZIP ‚Äé Avant d‚Äôaller plus loin, si tu es sous MacOS, il te faudra t‚Äôassurer d‚Äôavoir t√©l√©charg√© la derni√®re version d‚ÄôXcode qui est requise pour le simulateur d‚ÄôiPhone. Son installation peut √™tre tr√®s longue, aussi, je te conseille de le faire en parall√®le de ta lecture. ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:2:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Description du projet Une fois le fichier t√©l√©charg√© d√©compress√©, rends-toi dans le dossier des exemples associ√©s √† notre cours (Samples/NightClub). Les dossiers qui y sont entrepos√©s correspondent chacun √† une partie diff√©rente du cours: Pour le moment, ouvre le premier dossier (0 - Get Started) et double-clique sur NightClub.sln pour ouvrir le projet NightClub dans Visual Studio. La structure du projet NightClub apr√®s ouverture dans Visual Studio. ‚Äé üêí‚Äé ‚Äé Ok ! J‚Äôouvre le projet, √ßa charge‚Ä¶ Mais il y a d√©j√† plein de choses dans ce projet, on ne peut pas partir de z√©ro ? En fait, c‚Äôest d√©j√† le cas ! Le projet que tu as sous les yeux est tout neuf, mais il embarque plusieurs fichiers de base n√©cessaires au bon fonctionnement d‚Äôune application .NET MAUI: Toutes les librairies n√©cessaires au bon fonctionnement du projet sont regroup√©es dans le dossier Dependencies, Dans Platforms, tu retrouveras tous les fichiers n√©cessaires √† l‚Äôex√©cution de l‚Äôapplication, et ce pour chaque plateforme cible, Quant au dossier Properties, on y retrouve g√©n√©ralement des fichiers de configuration (il y en a d‚Äôailleurs une cr√©√©e par d√©faut pour Windows), Et puis, tu auras la possibilit√© pour chaque application de lui configurer une ic√¥ne et un √©cran de chargement ! Pour cela, on recourt g√©n√©ralement au dossier Resources pour stocker tous nos m√©dias (ic√¥nes, images, pistes audio et vid√©o, ‚Ä¶), Enfin, il faudra bien pouvoir afficher quelque chose √† l‚Äôouverture de l‚Äôapp ! Et pour √ßa, on a le dossier Views qui contient pour le moment notre premi√®re page, la fameuse page d‚Äôaccueil‚Ä¶ ‚Äé Aller plus loin avec la structure de base des projets Visual Studio Et voil√† c‚Äôest tout, et si on lan√ßait cette app ? üôÇ Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/2-setup-the-project/:3:0","tags":["Visual Studio","Setup","New Project"],"title":"Installation du projet .NET MAUI","uri":"/posts/tutos/my-first-app/2-setup-the-project/"},{"categories":null,"content":"Salut les Dev¬∑e¬∑s ! ü§ì Moi c'est J-E et mon but avec ce blog est d‚Äôaider tout d√©veloppeur d√©butant √† se lancer dans son projet d‚Äôapplication mobile au travers de cours tr√®s simples. Pas de cours th√©oriques √† rallonge, ici tu vas vite t‚Äôamuser et produire des apps sympas ! Et je t‚Äôaccompagnerai du d√©veloppement jusqu‚Äô√† la mise en ligne de ton application sur les stores.","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/1-introduction/","tags":["New Project"],"title":"Ma toute premi√®re app en .NET MAUI","uri":"/posts/tutos/my-first-app/1-introduction/"},{"categories":null,"content":"Salut les Dev¬∑e¬∑s ! ü§ì Moi c‚Äôest J-E, ou Jean-Emmanuel si tu pr√©f√®res, et je suis ravi de te savoir en train de me lire ! üòä En effet, j‚Äôavais √† c≈ìur de partager ma passion pour le d√©veloppement d‚Äôapplications mobiles cross-platforms, et tout particuli√®rement avec .NET MAUI (√† prononcer ‚Äúdote-net maoui‚Äù). Avec ce blog, je veux pouvoir aider tout d√©veloppeur d√©butant √† se lancer dans son projet d‚Äôapplication mobile au travers de cours tr√®s simples. Pas de cours th√©oriques √† rallonge, ici tu vas vite t‚Äôamuser et produire des apps sympas ! Et je t‚Äôaccompagnerai du d√©veloppement jusqu‚Äô√† la mise en ligne de ton application sur les stores. ‚Äé üêí‚Äé ‚Äé Mais au fait, c‚Äôest quoi .NET MAUI ? Tu peux m‚Äôen dire plus ? Il s‚Äôagit du framework maintenu par Microsoft pour d√©velopper des applications mobiles, mais pas que ! En fait, MAUI signifie : ‚ÄúMulti-platform App User Interface‚Äù, ce qui veut litt√©ralement dire ‚Äúapplication dot√©e d‚Äôune interface utilisateur et qui peut s‚Äôex√©cuter sur plusieurs plateformes‚Äù. .NET MAUI a √©t√© officiellement publi√© courant 2022 et se base sur l‚Äôexcellent framework Xamarin.Forms qui couvre iOS et Android uniquement. Et si tu n‚Äôen avais jamais entendu parler, pas de panique ! Moi-m√™me j‚Äôen ai appris l‚Äôexistence seulement fin 2019, et c‚Äôest gr√¢ce √† lui que j‚Äôai d√©ploy√© ma toute premi√®re application sur les stores: MyVanity. ‚Äé üêí‚Äé ‚Äé Et comment as-tu fait pour publier ta premi√®re application ? √áa t‚Äôa pris longtemps ? Et c‚Äôest l√† toute la magie de .NET MAUI, tu n‚Äôas qu‚Äô√† coder un seul programme pour qu‚Äôil fonctionne sur Android, iOS, macOS et Windows ! Et tout √ßa bien-s√ªr avec un seul langage de programmation. Et donc non, cela ne m‚Äôa pas pris tr√®s longtemps, mais cela d√©pendra surtout: de tes connaissances en d√©veloppement, de la complexit√© de ton application, et du temps que tu peux lui accorder. Dans mon cas, cela m‚Äôa pris exactement un an entre le moment o√π j‚Äôai imagin√© l‚Äôapplication et le jour o√π je l‚Äôai publi√©e sur les stores. ‚Äé üêí‚Äé ‚Äé D‚Äôaccord, alors qu‚Äôest-ce que je dois savoir avant de d√©buter mon application ? Tout d‚Äôabord bravo, tu as raison de te lancer ! Alors pour d√©marrer ton application, il te faudra : Trouver une id√©e, Concevoir la maquette, Comprendre le langage C#. Pour le premier point, c‚Äôest facile, tu l‚Äôas normalement d√©j√† fait pour arriver jusqu‚Äôici. üòõ Le deuxi√®me, c‚Äôest simplement pour avoir une id√©e pr√©cise de ce √† quoi ton application ressemblera, et pour √ßa, tu peux utiliser le tr√®s bon Adobe XD qui est gratuit ! Enfin pour finir, il te faudra conna√Ætre le langage C# pour programmer ton application, et pour cela je te propose le parcours d‚Äôapprentissage √©labor√© par Microsoft. Cela dit, si tu as d√©j√† cod√© dans ta vie, alors tu peux te lancer m√™me sans conna√Ætre le C# ! Tu apprendras tr√®s vite en voulant d√©velopper ton application. Pour ce premier cours, je te propose de d√©velopper une application pour lire des titres musicaux dans une ambiance ‚Äúbo√Æte de nuit‚Äù. üíÉüèæüï∫üèªü™© Tu feras s√ªrement quelques erreurs, mais se tromper est justement la meilleure fa√ßon d‚Äôapprendre, alors surtout: va jusqu‚Äôau bout de ton id√©e ! ‚Äé üêí‚Äé ‚Äé J‚Äôai l‚Äôid√©e en t√™te, mon design est pr√™t, et coder en C# ne me fait pas peur, on attaque ? Allez c‚Äôest parti, rendez-vous au prochain article ! Plus d‚Äôarticles dans la m√™me s√©rie: Ma toute premi√®re app en .NET MAUI Installation du projet .NET MAUI Premi√®re ex√©cution de l‚Äôapp .NET MAUI Le MVVM, pour une application r√©ussie Naviguer vers une nouvelle page en .NET MAUI Agencer les √©l√©ments d'une page .NET MAUI Affichage du lecteur MP3 - Dur√©e d'√©coute Affichage du lecteur MP3 - Contr√¥les de lecture Affichage du lecteur MP3 - Volume √âcouter de la musique en .NET MAUI avec MediaElement Contr√¥ler la t√™te de lecture avec MediaElement Contr√¥ler le volume avec MediaElement T√©l√©charger un fichier audio en .NET MAUI √âcouter une playlist avec MediaElement Cr√©er des animations avec .NET MAUI pour une ambiance disco ","date":"02/01/2023","objectID":"/posts/tutos/my-first-app/1-introduction/:0:0","tags":["New Project"],"title":"Ma toute premi√®re app en .NET MAUI","uri":"/posts/tutos/my-first-app/1-introduction/"}]